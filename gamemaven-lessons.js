// Copyright 2013 Geeky Ventures

// Each lesson has a tutor message, the code given at the start of the
// lesson, some hiddenCode that is not shown but defines some
// convenience functions and globals, a lessonSection that is
// displayed to give a sense of where you are and progress, and which
// tutorImage to display
// code, if missing, will not change the code in the box.
// hiddenCode, lessonSection, and tutorImage all will, if missing, use
// the hiddenCode from the last lesson where it was defined.
// Of these, the message is always there and the code often there.  Others
// are usually missing for most lessons.

var lessons =
  [
    { message: "Hello, I'm Game Maven! Work with me and we'll code a few games together! (click on my words to see what's next)", 
      code: "var size = 20;\nvar w = c.canvas.width;\nvar h = c.canvas.height;\nvar x = (w - size) / 2;\nvar y = (h - size) / 2;\n\n// The parameters of strokeRect are\n// strokeRect(left, top, width, height)\nc.strokeRect(x, y, size, size);\n",
      lessonSection: "Hello and Getting Started",
      tutorImage: 1,
      // Hide the access to the canvas, which is ugly, giving instead c
      // rgba() is a string, but students sometimes want to use it as
      // a function.  Let that quietly succeed, not worth confusing them
      // on that.
      hiddenCode: "var c = document.getElementById('pane').getContext('2d');\ndocument.stopAnimation = function() {if (typeof cmTID != 'undefined') {clearTimeout(cmTID);}};\nfunction rgba(r,g,b,a) {return 'rgba('+[r,g,b,a].join(',')+')';}\nfunction rgb(r,g,b,a) {return 'rgb('+[r,g,b].join(',')+')';}\n\n",
    },
    { message: "I'll teach you a lot about how to write code and build games.  If you get all the way through this tutorial, you'll build three games, be able to change the games any way you want, and be ready to build your own games!"
    },
    { message: "Before we start, if you haven't done <a href=\"http://crunchzilla.com/code-maven\">Code Maven</a> yet, you might want to do it first. Game Maven is harder and assumes you have done Code Maven or already have some programming experience. Besides, Code Maven is really fun, you wouldn't want to miss it!"
    },
    { message: "Let's get started!  Remember how this works?  Below on the left is Javascript code, on the right what the code does."
    },
    { message: "See the code on the left? We made five variables -- <span class=tutor-code>size, w, h, x, y</span> -- and then we call a function to draw a rectangle. <span class=tutor-code>w</span> and <span class=tutor-code>h</span> are the width and height of the canvas.  <span class=tutor-code>x</span> and <span class=tutor-code>y</span> are the top-left corner of the square. <span class=tutor-code>size</span> is used for both the width and height of the rectangle, so it draws a square."
    },
    { message: "Do you see why the square will always be in the center?  Try changing <span class=tutor-code>size</span> to 40.  Then try changing it to any other number you want, like 2, or 80. No matter what the size is, the square is still centered. Look at the code, do you understand how the code does that?"
    },
    { message: "Did you figure it out?  Half of the width and half of the height is the center of the screen.  If we then move the top left of the square up and to the left another half of the size of the square, we'll center the square right at the center of the screen.",
      code: "var size = 20;\nvar w = c.canvas.width;\nvar h = c.canvas.height;\nvar x = (w - size) / 2;\nvar y = (h - size) / 2;\n\n// The parameters of strokeRect are\n// strokeRect(left, top, width, height)\nc.strokeRect(x, y, size, size);\n",
      tutorImage: 4,
    },
    { message: "If that made sense, great, I bet you're ready to write some games!  If none of that made any sense, you might want to check out <a href=\"http://crunchzilla.com/code-maven\">Code Maven</a> before trying this.  Code Maven does variables, operators, drawing, and other really cool things like fractals and animation.  It's fun, you don't want to miss it!",
      tutorImage: 1,
    },
    { message: "Hey, you're still here!  You must be ready to build some games!  Let's do it!",
      lessonSection: "Building a Game",
      tutorImage: 5,
    },
    { message: "The first game we're going to build is a little space base defense game. We're going to start by drawing a base, then do some animation for shooting lasers, then make some enemies to shoot.  It's going to be great!",
      tutorImage: 3,
    },
    { message: "So you can see where we'll be going, here is an example of the kind of thing you will be building soon. There will be animation, movement, rotation, and collisions. Lots of fun code in a game!",
      tutorImage: 6,
      code: "var boxSize = 25;\nvar numBoxes = 10;\n\nfunction Box(x, y, size, a, dx, dy, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.dx = dx;\n  this.dy = dy;\n  this.da = da;\n\n  this.update = function() {\n    this.angle += this.da;\n    this.x = this.x + this.dx;\n    this.y = this.y + this.dy;\n    var s = this.size;\n    // Bounce off the edges\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n    this.stroke();\n  };\n  \n  this.stroke = function() {\n    c.save();\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle);\n    c.strokeRect(-this.size / 2, -this.size / 2,\n                 this.size, this.size);\n    c.restore();\n  };\n}\n\nvar timeStep = 50; // In milliseconds\nvar w = c.canvas.width;\nvar h = c.canvas.height;\nvar cmTID;\n\nfunction updateAll() {\n  c.clearRect(0, 0, w, h);\n  for (var i = 0; i < boxes.length; i = i + 1) {\n    boxes[i].update();\n  }\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);\n}\n\n// Create the boxes\nvar boxes = [];\nvar s = boxSize;\nfor (var i = 0; i < numBoxes; i = i + 1) {\n  var x = Math.random() * (w - s) + s / 2;\n  var y = Math.random() * (h - s) + s / 2;\n  var a = Math.random() * 2 - 1;\n  var dx = Math.random() * 2 - 1;\n  var dy = Math.random() * 2 - 1;\n  var da = 0.1 * (Math.random() * 2 - 1);\n  boxes.push(new Box(x, y, s, a, dx, dy, da));\n}\n// Do the first update\nupdateAll();\n\n",
    },
    { message: "There's a lot of code, but don't worry.  We'll walk through building each game step-by-step, with lots explanations as we go, and plenty of chances to twiddle the code and experiment. Ready to start?",
    },
    { message: "The first step is to draw the player's base.  Then we'll make it shoot lasers!  And things to shoot at! But let's start with the base.  Here's that box from before, centered right in the middle.",
      code: "var size = 80;\nvar w = c.canvas.width;\nvar h = c.canvas.height;\nvar x = (w - size) / 2;\nvar y = (h - size) / 2;\n\nc.strokeRect(x, y, size, size);\n",
      lessonSection: "Rotation",
      tutorImage: 1,
    },
    { message: "Now here is another way of drawing that box, using a translate() to move to where we want to draw it. Remember this from Code Maven?  The comments explain how the code works.",
      code: "var size = 80;\nvar w = c.canvas.width;\nvar h = c.canvas.height;\n\n// Save the canvas so we can get back to it later\nc.save();\n// Move the origin (0, 0) to the center\nc.translate(w / 2, h / 2);\n// Draw a box, moving half the size of the box\n// left and up so it is centered on 0, 0\nc.strokeRect(-size / 2, -size / 2, size, size);\n// Put the origin back where it was\nc.restore();\n",
    },
    { message: "Because we used translate() to move the origin, we now can use rotate() to rotate the box around its center. From Code Maven, you might recall the rotate() rotates around the origin and wants the rotation angle in radians (so PI is the same as 180 degrees). Here we are rotating by 30 degrees (30 degrees is PI * 30 / 180 in radians).",
      code: "var size = 80;\nvar w = c.canvas.width;\nvar h = c.canvas.height;\n\nc.save();\nc.translate(w / 2, h / 2);\nc.rotate(Math.PI * 30 / 180);\nc.strokeRect(-size / 2, -size / 2, size, size);\nc.restore();\n",
      tutorImage: 3,
    },
    { message: "Can you add a second box to this, two boxes total, right on top of each other? Make the first rotated by 30 degrees, the next rotated by another 30 degrees. Try to change the code to add that.",
      tutorImage: 4,
    },
    { message: "Let's use something like this for our base.  It's three boxes, two of them rotated. Like it?",
      code: "var size = 20;\nvar w = c.canvas.width;\nvar h = c.canvas.height;\n\nc.save();\nc.translate(w / 2, h / 2);\nc.strokeRect(-size / 2, -size / 2, size, size);\nc.rotate(Math.PI * 30 / 180);\nc.strokeRect(-size / 2, -size / 2, size, size);\nc.rotate(Math.PI * 30 / 180);\nc.strokeRect(-size / 2, -size / 2, size, size);\nc.restore();\n",
      tutorImage: 6,
    },
    { message: "Games need movement. Movement requires animation. Fortunately, animation is pretty easy. We just need to redraw the screen a few times a second.",
      code: "",
      lessonSection: "Animation",
      tutorImage: 1,
    },
    { message: "This is a simple animation. It draws a slowly spinning box, 20 frames per second. It calls update() at the beginning, update() draws the box, then update() says to call itself 50ms later.",
      code: "var timeStep = 50; // In milliseconds\nvar angle = 0;\nvar size = 80;\nvar w = c.canvas.width;\nvar h = c.canvas.height;\nvar cmTID;\n\nfunction update() {\n  // Clear the canvas\n  c.clearRect(0, 0, w, h);\n\n  // Draw our box in the center, rotated by angle\n  c.save();\n  c.translate(w / 2, h / 2);\n  c.rotate(Math.PI * angle / 180);\n  c.strokeRect(-size / 2, -size / 2, size, size);\n  c.restore();\n\n  // Increase the rotation a little each time\n  angle += 1;\n\n  clearTimeout(cmTID);\n  // Do everything again in a while\n  cmTID = setTimeout(update, timeStep);\n}\n\nupdate();",
    },
    { message: "Can you speed up how fast the box rotates? There are two ways to do that, either by changing how frequently update() is called or by changing how much the angle changes each time update() is called. Can you do it?",
      tutorImage: 3,
    },
    { message: "Can you figure out how to draw that base we did earlier? It was three boxes, the second two each rotated another 30 degrees from the previous. Can you make a slowly spinning base instead of a slowly spinning box? Try it now.",
      tutorImage: 4,
    },
    { message: "Here is what I did.  If you got something different, maybe you rotated the second and third squares by <span class=tutor-code>angle</span> instead of 30? That creates a cool and fun effect, but this is what we wanted.  If you rotate the next two squares by 30 degrees, like this code does, it makes a good base, a small spinning star-like object right in the middle. Neat, huh?",
      code: "var timeStep = 50; // In milliseconds\nvar angle = 0;\nvar size = 20;\nvar w = c.canvas.width;\nvar h = c.canvas.height;\nvar cmTID;\n\nfunction update() {\n  // Clear the canvas\n  c.clearRect(0, 0, w, h);\n\n  // Draw our base in the center, rotated by angle\n  c.save();\n  c.translate(w / 2, h / 2);\n  c.rotate(Math.PI * angle / 180);\n  c.strokeRect(-size / 2, -size / 2, size, size);\n  c.rotate(Math.PI * 30 / 180);\n  c.strokeRect(-size / 2, -size / 2, size, size);\n  c.rotate(Math.PI * 30 / 180);\n  c.strokeRect(-size / 2, -size / 2, size, size);\n  c.restore();\n\n  // Increase the rotation a little each time\n  angle += 1;\n\n  clearTimeout(cmTID);\n  // Do everything again in a while\n  cmTID = setTimeout(update, timeStep);\n}\n\nupdate();",
      tutorImage: 1,
    },
    { message: "Next, let's look at how we could shoot lasers out of our base. To start, we're going to have to track where the mouse is. The way this works is that we attach an <i>anonymous function</i> to the an <i>event handler</i> on the canvas that updates mouse.x and mouse.y every time the mouse moves inside the canvas. That way, we always know where the mouse is. Take a look at the code for that.",
      lessonSection: "Mouse Events",
      code: "var timeStep = 50; // In milliseconds\nvar angle = 0;\nvar size = 20;\nvar w = c.canvas.width;\nvar h = c.canvas.height;\nvar cmTID;\n\n// Keep track of where the mouse is.\n// Setting the canvas' onmousemove event\n// handler to an anonymous function lets us\n// run whatever code we want when the\n// mouse moves. Our code just grabs the\n// location of where the event happened\n// (which is where the mouse moved to)\n// and stores it.\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\nfunction update() {\n  // Clear the canvas\n  c.clearRect(0, 0, w, h);\n\n  // Draw our base in the center, rotated by angle\n  c.save();\n  c.translate(w / 2, h / 2);\n  c.rotate(Math.PI * angle / 180);\n  c.strokeRect(-size / 2, -size / 2, size, size);\n  c.rotate(Math.PI * 30 / 180);\n  c.strokeRect(-size / 2, -size / 2, size, size);\n  c.rotate(Math.PI * 30 / 180);\n  c.strokeRect(-size / 2, -size / 2, size, size);\n  c.restore();\n\n  // Increase the rotation a little each time\n  angle += 1;\n\n  clearTimeout(cmTID);\n  // Do everything again in a while\n  cmTID = setTimeout(update, timeStep);\n}\n\nupdate();",
    },
    { message: "Now, let's add some code to draw a line from the center of the base to where the mouse pointer is. Look in update(), see how the line is drawn? Look at the code around c.lineTo().",
      code: "var timeStep = 50; // In milliseconds\nvar angle = 0;\nvar size = 20;\nvar w = c.canvas.width;\nvar h = c.canvas.height;\nvar cmTID;\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\nfunction update() {\n  // Clear the canvas\n  c.clearRect(0, 0, w, h);\n\n  // Draw our base in the center, rotated by angle\n  c.save();\n  c.translate(w / 2, h / 2);\n  c.rotate(Math.PI * angle / 180);\n  c.strokeRect(-size / 2, -size / 2, size, size);\n  c.rotate(Math.PI * 30 / 180);\n  c.strokeRect(-size / 2, -size / 2, size, size);\n  c.rotate(Math.PI * 30 / 180);\n  c.strokeRect(-size / 2, -size / 2, size, size);\n  c.restore();\n\n  // Draw a line from the base to the mouse\n  c.beginPath();\n  c.moveTo(w / 2, h / 2);\n  c.lineTo(mouse.x, mouse.y);\n  c.stroke();\n\n  // Increase the rotation a little each time\n  angle += 1;\n\n  clearTimeout(cmTID);\n  // Do everything again in a while\n  cmTID = setTimeout(update, timeStep);\n}\n\nupdate();",
      tutorImage: 6,
    },
    { message: "We can even make it so the line only appears when the mouse button is down. We just need to add another event handler on the canvas that keeps track of whether the mouse is down. See how that works?  Look at the code where it sets onmousedown and onmouseup and how the code now checks if isMouseDown is true before drawing the line. Starting to look a bit like shooting a laser now?",
      code: "var timeStep = 50; // In milliseconds\nvar angle = 0;\nvar size = 20;\nvar w = c.canvas.width;\nvar h = c.canvas.height;\nvar cmTID;\n\n// Keep track of whether the mouse is up or down\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\nfunction update() {\n  // Clear the canvas\n  c.clearRect(0, 0, w, h);\n\n  // Draw our base in the center, rotated by angle\n  c.save();\n  c.translate(w / 2, h / 2);\n  c.rotate(Math.PI * angle / 180);\n  c.strokeRect(-size / 2, -size / 2, size, size);\n  c.rotate(Math.PI * 30 / 180);\n  c.strokeRect(-size / 2, -size / 2, size, size);\n  c.rotate(Math.PI * 30 / 180);\n  c.strokeRect(-size / 2, -size / 2, size, size);\n  c.restore();\n\n  if (isMouseDown) {\n    // Draw a line from the base to the mouse\n    c.beginPath();\n    c.moveTo(w / 2, h / 2);\n    c.lineTo(mouse.x, mouse.y);\n    c.stroke();\n  }\n\n  // Increase the rotation a little each time\n  angle += 1;\n\n  clearTimeout(cmTID);\n  // Do everything again in a while\n  cmTID = setTimeout(update, timeStep);\n}\n\nupdate();",
      tutorImage: 5,
    },
    { message: "So far, we have a base and something like a laser shooting from the base, and we've gone over the basics of drawing, animation, and handling mouse events. Next, we'll need something to shoot at.",
      lessonSection: "Objects",
      tutorImage: 1,
    },
    { message: "We're going to want enemies moving in toward our base at the center, the enemies spinning as they go, and then we'll try shoot them before they hit the base.  Let's work on the enemies now.",
    },
    { message: "Each of the enemies should have a size, position, velocity, angle, and angular velocity -- probably some other things too -- and know how to draw and move itself. We'll use objects to represent them.",
      code: "",
      tutorImage: 4,
    },
    { message: "Here is code for an Enemy object. The enemy is drawn as a box, but we could draw it as anything we wanted. Read over the code, make sure you understand it.",
      code: "// This is how you create an Enemy object\n// in Javascript, using a function\nfunction Enemy(x, y, size, a) {\n  // Variables in an Enemy object so we know\n  // where it is, how big it is, and if it\n  // is rotated. From Code Maven, you\n  // might recall that this\n  // is used with code inside an\n  // object to refer to that object's\n  // member variables and functions?\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  \n  // Enemy objects know how to draw themselves\n  this.draw = function() {\n    // Just like before, translate to move\n    // the origin, (0, 0), over to the\n    // center of the object, then draw a\n    // rotated square around it\n    c.save();\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\n// Create an enemy object located at (100, 100)\n// that is 20 pixels big and not rotated\nvar e = new Enemy(100, 100, 20, 0);\n// Tell our enemy object, e, to draw itself\ne.draw();",
      tutorImage: 1,
    },
    { message: "No animation or movement going on here yet. But let's play with this a bit. Can you add a few more boxes in different spots, different sizes, maybe rotated a bit? Try to see what you can do!",
      tutorImage: 4,
    },
    { message: "Once you bundle everything in an object, it is easy to create more. Here are a whole bunch of enemies! See how it works? Take a look over the code, because you're going to try to do something like this mostly by yourself next!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Enemy(x, y, size, a) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  \n  this.draw = function() {\n    c.save();\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\n// Add as many boxes as we can fit, separated\n// by a percentage of size, rotated randomly \n// from 0 to 90 degrees\nvar s = 24;\nfor (var x = s; x < w - s; x += s * 1.3) {\n  for (var y = s; y < h - s; y += s * 1.3) {\n    // Remember Math.random()? It returns\n    // a number between 0 and 1.\n    var a = 90 * Math.random();\n    var e = new Enemy(x, y, s, a);\n    e.draw();\n  }\n}",
      tutorImage: 5,
    },
    { message: "Okay, it's time for you to write some code! You're going to try to recreate that Enemy object on your own.  Don't worry, I'll help you do it! Follow the instructions in the comments below. Write your code below each of the comments. We'll start with the object definition.",
      code: "// I'll do this for you, getting the width and\n// height out of the canvas, then sticking \n// them into variables called w and h\nvar w = c.canvas.width;\nvar h = c.canvas.height;\n\n// Now you need to create an object defintion.\n// In Javascript, you do that by defining\n// a function.  It'll look like \n//\n// function NameOfObject(param1, param2) {\n// }\n//\n// Can you add that, but make the name of the\n// object be Enemy and use x, y, size, a\n// as the parameters?\n\n",
      lessonSection: "Quiz: Writing Objects",
      tutorImage: 1,
    },
    { message: "Next we need to add the member variables.  When we use <span class=tutor-code>new</span> (like when we say <span class=tutor-code>var e = new Enemy(50, 50, 20, 0)</span>) to create a new object, this function is called (as a <i>constructor</i>), and we should set initial values for any member variables of the object. Enemy has member variables for the position, size, and angle of the enemy, so we should initialize those. Follow the comments and I'll walk you through doing that.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Enemy(x, y, size, a) {\n  // Now we need to create member variables,\n  // which is a fancy way of referring to\n  // the variables like position that define\n  // what it means to be an Enemy object\n  //\n  // this is a keyword that refers to the object,\n  // and the way we create these member variables\n  // is to say something like\n  //\n  // this.variableName = 5;\n  //\n  // Notice you don't use var for these, just\n  // this.variableName to create a member\n  // variable in the object.\n  // \n  // Okay, so, can you create four variables,\n  // called this.x, this.y, this.size, and\n  // this.angle and set them equal to\n  // x, y, size, a?  Do that below.\n  \n  \n}",
    },
    { message: "Now we'll add code to tell an Enemy object how to draw itself. Let's start by just defining an empty draw function.  The comments will tell you what to do. Add your code below the comments.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Enemy(x, y, size, a) {  \n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  \n  // Now we need to tell the Enemy object\n  // how to draw itself.  We create what\n  // is called an instance method, which \n  // is just a way of saying a function in\n  // the object, for that.  The syntax \n  // is\n  //\n  // this.functionName = function () {\n  // };\n  //\n  // Can you go ahead and add that below\n  // and name the function draw?\n  \n  \n}",
      tutorImage: 3,
    },
    { message: "And now we'll finish it off!  Follow the comments in the code to tell an Enemy object how to draw itself.  When you're done, it should draw something.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Enemy(x, y, size, a) {  \n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  \n  this.draw = function() {\n    // Awesome, you've got your Enemy object\n    // all defined now, but draw() doesn't\n    // do anything yet. Let's make it actually\n    // draw something.  I bet you don't remember\n    // all the details of how to do that, do\n    // you?  Don't worry, I'll walk you through\n    // how to do it!\n    \n    // First, because we're going to do\n    // translation and rotation, you'll need\n    // to save the canvas state so we can\n    // restore it later.  You do that by telling\n    // the canvas (which is stored in a variable\n    // called c here) to save itself.  I'll\n    // do that for you, it looks like this:\n    c.save();\n    // Next, you need to use c.translate(x, y)\n    // to move to a location.  Where you\n    // want to move to is the x position of\n    // our object (which is stored in this.x)\n    // and same thing for the y. Can you add\n    // that below?\n    \n    \n    // And now you need to rotate.  Rotation\n    // would be pretty easy, it's just \n    // c.rotate(angle), but the angle it wants is\n    // in radians (so 2 * PI is the same as\n    // 360 degrees) and the angle we have\n    // (in this.angle) is in degrees, not\n    // radians.  So, we need to make it into\n    // radians.  You can convert degrees to\n    // radians by dividing by 180 and then\n    // multiplying by Math.PI.  So, call\n    // c.rotate() below, passing it \n    // this.angle after multiplying that\n    // angle by Math.PI and dividing it\n    // by 180.\n    \n    \n    // Finally, we get to draw our Enemy object.\n    // We can draw a rectangle using\n    //\n    // c.strokeRect(left, top, width, height);\n    //\n    // Because we did a translate to move to\n    // the center of the square, the left and top\n    // should both be the negative of half of\n    // this.size and then both the width and\n    // height should be this.size. Can you\n    // add that below?\n    \n    \n    // And, last, we need to clean up after\n    // ourselves and restore the canvas state.\n    // This looks just like the c.save() up\n    // above, but call restore instead of\n    // save.  Can you add that?\n    \n    \n  };\n}\n\n// And eveything should work now, so\n// let's try it.  You can create a new\n// enemy object and tell it to draw itself.\n// Creating a new variable and assigning it\n// a new object looks like\n//\n// var variableName = \n//   new ObjectName(parameter1, parameter2);\n//\n// Can you create a new Enemy object, passing\n// 100, 100, 50, 10 as the parameters, and\n// make the variable name e (or whatever\n// else you want)?\n\n\n// Finally, you can tell your enemy object\n// to draw itself.  If you called your variable\n// e, that would look like e.draw().  Can\n// you add that below?  If you got everything\n// right, you should see a box appear, rotated\n// by 10 degrees.\n\n\n",
      tutorImage: 1,
    },
	{ message: "Were you able to get it? If you're having trouble, make sure you are using <span class=tutor-code>this.x</span> (not x) and <span class=tutor-code>this.y</span> in the c.translate() call, <span class=tutor-code>this.angle</span> in the c.rotate(), and <span class=tutor-code>this.size</span> in the c.strokeRect().  Also, make sure you did the instructions at the bottom to create an Enemy object and to tell it to draw itself.",
	},
    { message: "Here is what I did.  It's an Enemy object that draws itself. If you had trouble with this, look over this code to see how it works.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Enemy(x, y, size, a) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  \n  this.draw = function() {\n    c.save();\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nvar e = new Enemy(100, 100, 50, 10);\ne.draw();",
      tutorImage: 2,
    },
    { message: "Let's do one more thing, try to create a bunch of objects. We'll use a for loop.  The comments below will walk you through how to do it. Can you add the code to make it work? What you get is pretty cool, try to do it!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Enemy(x, y, size, a) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  \n  this.draw = function() {\n    c.save();\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\n// Write a for loop to create a bunch of\n// enemies.  We're going to put them all on top\n// of each other, each one bigger than the last,\n// just because it looks kind of neat.\n// A for loop looks like this:\n//\n// for (var i = 1; i <= 10; i += 1) {\n// }\n//\n// That for loop counts from 1 to 10, increasing\n// by one each time, and runs whatever code\n// is inside those brackets. The variable i\n// is set to 0 the first time the code in the\n// for loop is run, then set to 1, then set to 2,\n// and so on, all the way up to 9.\n//\n// Now, create your own for loop.  Make it start\n// at 40 and end at 200, increasing by 10.\n// Inside that for loop, you are going to want to\n// create an Enemy object, and, when you create\n// it, set its location to w / 2 and h / 2,\n// which centers it nicely, and then use i\n// (or whatever variable name you used in your\n// for loop) for both the size and the angle,\n// and finally tell that Enemy object to\n// draw itself.\n// Can you replace what is below with that?\nvar e = new Enemy(100, 100, 50, 10);\ne.draw();\n",
      tutorImage: 6,
    },
	{ message: "Did you get it? I like the pattern it makes. If you didn't finish it, you really should keep working on it, it's cool when you see it!",
	  tutorImage: 1,
	},
    { message: "Whew, that's tough, isn't it? Coding is hard, but it's rewarding too. Let me show you where we are going. See the game running now? It is the first of three games we will build together. I've hidden the code from you for now. Try playing the game! When you get to the end of these lessons, you'll have coded this game mostly yourself, and you'll be able to customize the code and game any way you want!",
	  code: "// The code for this game is hidden for now.\n// Keep going in the lessons and this\n// is the first game you'll build!  And then\n// you'll make two more games after that!",
      hiddenCode: "var c = document.getElementById('pane').getContext('2d');\ndocument.stopAnimation = function() {if (typeof cmTID != 'undefined') {clearTimeout(cmTID);}};\nfunction rgba(r,g,b,a) {return 'rgba('+[r,g,b,a].join(',')+')';}\nfunction rgb(r,g,b,a) {return 'rgb('+[r,g,b].join(',')+')';}\n\n\n\nvar w = c.canvas.width;\nvar h = c.canvas.height;\nvar score = 0;\nvar gameOver = false;\n\nfunction Enemy() {\n  // Initial size\n  this.isize = 20;\n  // Initial maximum positional velocity\n  this.maxDxy = 4;\n  // Initial maximum angular velocity\n  this.maxDa = 8;\n  \n  this.init = function() {\n    // Reset the size\n    this.size = this.isize;\n    var s = this.size;\n    // Initial position is a random spot along\n    // the edge\n    if (Math.random() < 0.5) {\n      if (Math.random() < 0.5) {\n        this.x = s / 2;\n      } else {\n        this.x = w - s / 2;\n      }\n      this.y = Math.random() * (h - s) + s / 2;\n    } else {\n      this.x = Math.random() * (w - s) + s / 2;\n      if (Math.random() < 0.5) {\n        this.y = s / 2;\n      } else {\n        this.y = h - s / 2;\n      }\n    }\n    // Initial angle is random\n    this.angle = Math.random() * 360;\n    // Velocities are random\n    var maxDxy = this.maxDxy;\n    this.dx = maxDxy * (Math.random()- 0.5);\n    this.dy = maxDxy * (Math.random() - 0.5);\n    this.da = this.maxDa * (Math.random() - 0.5);\n    // Each time init() is called, increase the\n    // maximum position velocity and the initial\n    // size\n    this.maxDxy *= 1.1;\n    this.isize *= 1.05;\n  };\n  // Call init immediately in the constructor\n  this.init();\n\n  this.move = function() {\n    // Are we dead?\n    if (this.size <= 0) {\n      // We are dead, but we shall be reborn!\n      // Respawn at the original size\n      // at a random location along the edge\n      // and a little faster than before.\n      this.init();\n    }\n    // Are we being shot?\n    if (isMouseDown) {\n      var diffX = mouse.x - this.x;\n      var diffY = mouse.y - this.y;\n      var dist = Math.sqrt(diffX * diffX +\n                           diffY * diffY);\n\n      if (dist < this.size / 2 || dist < 10) {\n        // We've been hit! Decrease our size\n        // and increase the score.\n        this.size -= 2;\n        score += 110;\n        if (this.size <= 0) { return; }\n      }\n    }\n    // Move, which means change our\n    // position and angle by our velocity\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    // Have we hit an edge? If so, bounce off.\n    var s = this.size;\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    // We don't draw dead guys\n    if (s <= 0) { return; }\n    // Draw by first moving to the center of\n    // the object, rotating around that center,\n    // then drawing around the center\n    c.save();\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nfunction Base() {\n  this.x = w / 2;\n  this.y = h / 2;\n  this.size = 20;\n  this.angle = 0;\n  this.da = 3;\n\n  this.isHitBy = function(obj) {\n    // Checks if obj overlaps with this.\n    // Assumes obj has x, y, and size.\n    var x = this.x - obj.x;\n    var y = this.y - obj.y;\n    var d = Math.sqrt(x * x + y * y);\n    if (d < this.size / 2 + obj.size / 2) {\n      return true;\n    }\n    return false;\n  };\n  \n  this.move = function() {\n    // Bases only rotate, no movement\n    this.angle += this.da;\n    // Shooting the laser costs points. That\n    // keeps the player from shooting all the\n    // time even when they'd miss.\n    if (isMouseDown) {\n      score -= 10;\n    }\n  };\n\n  this.draw = function() {\n    // Draw the base as three squares, the\n    // second two rotated 30 degrees from the\n    // previous\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n    // Are we shooting the laser?\n    if (isMouseDown) {\n      // If so, draw the laser\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(mouse.x, mouse.y);\n      c.stroke();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the enemies and the base\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var e = new Enemy();\n  enemies.push(e);\n}\nvar base = new Base();\n\n// This is the main animation loop. Move\n// and redraw everything many times every\n// second.\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  // Move everything\n  for (var i = 0; i < numEnemies; i++) {\n    var enemy = enemies[i];\n    enemy.move();\n    if (base.isHitBy(enemy)) {\n      gameOver = true;\n    }\n  }\n  base.move();\n  // Erase everything\n  c.clearRect(0, 0, w, h);\n  // Redraw everything\n  for (i = 0; i < numEnemies; i++) {\n    enemies[i].draw();\n  }\n  base.draw();\n  // Show the score on the screen\n  c.fillText('Score: ' + score, w * 0.8, 20);\n  if (gameOver) {\n    // If the game is over, display game over\n    // text\n    c.save();\n    c.font = '48pt sans-serif';\n    c.textAlign = 'center';\n    c.fillStyle = 'red';\n    c.textBaseline = 'middle';\n    c.fillText('GAME OVER', w / 2, h / 2);\n    c.restore();\n  }\n  // Do it all again in a little while\n  clearTimeout(cmTID);\n  if (!gameOver) {\n    // Only animate if the game isn't over\n    cmTID = setTimeout(updateAll, timeStep);\n  }\n}\nupdateAll();",
	  tutorImage: 3,
	  lessonSection: "Where You Are Going",
	},
	{ message: "Now let's code that game! We'll start by adding animation. Now I've made it so the Enemy objects know how to move themselves.  See how it works? We animate 20 frames a second by asking the enemy to move itself, clearing the screen, then asking it to draw itself. When an enemy moves and hits the edge of the screen, we reverse the velocities, making it bounce off. Take a look over the code.",
      hiddenCode: "var c = document.getElementById('pane').getContext('2d');\ndocument.stopAnimation = function() {if (typeof cmTID != 'undefined') {clearTimeout(cmTID);}};\nfunction rgba(r,g,b,a) {return 'rgba('+[r,g,b,a].join(',')+')';}\nfunction rgb(r,g,b,a) {return 'rgb('+[r,g,b].join(',')+')';}\n\n",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Enemy(x, y, size, a, dx, dy, da) {\n  // Location of the enemy (x,y)\n  this.x = x;\n  this.y = y;\n  // How big the enemy is\n  this.size = size;\n  // How far to rotate this enemy\n  this.angle = a;\n  // dx, dy, and da are how much the\n  // position and angle change every time we move.\n  // These are also known as positional and\n  // angular velocities.\n  this.dx = dx;\n  this.dy = dy;\n  this.da = da;\n\n  this.move = function() {\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    // Bounce off the edges\n    var s = this.size;\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nvar e = new Enemy(100, 100, 20, 0, 1, 1, 1);\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  e.move();\n  c.clearRect(0, 0, w, h);\n  e.draw();\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);  \n}\nupdateAll();",
      lessonSection: "Objects and Animation",
      tutorImage: 1,
    },
    { message: "Because we did the work to make these into objects, it's easy to create more of them. Let's make 5 enemies all moving around.  The big change is at the bottom, in updateAll(), which now moves a list of enemies and then draws a list of enemies. Can you make it so there are 15 enemies? Make them move faster? Spin faster? Smaller or bigger? Add even more?",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Enemy(x, y, size, a, dx, dy, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.dx = dx;\n  this.dy = dy;\n  this.da = da;\n\n  this.move = function() {\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    // Bounce off the edges\n    var s = this.size;\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var s = 20;\n  var x = (w - s) * Math.random() + s / 2;\n  var y = (h - s) * Math.random() + s / 2;\n  var dx = 4 * (Math.random() - 0.5);\n  var dy = 4 * (Math.random() - 0.5);\n  var da = 8 * (Math.random() - 0.5);\n  var e = new Enemy(x, y, s, 0, dx, dy, da);\n  enemies.push(e);\n}\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  for (var i = 0; i < numEnemies; i++) {\n    enemies[i].move();\n  }\n  c.clearRect(0, 0, w, h);\n  for (i = 0; i < numEnemies; i++) {\n    enemies[i].draw();\n  }\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);  \n}\nupdateAll();",
      tutorImage: 5,
    },
    { message: "Now that we have enemies, let's add the base and the laser back in!  It's fun to see how it might all work together. See the new Base class in the code? It knows how to move and draw itself, including drawing the laser.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Enemy(x, y, size, a, dx, dy, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.dx = dx;\n  this.dy = dy;\n  this.da = da;\n\n  this.move = function() {\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    // Bounce off the edges\n    var s = this.size;\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nfunction Base(x, y, size, a, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.da = da;\n\n  this.move = function() {\n    this.angle += this.da;\n  };\n\n  this.draw = function() {\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n    // Draw the laser firing if it is firing\n    if (isMouseDown) {\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(mouse.x, mouse.y);\n      c.stroke();\n    }\n  };\n}\n\n\n// Keep track of whether the mouse is up or down\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var s = 20;\n  var x = (w - s) * Math.random() + s / 2;\n  var y = (h - s) * Math.random() + s / 2;\n  var dx = 4 * (Math.random()- 0.5);\n  var dy = 4 * (Math.random() - 0.5);\n  var da = 8 * (Math.random() - 0.5);\n  var e = new Enemy(x, y, s, 0, dx, dy, da);\n  enemies.push(e);\n}\nvar base = new Base(w / 2, h / 2, 20, 0, 3);\n\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  for (var i = 0; i < numEnemies; i++) {\n    enemies[i].move();\n  }\n  base.move();\n  c.clearRect(0, 0, w, h);\n  for (i = 0; i < numEnemies; i++) {\n    enemies[i].draw();\n  }\n  base.draw();\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);  \n}\nupdateAll();",
      tutorImage: 3,
    },
    { message: "When you're learning to code, it's important to write a lot of code. Let's make sure you can create a new object all on your own. Let's start with you trying to write the Base object yourself. Don't worry about shooting the laser yet, we'll add that later. This is might seem hard, but be brave, try things, and make mistakes, it's all good.  Look for the comments in the code and write your code for the Base object below them.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n// Can you write the Base object on your\n// own from scratch? You can look at the Enemy\n// object definition below and copy a lot of\n// the syntax from there.  The Base object\n// looks just like an Enemy object, but \n// it has no position velocity (no dx or dy).\n// It should still have a move method,\n// but the move function doesn't need anything\n// with dx or dy or anything bouncing off edges.\n// It should have a draw method, but the \n// draw function should not only draw one\n// box rotated by angle, but then rotate\n// by another 30 degrees and draw another box,\n// then rotate again by another 30 degrees\n// and draw a third box.  Finally, when\n// you think you have the Base object,\n// make sure to look at the very bottom of\n// the code for more instructions in the\n// comments.  Okay, go for it, try to write\n// code for the Base object below!\n\n\n\n// This is the Enemy object. You can look\n// at what it does to help you write the\n// Base object.\nfunction Enemy(x, y, size, a, dx, dy, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.dx = dx;\n  this.dy = dy;\n  this.da = da;\n\n  this.move = function() {\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    // Bounce off the edges\n    var s = this.size;\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\n\n// I'll create all the enemies for you, nothing\n// for you to do here.\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var s = 20;\n  var x = (w - s) * Math.random() + s / 2;\n  var y = (h - s) * Math.random() + s / 2;\n  var dx = 4 * (Math.random()- 0.5);\n  var dy = 4 * (Math.random() - 0.5);\n  var da = 8 * (Math.random() - 0.5);\n  var e = new Enemy(x, y, s, 0, dx, dy, da);\n  enemies.push(e);\n}\n\n// You need to create a new Base object\n// below, a new variable called base, and\n// initialize the variable to your new\n// Base object.  It's going to look a lot\n// like the new Enemy(...) code just\n// a few lines above, but you're going to\n// call the variable base instead of e,\n// pass in w / 2 and h / 2 for the x and\n// y position, set the size to 20, initial\n// angle to 0, and change of angle (da) to 3.\n// Don't forget there will be no dx or dy,\n// only five parameters to create a Base,\n// not the seven there are for an Enemy object.\n// Okay, should be just one line of code,\n// write it below!\n\n\n\n// Below is the code for the animation loop.\n// It works by telling everything to move,\n// then erasing the screen, then telling\n// everything to draw itself. Then it says\n// to do it all again in 50 ms, so that\n// ends up drawing about 20 frames/sec.\n// I've written most of the code for you,\n// all you have to do is uncomment the \n// lines (delete the \"//\") with the calls\n// to move() and draw() below.\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  // Everything that moves should move now\n  for (var i = 0; i < numEnemies; i++) {\n    // enemies[i].move();\n  }\n  // base.move();\n  \n  // Erase the screen\n  c.clearRect(0, 0, w, h);\n  // Redraw everything\n  for (i = 0; i < numEnemies; i++) {\n    // enemies[i].draw();\n  }\n  // base.draw();\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);  \n}\nupdateAll();",
      lessonSection: "Quiz: Your Own Object",
      tutorImage: 1,
    },
      { message: "Look at you code! Very cool!"},
	  { message: "Next, let's make shooting enemies actually do something. What we need to do is have Enemy objects know how to die. There are a few ways to do this, but a really fun one is to have them shrink when shot until they disappear. Let's do that! Look in the code for comments that tell you what to do!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Enemy(x, y, size, a, dx, dy, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.dx = dx;\n  this.dy = dy;\n  this.da = da;\n\n  this.move = function() {\n    var s = this.size;\n    // The first thing we want to change\n    // is to make it so an enemy with size 0\n    // is considered dead. So, move() and\n    // draw() should do nothing, just return\n    // immediately.  I'll do this for you below.\n    if (s <= 0) { return; }\n    // Next, we want to check if the mouse\n    // is on top of us and shooting. That\n    // starts with a check if the mouse is\n    // down. I'll add that for you too.\n    if (isMouseDown) {\n      // Okay, this is where you need to add\n      // code. What we need to do is see\n      // if the mouse is on top of this enemy.\n      // A way to do that is to compute the\n      // distance between the mouse position\n      // and the enemy and, if that distance\n      // is small enough, we'll say this enemy\n      // is being shot with the laser. Cool,\n      // huh?\n      // Start by creating two variables below,\n      // diffX and diffY, and set diffX\n      // to mouse.x - this.x, then set diffY\n      // similarly to the difference between\n      // mouse.y and this.y.\n      \n      \n      \n      // Now you get to use the Pythagorean\n      // Theorem!  Remember that?  It's\n      // Math.sqrt(x * x + y * y) is the length\n      // of the hypotenuse on a right triangle.\n      // Set a new variable called dist\n      // equal to the square root of\n      // diffX squared and diffY squared.\n      // It'll look just like \n      //\n      // var dist = Math.sqrt(x * x + y * y);\n      //\n      // but use diffX instead of x and\n      // diffY instead of y.  Code that up\n      // below.\n      \n      \n      \n      \n      // Okay, now is the fun part. First,\n      // write an if statement that checks\n      // if the distance is either less than\n      // half the size (size is stored in \n      // this.size as well as a local variable\n      // called s) or it is less than 10.\n      // The if statement should look like\n      //\n      // if (d < 10 || d < s / 2) {\n      // }\n      //\n      // but using dist instead of d. If you\n      // haven't seen that || before, it\n      // means or, so that means, if\n      // d is less than 10 or d is less than\n      // half of s, do whatever is in the\n      // brackets.\n      // Finally, inside those brackets,\n      // you need to reduce this.size by\n      // 1 (remember that x -= 1 means\n      // set x to 1 less than what it is).\n      // Do that below.\n      \n      \n      \n    }\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    // Bounce off the edges\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    // I added this for you.  It says that\n    // draw should do nothing for dead enemies\n    // (enemies where the size is 0).\n    if (s <= 0) { return; }\n    c.save();\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nfunction Base(x, y, size, a, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.da = da;\n\n  this.move = function() {\n    this.angle += this.da;\n  };\n\n  this.draw = function() {\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n    // Draw the laser firing if it is firing\n    if (isMouseDown) {\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(mouse.x, mouse.y);\n      c.stroke();\n    }\n  };\n}\n\n\n// Keep track of whether the mouse is up or down\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var s = 20;\n  var x = (w - s) * Math.random() + s / 2;\n  var y = (h - s) * Math.random() + s / 2;\n  var dx = 4 * (Math.random()- 0.5);\n  var dy = 4 * (Math.random() - 0.5);\n  var da = 8 * (Math.random() - 0.5);\n  var e = new Enemy(x, y, s, 0, dx, dy, da);\n  enemies.push(e);\n}\nvar base = new Base(w / 2, h / 2, 20, 0, 3);\n\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  for (var i = 0; i < numEnemies; i++) {\n    enemies[i].move();\n  }\n  base.move();\n  c.clearRect(0, 0, w, h);\n  for (i = 0; i < numEnemies; i++) {\n    enemies[i].draw();\n  }\n  base.draw();\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);  \n}\nupdateAll();",
      tutorImage: 3,
      lessonSection: "Shooting Enemies",
    },
    { message: "Isn't that great?  Here's something very similar to what you just did, but the enemies respawn somewhere random after you kill them.  Play with it and check out how it's done! Starting to feel a lot like a game?",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Enemy(x, y, size, a, dx, dy, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.dx = dx;\n  this.dy = dy;\n  this.da = da;\n\n  this.move = function() {\n    var s = this.size;\n    // The big change is here.  Instead of\n    // doing nothing for dead enemies,\n    // we give them a new location and\n    // reset their size.\n    if (s <= 0) {\n      // Restore both this.size and our copy\n      // of that size (in the variable s)\n      // to whatever it should be for a \n      // reborn enemy\n      this.size = s = 20;\n      // Make the extra effort here of respawning\n      // at the edge of the map, randomly picking\n      // the edge and where along the edge.\n      if (Math.random() < 0.5) {\n        if (Math.random() < 0.5) {\n          this.x = s / 2;\n        } else {\n          this.x = w - s / 2;\n        }\n        this.y = Math.random() * (h - s) + s / 2;\n      } else {\n        this.x = Math.random() * (w - s) + s / 2;\n        if (Math.random() < 0.5) {\n          this.y = s / 2;\n        } else {\n          this.y = h - s / 2;\n        }\n      }\n    }\n    if (isMouseDown) {\n      var diffX = mouse.x - this.x;\n      var diffY = mouse.y - this.y;\n      var dist = Math.sqrt(diffX * diffX +\n                           diffY * diffY);\n\n      // The dist < 10 check is there so it is\n      // easier to shoot very small enemies.\n      // Without it, it's too hard to hit them.\n      if (dist < s / 2 || dist < 10) {\n        // Decrement by 2 instead of 1 now\n        // that we are respawning, makes things\n        // more exciting!\n        this.size -= 2;\n        s = this.size;\n        if (s <= 0) { return; }\n      }\n    }\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    // Bounce off the edges\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    // Do nothing for dead enemies\n    // (enemies where the size is 0).\n    if (s <= 0) { return; }\n    c.save();\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nfunction Base(x, y, size, a, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.da = da;\n\n  this.move = function() {\n    this.angle += this.da;\n  };\n\n  this.draw = function() {\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n    // Draw the laser firing if it is firing\n    if (isMouseDown) {\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(mouse.x, mouse.y);\n      c.stroke();\n    }\n  };\n}\n\n\n// Keep track of whether the mouse is up or down\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var s = 20;\n  var x = (w - s) * Math.random() + s / 2;\n  var y = (h - s) * Math.random() + s / 2;\n  var dx = 4 * (Math.random()- 0.5);\n  var dy = 4 * (Math.random() - 0.5);\n  var da = 8 * (Math.random() - 0.5);\n  var e = new Enemy(x, y, s, 0, dx, dy, da);\n  enemies.push(e);\n}\nvar base = new Base(w / 2, h / 2, 20, 0, 3);\n\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  for (var i = 0; i < numEnemies; i++) {\n    enemies[i].move();\n  }\n  base.move();\n  c.clearRect(0, 0, w, h);\n  for (i = 0; i < numEnemies; i++) {\n    enemies[i].draw();\n  }\n  base.draw();\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);  \n}\nupdateAll();",
      tutorImage: 5,
    },
    { message: "We've almost got a complete game here.  There are a few more things we need. We need to keep score. The game needs to get harder and harder over time. We need to detect when the base has been hit by an enemy. And, when the base has been hit, the game should end.",
      lessonSection: "Finishing the First Game",
      tutorImage: 1,
    },
    { message: "Let's start by keeping track of a score and displaying it too. What we want to do is create a new variable called score, make it 0 to start, and then increase it every time we successfully shoot an enemy. Then we'll have to display the score in the part of the code that redraws the screen on every animation frame. Look for comments in the code that tell you what to do.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n// Right here at the top, please add a variable \n// called score and set it equal to 0.\n// Add it right below here, then look further\n// down for more stuff to do.\n\n\n\nfunction Enemy(x, y, size, a, dx, dy, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.dx = dx;\n  this.dy = dy;\n  this.da = da;\n\n  this.move = function() {\n    var s = this.size;\n    if (s <= 0) {\n      this.size = s = 20;\n      if (Math.random() < 0.5) {\n        if (Math.random() < 0.5) {\n          this.x = s / 2;\n        } else {\n          this.x = w - s / 2;\n        }\n        this.y = Math.random() * (h - s) + s / 2;\n      } else {\n        this.x = Math.random() * (w - s) + s / 2;\n        if (Math.random() < 0.5) {\n          this.y = s / 2;\n        } else {\n          this.y = h - s / 2;\n        }\n      }\n    }\n    if (isMouseDown) {\n      var diffX = mouse.x - this.x;\n      var diffY = mouse.y - this.y;\n      var dist = Math.sqrt(diffX * diffX +\n                           diffY * diffY);\n\n      if (dist < s / 2 || dist < 10) {\n        this.size -= 2;\n        s = this.size;\n        // Right here is where we know we\n        // have shot something successfully.\n        // Increase the score by 100.\n        // Add that below.\n        \n        \n        if (s <= 0) { return; }\n      }\n    }\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    if (s <= 0) { return; }\n    c.save();\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nfunction Base(x, y, size, a, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.da = da;\n\n  this.move = function() {\n    this.angle += this.da;\n  };\n\n  this.draw = function() {\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n    if (isMouseDown) {\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(mouse.x, mouse.y);\n      c.stroke();\n    }\n  };\n}\n\n\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var s = 20;\n  var x = (w - s) * Math.random() + s / 2;\n  var y = (h - s) * Math.random() + s / 2;\n  var dx = 4 * (Math.random()- 0.5);\n  var dy = 4 * (Math.random() - 0.5);\n  var da = 8 * (Math.random() - 0.5);\n  var e = new Enemy(x, y, s, 0, dx, dy, da);\n  enemies.push(e);\n}\nvar base = new Base(w / 2, h / 2, 20, 0, 3);\n\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  for (var i = 0; i < numEnemies; i++) {\n    enemies[i].move();\n  }\n  base.move();\n  c.clearRect(0, 0, w, h);\n  for (i = 0; i < numEnemies; i++) {\n    enemies[i].draw();\n  }\n  base.draw();\n  // This is where we redraw everything. Let's\n  // draw the score.  You do that by \n  // calling\n  //\n  // c.fillText(text, x, y)\n  //\n  // but make text be\n  //\n  // \"Score: \" + score\n  //\n  // so we print out the score with the\n  // label \"Score\" before it. Then for\n  // x use w * 0.8 (whcih gets you 80% of the\n  // way across the screen) and use 20 for\n  // y.  Add that below.\n  \n  \n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);  \n}\nupdateAll();",
      lessonSection: "Keeping Score",
    },
    { message: "I noticed that I never stop shooting the laser. Do you do that too? We should make a penalty for doing that, don't you think? Player should mostly shoot only to hit things.  Let's make it cost 10 points to shoot, but worth 110 points to hit an enemy. Look for comments in the code for what to do.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\nvar score = 0;\n\nfunction Enemy(x, y, size, a, dx, dy, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.dx = dx;\n  this.dy = dy;\n  this.da = da;\n\n  this.move = function() {\n    var s = this.size;\n    if (s <= 0) {\n      this.size = s = 20;\n      if (Math.random() < 0.5) {\n        if (Math.random() < 0.5) {\n          this.x = s / 2;\n        } else {\n          this.x = w - s / 2;\n        }\n        this.y = Math.random() * (h - s) + s / 2;\n      } else {\n        this.x = Math.random() * (w - s) + s / 2;\n        if (Math.random() < 0.5) {\n          this.y = s / 2;\n        } else {\n          this.y = h - s / 2;\n        }\n      }\n    }\n    if (isMouseDown) {\n      var diffX = mouse.x - this.x;\n      var diffY = mouse.y - this.y;\n      var dist = Math.sqrt(diffX * diffX +\n                           diffY * diffY);\n\n      if (dist < s / 2 || dist < 10) {\n        this.size -= 2;\n        s = this.size;\n        // Change this line here to add\n        // 110 instead of 100. That is\n        // because it will now cost 10 points\n        // to shoot, but we want to make it \n        // worth 100 points (110 - 10) to\n        // hit something.  Change the line\n        // below.\n        score += 100;\n        if (s <= 0) { return; }\n      }\n    }\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    if (s <= 0) { return; }\n    c.save();\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nfunction Base(x, y, size, a, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.da = da;\n\n  this.move = function() {\n    this.angle += this.da;\n    // Here is a good spot to check if we\n    // are shooting and to lower the score\n    // by 10 if we are.  If the mouse\n    // is down, we are shooting, and we should\n    // reduce the score by 10 (there is\n    // an example of checking if the mouse\n    // is down below in draw() if that is\n    // helpful). Add that below.\n\n    \n  };\n\n  this.draw = function() {\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n    if (isMouseDown) {\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(mouse.x, mouse.y);\n      c.stroke();\n    }\n  };\n}\n\n\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var s = 20;\n  var x = (w - s) * Math.random() + s / 2;\n  var y = (h - s) * Math.random() + s / 2;\n  var dx = 4 * (Math.random()- 0.5);\n  var dy = 4 * (Math.random() - 0.5);\n  var da = 8 * (Math.random() - 0.5);\n  var e = new Enemy(x, y, s, 0, dx, dy, da);\n  enemies.push(e);\n}\nvar base = new Base(w / 2, h / 2, 20, 0, 3);\n\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  for (var i = 0; i < numEnemies; i++) {\n    enemies[i].move();\n  }\n  base.move();\n  c.clearRect(0, 0, w, h);\n  for (i = 0; i < numEnemies; i++) {\n    enemies[i].draw();\n  }\n  base.draw();\n  c.fillText(\"Score: \" + score, w * 0.8, 20);\n  \n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);  \n}\nupdateAll();",
      tutorImage: 4,
    },
    { message: "Great! Next, let's make the game get harder and harder over time. We could do this by adding more enemies or speeding up the enemies. Let's speed up an enemy whenever it is killed and respawns, that's pretty simple to do. This time, I'd like you to do it on your own. I added comments to the code that help explain what the code does, but the comments don't tell you exactly what and where to change. Can you find the spot where the enemy dies and respawns, then increase its velocity (this.dx and this.dy) by 10% each time?",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\nvar score = 0;\n\nfunction Enemy(x, y, size, a, dx, dy, da) {\n  this.size = size;\n  // Position and angle\n  this.x = x;\n  this.y = y;\n  this.angle = a;\n  // Velocities\n  this.dx = dx;\n  this.dy = dy;\n  this.da = da;\n\n  this.move = function() {\n    var s = this.size;\n    // Are we dead?\n    if (s <= 0) {\n      // We are dead, but we shall be reborn!\n      // Respawn at the original size\n      // at a random location along the edge.\n      this.size = s = 20;\n      if (Math.random() < 0.5) {\n        if (Math.random() < 0.5) {\n          this.x = s / 2;\n        } else {\n          this.x = w - s / 2;\n        }\n        this.y = Math.random() * (h - s) + s / 2;\n      } else {\n        this.x = Math.random() * (w - s) + s / 2;\n        if (Math.random() < 0.5) {\n          this.y = s / 2;\n        } else {\n          this.y = h - s / 2;\n        }\n      }\n    }\n    // Are we being shot?\n    if (isMouseDown) {\n      var diffX = mouse.x - this.x;\n      var diffY = mouse.y - this.y;\n      var dist = Math.sqrt(diffX * diffX +\n                           diffY * diffY);\n\n      if (dist < s / 2 || dist < 10) {\n        // We've been hit! Decrease our size\n        // and increase the score.\n        this.size -= 2;\n        s = this.size;\n        score += 110;\n        if (s <= 0) { return; }\n      }\n    }\n    // Move, which means change our\n    // position and angle by our velocity\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    // Have we hit an edge? If so, bounce off.\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    // We don't draw dead guys\n    if (s <= 0) { return; }\n    // Draw by first moving to the center of\n    // the object, rotating around that center,\n    // then drawing around the center\n    c.save();\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nfunction Base(x, y, size, a, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.da = da;\n\n  this.move = function() {\n    // Bases only rotate, no movement\n    this.angle += this.da;\n    // Shooting the laser costs points. That\n    // keeps the player from shooting all the\n    // time even when they'd miss.\n    if (isMouseDown) {\n      score -= 10;\n    }\n  };\n\n  this.draw = function() {\n    // Draw the base as three squares, the\n    // second two rotated 30 degrees from the\n    // previous\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n    // Are we shooting the laser?\n    if (isMouseDown) {\n      // If so, draw the laser\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(mouse.x, mouse.y);\n      c.stroke();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the enemies and the base\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var s = 20;\n  var x = (w - s) * Math.random() + s / 2;\n  var y = (h - s) * Math.random() + s / 2;\n  var dx = 4 * (Math.random()- 0.5);\n  var dy = 4 * (Math.random() - 0.5);\n  var da = 8 * (Math.random() - 0.5);\n  var e = new Enemy(x, y, s, 0, dx, dy, da);\n  enemies.push(e);\n}\nvar base = new Base(w / 2, h / 2, 20, 0, 3);\n\n// This is the main animation loop. Move\n// and redraw everything many times every\n// second.\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  // Move everything\n  for (var i = 0; i < numEnemies; i++) {\n    enemies[i].move();\n  }\n  base.move();\n  // Erase everything\n  c.clearRect(0, 0, w, h);\n  // Redraw everything\n  for (i = 0; i < numEnemies; i++) {\n    enemies[i].draw();\n  }\n  base.draw();\n  // Show the score on the screen\n  c.fillText(\"Score: \" + score, w * 0.8, 20);\n  \n  // Do it all again in a little while\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);  \n}\nupdateAll();",
      tutorImage: 6,
      lessonSection: "Difficulty and Leveling",
    },
    { message: "Fantastic! You should have something like this now. Play with it a bit! Try changing the size of enemies when they respawn, or a different way of changing the velocities. Add more enemies, whatever you want!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\nvar score = 0;\n\nfunction Enemy(x, y, size, a, dx, dy, da) {\n  this.size = size;\n  // Position and angle\n  this.x = x;\n  this.y = y;\n  this.angle = a;\n  // Velocities\n  this.dx = dx;\n  this.dy = dy;\n  this.da = da;\n\n  this.move = function() {\n    var s = this.size;\n    // Are we dead?\n    if (s <= 0) {\n      // We are dead, but we shall be reborn!\n      // Respawn at the original size\n      // at a random location along the edge\n      // and a little faster than before.\n      this.size = s = 20;\n      this.dx *= 1.1;\n      this.dy *= 1.1;\n      if (Math.random() < 0.5) {\n        if (Math.random() < 0.5) {\n          this.x = s / 2;\n        } else {\n          this.x = w - s / 2;\n        }\n        this.y = Math.random() * (h - s) + s / 2;\n      } else {\n        this.x = Math.random() * (w - s) + s / 2;\n        if (Math.random() < 0.5) {\n          this.y = s / 2;\n        } else {\n          this.y = h - s / 2;\n        }\n      }\n    }\n    // Are we being shot?\n    if (isMouseDown) {\n      var diffX = mouse.x - this.x;\n      var diffY = mouse.y - this.y;\n      var dist = Math.sqrt(diffX * diffX +\n                           diffY * diffY);\n\n      if (dist < s / 2 || dist < 10) {\n        // We've been hit! Decrease our size\n        // and increase the score.\n        this.size -= 2;\n        s = this.size;\n        score += 110;\n        if (s <= 0) { return; }\n      }\n    }\n    // Move, which means change our\n    // position and angle by our velocity\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    // Have we hit an edge? If so, bounce off.\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    // We don't draw dead guys\n    if (s <= 0) { return; }\n    // Draw by first moving to the center of\n    // the object, rotating around that center,\n    // then drawing around the center\n    c.save();\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nfunction Base(x, y, size, a, da) {\n  this.x = x;\n  this.y = y;\n  this.size = size;\n  this.angle = a;\n  this.da = da;\n\n  this.move = function() {\n    // Bases only rotate, no movement\n    this.angle += this.da;\n    // Shooting the laser costs points. That\n    // keeps the player from shooting all the\n    // time even when they'd miss.\n    if (isMouseDown) {\n      score -= 10;\n    }\n  };\n\n  this.draw = function() {\n    // Draw the base as three squares, the\n    // second two rotated 30 degrees from the\n    // previous\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n    // Are we shooting the laser?\n    if (isMouseDown) {\n      // If so, draw the laser\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(mouse.x, mouse.y);\n      c.stroke();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the enemies and the base\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var s = 20;\n  var x = (w - s) * Math.random() + s / 2;\n  var y = (h - s) * Math.random() + s / 2;\n  var dx = 4 * (Math.random()- 0.5);\n  var dy = 4 * (Math.random() - 0.5);\n  var da = 8 * (Math.random() - 0.5);\n  var e = new Enemy(x, y, s, 0, dx, dy, da);\n  enemies.push(e);\n}\nvar base = new Base(w / 2, h / 2, 20, 0, 3);\n\n// This is the main animation loop. Move\n// and redraw everything many times every\n// second.\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  // Move everything\n  for (var i = 0; i < numEnemies; i++) {\n    enemies[i].move();\n  }\n  base.move();\n  // Erase everything\n  c.clearRect(0, 0, w, h);\n  // Redraw everything\n  for (i = 0; i < numEnemies; i++) {\n    enemies[i].draw();\n  }\n  base.draw();\n  // Show the score on the screen\n  c.fillText(\"Score: \" + score, w * 0.8, 20);\n  \n  // Do it all again in a little while\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);  \n}\nupdateAll();",
      tutorImage: 5,
    },
    { message: "Next, we will work on detecting when the base gets hit by an enemy and ending the game. But, before we can do that, there's a little problem! Right now, enemies can start anywhere on the map, including right on top of the base. That would immediately end the game! We'll need to fix that.",
      code: "",
      tutorImage: 7,
      lessonSection: "Refactoring",
    },
    { message: "We could change it by copying code, but the best way to make a change like this is to look for an opportunity to refactor the code so everything is simpler. What probably should happen is that Enemy and Base objects should know how to create themselves, which would make it easier to create them at the beginning and to respawn them when they are killed.",
      tutorImage: 1,
    },
    { message: "Take a look at the new code. What I did was add an init() method to the Enemy object, and then we use that both to create new enemies (at the beginning) and to respawn enemies (when they are killed). See how it works? You know, it's also now much easier to make them bigger each time they respawn. Can you figure out where and how to make that change?",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\nvar score = 0;\n\nfunction Enemy() {\n  // Initial size\n  this.isize = 20;\n  // Initial maximum positional velocity\n  this.maxDxy = 4;\n  // Initial maximum angular velocity\n  this.maxDa = 8;\n  \n  this.init = function() {\n    // Reset the size\n    this.size = this.isize;\n    var s = this.size;\n    // Initial position is a random spot along\n    // the edge\n    if (Math.random() < 0.5) {\n      if (Math.random() < 0.5) {\n        this.x = s / 2;\n      } else {\n        this.x = w - s / 2;\n      }\n      this.y = Math.random() * (h - s) + s / 2;\n    } else {\n      this.x = Math.random() * (w - s) + s / 2;\n      if (Math.random() < 0.5) {\n        this.y = s / 2;\n      } else {\n        this.y = h - s / 2;\n      }\n    }\n    // Initial angle is random\n    this.angle = Math.random() * 360;\n    // Velocities are random\n    var maxDxy = this.maxDxy;\n    this.dx = maxDxy * (Math.random()- 0.5);\n    this.dy = maxDxy * (Math.random() - 0.5);\n    this.da = this.maxDa * (Math.random() - 0.5);\n    // Each time init() is called, increase the\n    // maximum position velocity\n    this.maxDxy *= 1.1;\n  };\n  // Call init immediately in the constructor\n  this.init();\n\n  this.move = function() {\n    // Are we dead?\n    if (this.size <= 0) {\n      // We are dead, but we shall be reborn!\n      // Respawn at the original size\n      // at a random location along the edge\n      // and a little faster than before.\n      this.init();\n    }\n    // Are we being shot?\n    if (isMouseDown) {\n      var diffX = mouse.x - this.x;\n      var diffY = mouse.y - this.y;\n      var dist = Math.sqrt(diffX * diffX +\n                           diffY * diffY);\n\n      if (dist < this.size / 2 || dist < 10) {\n        // We've been hit! Decrease our size\n        // and increase the score.\n        this.size -= 2;\n        score += 110;\n        if (this.size <= 0) { return; }\n      }\n    }\n    // Move, which means change our\n    // position and angle by our velocity\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    // Have we hit an edge? If so, bounce off.\n    var s = this.size;\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    // We don't draw dead guys\n    if (s <= 0) { return; }\n    // Draw by first moving to the center of\n    // the object, rotating around that center,\n    // then drawing around the center\n    c.save();\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nfunction Base() {\n  this.x = w / 2;\n  this.y = h / 2;\n  this.size = 20;\n  this.angle = 0;\n  this.da = 3;\n\n  this.move = function() {\n    // Bases only rotate, no movement\n    this.angle += this.da;\n    // Shooting the laser costs points. That\n    // keeps the player from shooting all the\n    // time even when they'd miss.\n    if (isMouseDown) {\n      score -= 10;\n    }\n  };\n\n  this.draw = function() {\n    // Draw the base as three squares, the\n    // second two rotated 30 degrees from the\n    // previous\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n    // Are we shooting the laser?\n    if (isMouseDown) {\n      // If so, draw the laser\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(mouse.x, mouse.y);\n      c.stroke();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the enemies and the base\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var e = new Enemy();\n  enemies.push(e);\n}\nvar base = new Base();\n\n// This is the main animation loop. Move\n// and redraw everything many times every\n// second.\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  // Move everything\n  for (var i = 0; i < numEnemies; i++) {\n    enemies[i].move();\n  }\n  base.move();\n  // Erase everything\n  c.clearRect(0, 0, w, h);\n  // Redraw everything\n  for (i = 0; i < numEnemies; i++) {\n    enemies[i].draw();\n  }\n  base.draw();\n  // Show the score on the screen\n  c.fillText(\"Score: \" + score, w * 0.8, 20);\n  \n  // Do it all again in a little while\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);  \n}\nupdateAll();",
      tutorImage: 4,
    },
    { message: "Okay, let's do the last thing we need for a full game. The game needs to end. This game ends when an enemy hits the base. When the game ends, we should say \"GAME OVER\" and stop the animation.",
      code: "// That's it man, game over man, game over!",
      tutorImage: 6,
      lessonSection: "Collisions and Game Over",
    },
    { message: "I'll help you out by adding the \"GAME OVER\" text and stopping the animation when the game is over, but you need to add the check if the base is touching an enemy. Look for a method isHitBy() in the Base object and follow the comments there. Spend some time on this one. Try to get it before moving on.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\nvar score = 0;\nvar gameOver = false;\n\nfunction Enemy() {\n  // Initial size\n  this.isize = 20;\n  // Initial maximum positional velocity\n  this.maxDxy = 4;\n  // Initial maximum angular velocity\n  this.maxDa = 8;\n  \n  this.init = function() {\n    // Reset the size\n    this.size = this.isize;\n    var s = this.size;\n    // Initial position is a random spot along\n    // the edge\n    if (Math.random() < 0.5) {\n      if (Math.random() < 0.5) {\n        this.x = s / 2;\n      } else {\n        this.x = w - s / 2;\n      }\n      this.y = Math.random() * (h - s) + s / 2;\n    } else {\n      this.x = Math.random() * (w - s) + s / 2;\n      if (Math.random() < 0.5) {\n        this.y = s / 2;\n      } else {\n        this.y = h - s / 2;\n      }\n    }\n    // Initial angle is random\n    this.angle = Math.random() * 360;\n    // Velocities are random\n    var maxDxy = this.maxDxy;\n    this.dx = maxDxy * (Math.random()- 0.5);\n    this.dy = maxDxy * (Math.random() - 0.5);\n    this.da = this.maxDa * (Math.random() - 0.5);\n    // Each time init() is called, increase the\n    // maximum position velocity and the initial\n    // size\n    this.maxDxy *= 1.1;\n    this.isize *= 1.05;\n  };\n  // Call init immediately in the constructor\n  this.init();\n\n  this.move = function() {\n    // Are we dead?\n    if (this.size <= 0) {\n      // We are dead, but we shall be reborn!\n      // Respawn at the original size\n      // at a random location along the edge\n      // and a little faster than before.\n      this.init();\n    }\n    // Are we being shot?\n    if (isMouseDown) {\n      var diffX = mouse.x - this.x;\n      var diffY = mouse.y - this.y;\n      var dist = Math.sqrt(diffX * diffX +\n                           diffY * diffY);\n\n      if (dist < this.size / 2 || dist < 10) {\n        // We've been hit! Decrease our size\n        // and increase the score.\n        this.size -= 2;\n        score += 110;\n        if (this.size <= 0) { return; }\n      }\n    }\n    // Move, which means change our\n    // position and angle by our velocity\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    // Have we hit an edge? If so, bounce off.\n    var s = this.size;\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    // We don't draw dead guys\n    if (s <= 0) { return; }\n    // Draw by first moving to the center of\n    // the object, rotating around that center,\n    // then drawing around the center\n    c.save();\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nfunction Base() {\n  this.x = w / 2;\n  this.y = h / 2;\n  this.size = 20;\n  this.angle = 0;\n  this.da = 3;\n\n  this.isHitBy = function(obj) {\n    // This is what you need to write.\n    // Should take an object, obj, and check\n    // if the base (which you can refer to\n    // as this) is being touched by obj.\n    // The way you should compute this looks\n    // a little like the check to see if an\n    // enemy is being shot by the laser\n    // (which is above in Enemy's move()\n    // method). First, you should compute\n    // the distance between this and obj\n    // (so, you'll need things like the \n    // difference between this.x and obj.x).\n    // Then, see if they overlap (hint:\n    // they overlap if the distance is \n    // less than this.size / 2 + \n    // obj.size / 2). If they do overlap,\n    // you should return true. Otherwise,\n    // you should return false. Okay, write\n    // your code below!\n    \n    \n    return false;\n  };\n  \n  this.move = function() {\n    // Bases only rotate, no movement\n    this.angle += this.da;\n    // Shooting the laser costs points. That\n    // keeps the player from shooting all the\n    // time even when they'd miss.\n    if (isMouseDown) {\n      score -= 10;\n    }\n  };\n\n  this.draw = function() {\n    // Draw the base as three squares, the\n    // second two rotated 30 degrees from the\n    // previous\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n    // Are we shooting the laser?\n    if (isMouseDown) {\n      // If so, draw the laser\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(mouse.x, mouse.y);\n      c.stroke();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the enemies and the base\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var e = new Enemy();\n  enemies.push(e);\n}\nvar base = new Base();\n\n// This is the main animation loop. Move\n// and redraw everything many times every\n// second.\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  // Move everything\n  for (var i = 0; i < numEnemies; i++) {\n    var enemy = enemies[i];\n    enemy.move();\n    if (base.isHitBy(enemy)) {\n      gameOver = true;\n    }\n  }\n  base.move();\n  // Erase everything\n  c.clearRect(0, 0, w, h);\n  // Redraw everything\n  for (i = 0; i < numEnemies; i++) {\n    enemies[i].draw();\n  }\n  base.draw();\n  // Show the score on the screen\n  c.fillText('Score: ' + score, w * 0.8, 20);\n  if (gameOver) {\n    // If the game is over, display game over\n    // text\n    c.save();\n    c.font = '48pt sans-serif';\n    c.textAlign = 'center';\n    c.fillStyle = 'red';\n    c.textBaseline = 'middle';\n    c.fillText('GAME OVER', w / 2, h / 2);\n    c.restore();\n  }\n  // Do it all again in a little while\n  clearTimeout(cmTID);\n  if (!gameOver) {\n    // Only animate if the game isn't over\n    cmTID = setTimeout(updateAll, timeStep);\n  }\n}\nupdateAll();",
      tutorImage: 1,
    },
    { message: "You're done!  You have a complete game! It works beginning to end, and you did it! Great job! Play with it, change the code more, enjoy it!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\nvar score = 0;\nvar gameOver = false;\n\nfunction Enemy() {\n  // Initial size\n  this.isize = 20;\n  // Initial maximum positional velocity\n  this.maxDxy = 4;\n  // Initial maximum angular velocity\n  this.maxDa = 8;\n  \n  this.init = function() {\n    // Reset the size\n    this.size = this.isize;\n    var s = this.size;\n    // Initial position is a random spot along\n    // the edge\n    if (Math.random() < 0.5) {\n      if (Math.random() < 0.5) {\n        this.x = s / 2;\n      } else {\n        this.x = w - s / 2;\n      }\n      this.y = Math.random() * (h - s) + s / 2;\n    } else {\n      this.x = Math.random() * (w - s) + s / 2;\n      if (Math.random() < 0.5) {\n        this.y = s / 2;\n      } else {\n        this.y = h - s / 2;\n      }\n    }\n    // Initial angle is random\n    this.angle = Math.random() * 360;\n    // Velocities are random\n    var maxDxy = this.maxDxy;\n    this.dx = maxDxy * (Math.random()- 0.5);\n    this.dy = maxDxy * (Math.random() - 0.5);\n    this.da = this.maxDa * (Math.random() - 0.5);\n    // Each time init() is called, increase the\n    // maximum position velocity and the initial\n    // size\n    this.maxDxy *= 1.1;\n    this.isize *= 1.05;\n  };\n  // Call init immediately in the constructor\n  this.init();\n\n  this.move = function() {\n    // Are we dead?\n    if (this.size <= 0) {\n      // We are dead, but we shall be reborn!\n      // Respawn at the original size\n      // at a random location along the edge\n      // and a little faster than before.\n      this.init();\n    }\n    // Are we being shot?\n    if (isMouseDown) {\n      var diffX = mouse.x - this.x;\n      var diffY = mouse.y - this.y;\n      var dist = Math.sqrt(diffX * diffX +\n                           diffY * diffY);\n\n      if (dist < this.size / 2 || dist < 10) {\n        // We've been hit! Decrease our size\n        // and increase the score.\n        this.size -= 2;\n        score += 110;\n        if (this.size <= 0) { return; }\n      }\n    }\n    // Move, which means change our\n    // position and angle by our velocity\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    // Have we hit an edge? If so, bounce off.\n    var s = this.size;\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    // We don't draw dead guys\n    if (s <= 0) { return; }\n    // Draw by first moving to the center of\n    // the object, rotating around that center,\n    // then drawing around the center\n    c.save();\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nfunction Base() {\n  this.x = w / 2;\n  this.y = h / 2;\n  this.size = 20;\n  this.angle = 0;\n  this.da = 3;\n\n  this.isHitBy = function(obj) {\n    // Checks if obj overlaps with this.\n    // Assumes obj has x, y, and size.\n    var x = this.x - obj.x;\n    var y = this.y - obj.y;\n    var d = Math.sqrt(x * x + y * y);\n    if (d < this.size / 2 + obj.size / 2) {\n      return true;\n    }\n    return false;\n  };\n  \n  this.move = function() {\n    // Bases only rotate, no movement\n    this.angle += this.da;\n    // Shooting the laser costs points. That\n    // keeps the player from shooting all the\n    // time even when they'd miss.\n    if (isMouseDown) {\n      score -= 10;\n    }\n  };\n\n  this.draw = function() {\n    // Draw the base as three squares, the\n    // second two rotated 30 degrees from the\n    // previous\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n    // Are we shooting the laser?\n    if (isMouseDown) {\n      // If so, draw the laser\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(mouse.x, mouse.y);\n      c.stroke();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the enemies and the base\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var e = new Enemy();\n  enemies.push(e);\n}\nvar base = new Base();\n\n// This is the main animation loop. Move\n// and redraw everything many times every\n// second.\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  // Move everything\n  for (var i = 0; i < numEnemies; i++) {\n    var enemy = enemies[i];\n    enemy.move();\n    if (base.isHitBy(enemy)) {\n      gameOver = true;\n    }\n  }\n  base.move();\n  // Erase everything\n  c.clearRect(0, 0, w, h);\n  // Redraw everything\n  for (i = 0; i < numEnemies; i++) {\n    enemies[i].draw();\n  }\n  base.draw();\n  // Show the score on the screen\n  c.fillText('Score: ' + score, w * 0.8, 20);\n  if (gameOver) {\n    // If the game is over, display game over\n    // text\n    c.save();\n    c.font = '48pt sans-serif';\n    c.textAlign = 'center';\n    c.fillStyle = 'red';\n    c.textBaseline = 'middle';\n    c.fillText('GAME OVER', w / 2, h / 2);\n    c.restore();\n  }\n  // Do it all again in a little while\n  clearTimeout(cmTID);\n  if (!gameOver) {\n    // Only animate if the game isn't over\n    cmTID = setTimeout(updateAll, timeStep);\n  }\n}\nupdateAll();",
      tutorImage: 5,
      lessonSection: "First Game Completed",
    },
      { message: "One of the great things about having access to the code of the game is that you can make very different feeling games just with a few changes to the code. Here is a version a teen who did Game Maven made. Try playing it! It's just a few changes to make it, but it's really different!",
		code: "var w = c.canvas.width;\nvar h = c.canvas.height;\nvar score = 0;\nvar gameOver = false;\n\nfunction Enemy() {\n  // Initial size\n  this.isize = 20;\n  // Initial maximum positional velocity\n  this.maxDxy = 4;\n  // Initial maximum angular velocity\n  this.maxDa = 8;\n  \n  this.init = function() {\n    // Reset the size\n    this.size = this.isize;\n    var s = this.size;\n    // Initial position is a random spot along\n    // the edge\n    if (Math.random() < 0.5) {\n      if (Math.random() < 0.5) {\n        this.x = s / 2;\n      } else {\n        this.x = w - s / 2;\n      }\n      this.y = Math.random() * (h - s) + s / 2;\n    } else {\n      this.x = Math.random() * (w - s) + s / 2;\n      if (Math.random() < 0.5) {\n        this.y = s / 2;\n      } else {\n        this.y = h - s / 2;\n      }\n    }\n    // Initial angle is random\n    this.angle = Math.random() * 360;\n    // Velocities are random\n    var maxDxy = this.maxDxy;\n    this.dx = maxDxy * (Math.random()- 0.5);\n    this.dy = maxDxy * (Math.random() - 0.5);\n    this.da = this.maxDa * (Math.random() - 0.5);\n    // Each time init() is called, increase the\n    // maximum position velocity and the initial\n    // size\n    this.maxDxy *= 1.1;\n    this.isize *= 1.05;\n  };\n  // Call init immediately in the constructor\n  this.init();\n\n  this.move = function() {\n    // Are we dead?\n    if (this.size <= 0 && !this.reallyDie) {\n      // We are dead, but we shall be reborn!\n      // Respawn at the original size\n      // at a random location along the edge\n      // and a little faster than before.\n      this.init();\n    }\n    // Are we being shot?\n    if (isMouseDown) {\n      var diffX = mouse.x - this.x;\n      var diffY = mouse.y - this.y;\n      var dist = Math.sqrt(diffX * diffX +\n                           diffY * diffY);\n\n      if (dist < this.size / 2 || dist < 10) {\n        // We've been hit! Decrease our size\n        // and increase the score.\n        this.size -= 2;\n        if (this.size > 10) {\n          var e = new Enemy();\n          e.x = this.x + e.dx * 5;\n          e.y = this.y + e.dy * 5;\n          e.size = 4;\n          e.reallyDie = true;\n          enemies.push(e);\n        }\n        score += 110;\n        if (this.size <= 0) { return; }\n      }\n    }\n    // Move, which means change our\n    // position and angle by our velocity\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    // Have we hit an edge? If so, bounce off.\n    var s = this.size;\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    // We don't draw dead guys\n    if (s <= 0) { return; }\n    // Draw by first moving to the center of\n    // the object, rotating around that center,\n    // then drawing around the center\n    c.save();\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nfunction Base() {\n  this.x = w / 2;\n  this.y = h / 2;\n  this.size = 20;\n  this.angle = 0;\n  this.da = 3;\n\n  this.isHitBy = function(obj) {\n    // Checks if obj overlaps with this.\n    // Assumes obj has x, y, and size.\n    var x = this.x - obj.x;\n    var y = this.y - obj.y;\n    var d = Math.sqrt(x * x + y * y);\n    if (d < this.size / 2 + obj.size / 2) {\n      return true;\n    }\n    return false;\n  };\n  \n  this.move = function() {\n    // Bases only rotate, no movement\n    this.angle += this.da;\n    // Shooting the laser costs points. That\n    // keeps the player from shooting all the\n    // time even when they'd miss.\n    if (isMouseDown) {\n      score -= 10;\n    }\n  };\n\n  this.draw = function() {\n    // Draw the base as three squares, the\n    // second two rotated 30 degrees from the\n    // previous\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n    // Are we shooting the laser?\n    if (isMouseDown) {\n      // If so, draw the laser\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(mouse.x, mouse.y);\n      c.stroke();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the enemies and the base\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var e = new Enemy();\n  enemies.push(e);\n}\nvar base = new Base();\n\n// This is the main animation loop. Move\n// and redraw everything many times every\n// second.\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  // Move everything\n  for (var i = 0; i < enemies.length; i++) {\n    var enemy = enemies[i];\n    enemy.move();\n    if (base.isHitBy(enemy)) {\n      gameOver = true;\n    }\n  }\n  base.move();\n  // Kill off dead shards\n  var l = enemies.length;\n  for (i = l - 1; i >= 0; i--) {\n    var e = enemies[i];\n    if (e.size <= 0 && e.reallyDie) {\n      enemies.splice(i, 1);\n    }\n  }\n  // Erase everything\n  c.clearRect(0, 0, w, h);\n  // Redraw everything\n  for (i = 0; i < enemies.length; i++) {\n    enemies[i].draw();\n  }\n  base.draw();\n  // Show the score on the screen\n  c.fillText('Score: ' + score, w * 0.8, 20);\n  if (gameOver) {\n    // If the game is over, display game over\n    // text\n    c.save();\n    c.font = '48pt sans-serif';\n    c.textAlign = 'center';\n    c.fillStyle = 'red';\n    c.textBaseline = 'middle';\n    c.fillText('GAME OVER', w / 2, h / 2);\n    c.restore();\n  }\n  // Do it all again in a little while\n  clearTimeout(cmTID);\n  if (!gameOver) {\n    // Only animate if the game isn't over\n    cmTID = setTimeout(updateAll, timeStep);\n  }\n}\nupdateAll();",
		tutorImage: 1,
	  },
	  { message: "Let me put it back to the earlier code for the game so you can work from that. Now you try twiddling it!  Maybe add more enemies?  Make the enemies bigger but the laser shrink them faster?  Make the enemies faster?  Make the enemies random sizes? Try something, anything you want, change it!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\nvar score = 0;\nvar gameOver = false;\n\nfunction Enemy() {\n  // Initial size\n  this.isize = 20;\n  // Initial maximum positional velocity\n  this.maxDxy = 4;\n  // Initial maximum angular velocity\n  this.maxDa = 8;\n  \n  this.init = function() {\n    // Reset the size\n    this.size = this.isize;\n    var s = this.size;\n    // Initial position is a random spot along\n    // the edge\n    if (Math.random() < 0.5) {\n      if (Math.random() < 0.5) {\n        this.x = s / 2;\n      } else {\n        this.x = w - s / 2;\n      }\n      this.y = Math.random() * (h - s) + s / 2;\n    } else {\n      this.x = Math.random() * (w - s) + s / 2;\n      if (Math.random() < 0.5) {\n        this.y = s / 2;\n      } else {\n        this.y = h - s / 2;\n      }\n    }\n    // Initial angle is random\n    this.angle = Math.random() * 360;\n    // Velocities are random\n    var maxDxy = this.maxDxy;\n    this.dx = maxDxy * (Math.random()- 0.5);\n    this.dy = maxDxy * (Math.random() - 0.5);\n    this.da = this.maxDa * (Math.random() - 0.5);\n    // Each time init() is called, increase the\n    // maximum position velocity and the initial\n    // size\n    this.maxDxy *= 1.1;\n    this.isize *= 1.05;\n  };\n  // Call init immediately in the constructor\n  this.init();\n\n  this.move = function() {\n    // Are we dead?\n    if (this.size <= 0) {\n      // We are dead, but we shall be reborn!\n      // Respawn at the original size\n      // at a random location along the edge\n      // and a little faster than before.\n      this.init();\n    }\n    // Are we being shot?\n    if (isMouseDown) {\n      var diffX = mouse.x - this.x;\n      var diffY = mouse.y - this.y;\n      var dist = Math.sqrt(diffX * diffX +\n                           diffY * diffY);\n\n      if (dist < this.size / 2 || dist < 10) {\n        // We've been hit! Decrease our size\n        // and increase the score.\n        this.size -= 2;\n        score += 110;\n        if (this.size <= 0) { return; }\n      }\n    }\n    // Move, which means change our\n    // position and angle by our velocity\n    this.angle += this.da;\n    this.x += this.dx;\n    this.y += this.dy;\n    // Have we hit an edge? If so, bounce off.\n    var s = this.size;\n    if (this.x < s / 2 ||\n        this.x + s / 2 > w) {\n      this.dx = -this.dx;\n      this.da = -this.da;\n    }\n    if (this.y < s / 2 ||\n        this.y + s / 2 > h) {\n      this.dy = -this.dy;\n      this.da = -this.da;\n    }\n  };\n\n  this.draw = function() {\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    // We don't draw dead guys\n    if (s <= 0) { return; }\n    // Draw by first moving to the center of\n    // the object, rotating around that center,\n    // then drawing around the center\n    c.save();\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\nfunction Base() {\n  this.x = w / 2;\n  this.y = h / 2;\n  this.size = 20;\n  this.angle = 0;\n  this.da = 3;\n\n  this.isHitBy = function(obj) {\n    // Checks if obj overlaps with this.\n    // Assumes obj has x, y, and size.\n    var x = this.x - obj.x;\n    var y = this.y - obj.y;\n    var d = Math.sqrt(x * x + y * y);\n    if (d < this.size / 2 + obj.size / 2) {\n      return true;\n    }\n    return false;\n  };\n  \n  this.move = function() {\n    // Bases only rotate, no movement\n    this.angle += this.da;\n    // Shooting the laser costs points. That\n    // keeps the player from shooting all the\n    // time even when they'd miss.\n    if (isMouseDown) {\n      score -= 10;\n    }\n  };\n\n  this.draw = function() {\n    // Draw the base as three squares, the\n    // second two rotated 30 degrees from the\n    // previous\n    c.save();\n    var s = this.size;\n    var x = this.x;\n    var y = this.y;\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.rotate(30 * Math.PI / 180);\n    c.strokeRect(-s / 2, -s / 2, s, s);\n    c.restore();\n    // Are we shooting the laser?\n    if (isMouseDown) {\n      // If so, draw the laser\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(mouse.x, mouse.y);\n      c.stroke();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the enemies and the base\nvar enemies = [];\nvar numEnemies = 5;\nfor (var i = 0; i < numEnemies; i++) {\n  var e = new Enemy();\n  enemies.push(e);\n}\nvar base = new Base();\n\n// This is the main animation loop. Move\n// and redraw everything many times every\n// second.\nvar cmTID;\nvar timeStep = 50; // In milliseconds\nfunction updateAll() {\n  // Move everything\n  for (var i = 0; i < numEnemies; i++) {\n    var enemy = enemies[i];\n    enemy.move();\n    if (base.isHitBy(enemy)) {\n      gameOver = true;\n    }\n  }\n  base.move();\n  // Erase everything\n  c.clearRect(0, 0, w, h);\n  // Redraw everything\n  for (i = 0; i < numEnemies; i++) {\n    enemies[i].draw();\n  }\n  base.draw();\n  // Show the score on the screen\n  c.fillText('Score: ' + score, w * 0.8, 20);\n  if (gameOver) {\n    // If the game is over, display game over\n    // text\n    c.save();\n    c.font = '48pt sans-serif';\n    c.textAlign = 'center';\n    c.fillStyle = 'red';\n    c.textBaseline = 'middle';\n    c.fillText('GAME OVER', w / 2, h / 2);\n    c.restore();\n  }\n  // Do it all again in a little while\n  clearTimeout(cmTID);\n  if (!gameOver) {\n    // Only animate if the game isn't over\n    cmTID = setTimeout(updateAll, timeStep);\n  }\n}\nupdateAll();",
		tutorImage: 3,
	  },

    { message: "Whew! That first game was fun!  Want to do another game?",
      lessonSection: "Starting Another Game",
      tutorImage: 1,
      code: "// Wait, there's more?",
    },
    { message: "The next game is going to be a cannon firing game. These have been around for a while, but have gotten really popular with Angry Birds and all. When we do this, we're going to do a mini-physics simulator for the projectiles and blow things up too. Sound good?",
      tutorImage: 3,
      code: "// I get to write another game? Really?",
    },
    { message: "One of the hardest steps in writing code is starting completely from scratch. It's hard to start from a blank page. It can be really hard to remember how to do things, the syntax of the code, and where things go.",
      code: "", 
      lessonSection: "Coding from Nothing",
      tutorImage: 1,
    },
    { message: "Let's try that now. Here's a completely blank page. This game is going to need enemies for our cannon to shoot. Try to write that Enemy object from before from scratch, with move() and draw() methods and member variables for position, size, and angle, then create a new Enemy object and tell it to draw itself.",
      tutorImage: 6,
    },
    { message: "That's really hard, isn't it?",
      tutorImage: 7,
    },
    { message: "You might have been able to do it completely from memory, if you could, that's excellent, I'm impressed! Or maybe you prompted your memory by looking back at the previous lessons or maybe with Google searches for Javascript documentation? Or maybe you went back and just copy-and-pasted big chunks of code out and then fixed it up? That last one isn't pretty, but, hey, as long as you put in the effort to try to do it, any of those work, whatever helps you write code!",
      tutorImage: 2,
    },
    { message: "Let's try something else. Let's do the Cannon object from scratch. Here's what I'm thinking it might look like, kind of looks like a cannon sitting on a stand, right?",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nvar x = w / 2;\nvar y = h / 2;\nvar s = 100;\nvar angle = 30;\n\nc.save();\n// Move to the center of the cannon\nc.translate(x, y);\n// The cannon sits on a little stand\n// half of its height and 10% its width\nc.strokeRect(-s * 0.1 / 2, 0, s * 0.1, s / 2);\n// The cannon itself is two rectangles,\n// next to each other and rotated\n// through the angle\nc.rotate(-angle * Math.PI / 180);\nc.fillRect(-s * 0.4, -s * 0.4 / 2,\n           s * 0.4, s * 0.4);\nc.fillRect(0, -s * 0.1, s * 0.5, s * 0.2);\nc.restore();",
      tutorImage: 3,
    },
    { message: "Now, can you write a Cannon object, with member variables for position, size, and angle, and an empty move() method and a draw() method that draws a cannon like this? And then can you create a cannon in the bottom left corner of size 30 and ask it to draw itself? Try to do it before going on.",
      tutorImage: 1,
    },
    { message: "That's still really hard without seeing any other code to prompt you, isn't it? Here's what I thought we'd use for drawing the cannon, all the code is now below. Try changing the value of <span class=tutor-code>this.angle</span> for the cannon in the code to see how that works because, next, we are going to make the angle of the cannon track where the mouse is!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Cannon() {\n  this.size = 30;\n  // The cannon fits snugly at the bottom left\n  // corner of the screen\n  this.x = this.size / 2;\n  this.y = h - this.size / 2;\n  this.angle = 45;\n  \n  this.draw = function() {\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.save();\n    // Move to the center of the cannon\n    c.translate(x, y);\n    // The cannon sits on a little stand\n    // half of its height and 10% its width\n    c.strokeRect(-s * 0.1 / 2, 0, s * 0.1, s / 2);\n    // The cannon itself is two rectangles,\n    // next to each other and rotated\n    // through the angle\n    c.rotate(-this.angle * Math.PI / 180);\n    c.fillRect(-s * 0.4, -s * 0.4 / 2,\n               s * 0.4, s * 0.4);\n    c.fillRect(0, -s * 0.1, s * 0.5, s * 0.2);\n    c.restore();\n  };\n  \n  this.move = function() {\n    // We will change angle here later\n    // to track the mouse location\n  };\n}\n\nvar cannon = new Cannon();\ncannon.draw();",
      lessonSection: "Building the Second Game",
      tutorImage: 3,
    },
    { message: "Okay, take a look at this code. Three things are different now. We have a simple animation loop that calls move() and draw() on the cannon, animating at 20 frames per second. We keep track of the mouse location. And we update the angle based on the mouse location in move() using arctan (the inverse of the tangent, some trigonometry that you may have seen in math classes) so the cannon always points at the mouse. See how that works?",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Cannon() {\n  // Constants\n  this.size = 30;\n  // Position\n  // The cannon fits snugly at the bottom left\n  // corner of the screen\n  this.x = this.size / 2;\n  this.y = h - this.size / 2;\n  // Initial angle, this tracks the mouse soon\n  this.angle = 45;\n  \n  this.move = function() {\n    // Change angle to match mouse location\n    var diffX = mouse.x - this.x;\n    var diffY = mouse.y - this.y;\n    var a = -Math.atan2(diffY, diffX);\n    this.angle = a / Math.PI * 180;\n  };\n\n  this.draw = function() {\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.save();\n    // Move to the center of the cannon\n    c.translate(x, y);\n    // The cannon sits on a little stand\n    // half of its height and 10% its width\n    c.strokeRect(-s * 0.1 / 2, 0,\n                 s * 0.1, s / 2);\n    // The cannon itself is two rectangles,\n    // next to each other and rotated\n    // through the angle\n    c.rotate(-this.angle * Math.PI / 180);\n    c.fillRect(-s * 0.4, -s * 0.4 / 2,\n               s * 0.4, s * 0.4);\n    c.fillRect(0, -s * 0.1, s * 0.5, s * 0.2);\n    c.restore();\n  };\n}\n\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the objects in the world\nvar cannon = new Cannon();\n\n// Animation loop\nvar cmTID;\nvar timeStep = 50;  // milliseconds\nfunction updateAll() {\n  // Move everything\n  cannon.move();\n  // Redraw everything\n  c.clearRect(0, 0, w, h);\n  cannon.draw();\n  \n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);\n}\nupdateAll();",
      lessonSection: "Pointing at the Mouse",
      tutorImage: 7,
    },
    { message: "Let's work on the next step to get this game working, making the cannon shoot! We're going to code up a little physics, complete with gravity and air resistance, for our cannon.  Before we're done, we'll even build what's called a particle system, use it to simulate explosions, and make our cannon shoot fireworks! Ready to start?",
      lessonSection: "Cannon Go Boom!",
      tutorImage: 5,
    },
    { message: "You're going to write the Bullet object, which moves and draws the cannonball the cannon shoots. I've already done a bunch of stuff to make the Bullet work as soon as you finish it (the code knows whether the mouse is down, the cannon reacts to a mouse down by creating a bullet object, and bullets are told to move and draw themselves in the animation loop). Ready? Find the comments in the Bullet object and write the code it asks you to write.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n// CODE ME: This is the bullet object.  Follow\n// the comments here, write the code it tells\n// you to, and you'll have yourself a working\n// cannon that shoots!\nfunction Bullet(x, y, vx, vy) {\n  // A bullet is created from position (in\n  // the horizontal and vertical directions)\n  // and velocity.  We need to store those.\n  // Create member variables (like this.x)\n  // for x, y, vx, and vy and assign the\n  // parameters to them (so, like this.x\n  // = x).\n  \n  \n  // We need a few more things to define\n  // what it means to be a bullet. There\n  // should be a size and gravity on a\n  // bullet.  Create two more member\n  // variables for these called this.size\n  // and this.gravity and set size to 5\n  // (for all bullets we create) and\n  // gravity to 0.5\n  \n  \n  // Now you will need a move() method\n  // so bullets know how to move themselves.\n  // Move should increase this.x by this.vx\n  // every time it is called, same for this.y\n  // and this.vy.  Finally, move should also\n  // apply gravity, which it can do by\n  // increasing this.vy by this.gravity.\n  // Write the move method and do those three\n  // things below.\n  this.move = function() {\n  };\n  \n  // And finally you will need a draw()\n  // method so bullets know how to draw\n  // themselves.  Let's keep it simple,\n  // draw a box this.size big centered\n  // on this.x and this.y using c.fillRect()\n  // If you have any trouble with that,\n  // don't hesitate to look down at the \n  // draw() for the cannon to see an example\n  // of something similar.\n  this.draw = function() {\n  };\n  \n}\n// STOP: You shouldn't have to change any code\n// below this point. Sure, read the code, \n// understand it, but all the code you need \n// to write to get a working cannon should be\n// written above this point\n\n\n\nfunction Cannon() {\n  // Constants\n  this.size = 30;\n  this.reloadDelay = frameRate;\n  // Position\n  // The cannon fits snugly at the bottom left\n  // corner of the screen\n  this.x = this.size / 2;\n  this.y = h - this.size / 2;\n  // Initial angle, this tracks the mouse soon\n  this.angle = 45;\n  \n  this.draw = function() {\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.save();\n    // Move to the center of the cannon\n    c.translate(x, y);\n    // The cannon sits on a little stand\n    // half of its height and 10% its width\n    c.strokeRect(-s * 0.1 / 2, 0,\n                 s * 0.1, s / 2);\n    // The cannon itself is two rectangles,\n    // next to each other and rotated\n    // through the angle\n    c.rotate(-this.angle * Math.PI / 180);\n    c.fillRect(-s * 0.4, -s * 0.4 / 2,\n               s * 0.4, s * 0.4);\n    c.fillRect(0, -s * 0.1, s * 0.5, s * 0.2);\n    c.restore();\n  };\n  \n  this.move = function() {\n    // Change angle to match mouse location\n    var diffX = mouse.x - this.x;\n    var diffY = mouse.y - this.y;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    var a = -Math.atan2(diffY, diffX);\n    this.angle = a / Math.PI * 180;\n    \n    // If mouse is down and not reloading, fire\n    if (isMouseDown && !this.reload) {\n      // Create a bullet at the end of the\n      // muzzle\n      a = this.angle / 180 * Math.PI;\n      var x = this.x;\n      x += Math.cos(a) * this.size;\n      var y = this.y;\n      y -= Math.sin(a) * this.size;\n\n      // Muzzle velocity varies based on\n      // distance of the mouse from the\n      // cannon\n      var vStr = 0.05 * (dist + 10);\n      \n      // Distribute the muzzle velocity\n      // across velocity in x and y\n      var vx = Math.cos(a) * vStr;\n      var vy = Math.sin(a) * vStr;\n      \n      // Finally, create a new bullet\n      var bullet = new Bullet(x, y, vx, -vy);\n      bullets.push(bullet);\n      \n      // Don't let us shoot again for\n      // a little while\n      this.reload = this.reloadDelay;\n    }\n    if (this.reload) { this.reload--; }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the objects in the world\nvar cannon = new Cannon();\nvar bullets = [];\n\n// Animation loop\nvar cmTID;\nvar timeStep = 50;  // milliseconds\nvar frameRate = 1000 / timeStep;\nfunction updateAll() {\n  // Move everything\n  cannon.move();\n  for (var i = bullets.length - 1; i >= 0; i--) {\n    var b = bullets[i];\n    if (b.y > h) {\n      // The bullet has hit the ground.\n      // Delete it.\n      bullets.splice(i, 1);\n    } else {\n      b.move();\n    }\n  }\n  // Redraw everything\n  c.clearRect(0, 0, w, h);\n  cannon.draw();\n  for (i = 0; i < bullets.length; i++) {\n    bullets[i].draw();\n  }\n  \n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);\n}\nupdateAll();",
      tutorImage: 6,
    },

    { message: "Once you wrote the code, you probably noticed that the bullet shoots faster and further when the mouse is further away? That's kind of neat. Can you see where that is done? It's in the Cannon object in the move() method when the bullet is first created. Take a look at the code, it's kind of cool.",
      tutorImage: 7,
    },
    { message: "Here is the version I did. One thing I added is that the bullets spin slowly, which is kind of a neat effect, most visible when the bullet is at the top of the arc. What do you think of that? Hey, I've got an idea, want to try something funny? Increase the size of the bullets, see what happens!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n\nfunction Bullet(x, y, vx, vy) {\n  // Position\n  this.x = x;\n  this.y = y;\n  // Velocity\n  this.vx = vx;\n  this.vy = vy;\n  // Constants\n  this.size = 5;\n  this.angle = 0;\n  this.va = 10;  // Angular velocity\n  this.gravity = 0.5;\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    // Spin the bullets\n    this.angle += this.va;\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += this.gravity;\n  };\n  \n  this.draw = function() {\n    // Bullets are drawn as a little spinning\n    // box\n    var s = this.size;\n    c.save();\n    c.translate(this.x, this.y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.fillRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n}\n\n\nfunction Cannon() {\n  // Constants\n  this.size = 30;\n  this.reloadDelay = frameRate;\n  // Position\n  // The cannon fits snugly at the bottom left\n  // corner of the screen\n  this.x = this.size / 2;\n  this.y = h - this.size / 2;\n  // Initial angle, this tracks the mouse soon\n  this.angle = 45;\n  \n  this.draw = function() {\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.save();\n    // Move to the center of the cannon\n    c.translate(x, y);\n    // The cannon sits on a little stand\n    // half of its height and 10% its width\n    c.strokeRect(-s * 0.1 / 2, 0,\n                 s * 0.1, s / 2);\n    // The cannon itself is two rectangles,\n    // next to each other and rotated\n    // through the angle\n    c.rotate(-this.angle * Math.PI / 180);\n    c.fillRect(-s * 0.4, -s * 0.4 / 2,\n               s * 0.4, s * 0.4);\n    c.fillRect(0, -s * 0.1, s * 0.5, s * 0.2);\n    c.restore();\n  };\n  \n  this.move = function() {\n    // Change angle to match mouse location\n    var diffX = mouse.x - this.x;\n    var diffY = mouse.y - this.y;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    var a = -Math.atan2(diffY, diffX);\n    this.angle = a / Math.PI * 180;\n    \n    // If mouse is down and not reloading, fire\n    if (isMouseDown && !this.reload) {\n      // Create a bullet at the end of the\n      // muzzle\n      a = this.angle / 180 * Math.PI;\n      var x = this.x;\n      x += Math.cos(a) * this.size;\n      var y = this.y;\n      y -= Math.sin(a) * this.size;\n\n      // Muzzle velocity varies based on\n      // distance of the mouse from the\n      // cannon\n      var vStr = 0.05 * (dist + 10);\n      \n      // Distribute the muzzle velocity\n      // across velocity in x and y\n      var vx = Math.cos(a) * vStr;\n      var vy = Math.sin(a) * vStr;\n      \n      // Finally, create a new bullet\n      var bullet = new Bullet(x, y, vx, -vy);\n      bullets.push(bullet);\n      \n      // Don't let us shoot again for\n      // a little while\n      this.reload = this.reloadDelay;\n    }\n    if (this.reload) { this.reload--; }\n  };\n}\n\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the objects in the world\nvar cannon = new Cannon();\nvar bullets = [];\n\n// Animation loop\nvar cmTID;\nvar timeStep = 50;  // milliseconds\nvar frameRate = 1000 / timeStep;\nfunction updateAll() {\n  // Move everything\n  cannon.move();\n  for (var i = bullets.length - 1; i >= 0; i--) {\n    var b = bullets[i];\n    if (b.y > h) {\n      // The bullet has hit the ground.\n      // Delete it.\n      bullets.splice(i, 1);\n    } else {\n      b.move();\n    }\n  }\n  // Redraw everything\n  c.clearRect(0, 0, w, h);\n  cannon.draw();\n  for (i = 0; i < bullets.length; i++) {\n    bullets[i].draw();\n  }\n  \n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);\n}\nupdateAll();",
      tutorImage: 3,
    },
    { message: "Can you figure out how to make the cannon shoot faster? Make it shoot like a machine gun?",
      tutorImage: 1,
    },
    { message: "Right now, bullets just disappear when they hit the ground.  That's not very satisfying. What'd be much cooler is if the bullets exploded when they hit the ground! We can simulate explosions with something called a <i>particle system</i>, which is just a fancy way of saying a bunch of small things shooting around. That's what we'll do next.",
      lessonSection: "Explosions!",
      tutorImage: 2,
    },
    { message: "The way this will work is that a Bullet object will turn into an Explosion object and an Explosion object contains a bunch of Particle objects, each one of which has physics applied to it, so velocity, gravity, and air resistance.  There will have to be randomness as well so that the particles in the explosion appear to scatter in different directions.",
      tutorImage: 6,
    },
    { message: "You'll need to write the code for the Particle object. You're going to love it when you finish it, it's really cool! I'll take care of the code for you that turns a bullet into an explosion when it hits the ground and that makes particles and explosions eventually disappear, so everything will just work when you finish your code for the Particle object. Look at for the comments in the code below that tell you what to write.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n// START HERE\n// A particle is just a single point.\n// Explosions are made up of a bunch of \n// these particles.\nfunction Particle(x, y, vx, vy) {\n  // A particle is created by giving it\n  // an initial position (x, y) and initial\n  // velocity. Below, write some code to\n  // copy these into method variables\n  // (so, write this.x = x and so on)\n  \n  \n  // Particles need to live for a random\n  // amount of time, 20-60 frames would be\n  // about right (1-3 seconds).  If you\n  // remember, Math.random() generates a\n  // random number between 0 and 1.  Can\n  // you use that to set a method variable\n  // called this.life randomly to a number\n  // between 20 and 60 below?\n  \n  \n  // We're going to simulate air resistance\n  // by dropping the velocity by a bit each\n  // frame.  Set this.airResist to 0.97 below.\n  \n  \n  // Now write a move() method for a particle\n  // so particles know how to move themselves.\n  // This is going to be a bit of code, so\n  // read the walkthough below carefully.\n  // Inside that move method, increase\n  // the position by the velocity in that\n  // direction (so, this.x += this.vx and same\n  // for y and vy).\n  // Now you need to check if the particle\n  // has hit the ground (which it has if\n  // this.y > h).  If it has, then make\n  // sure vy is pointing out of the ground\n  // (which you can do by setting it to\n  // this.vy = -Math.abs(this.vy)\n  // because Math.abs() forces this.vy\n  // to be positive and then the negative\n  // sign makes it negative).  Finally,\n  // multiply both this.vx and this.vy\n  // by world.bounce, which will slow them\n  // and simulate a partially elastic collision\n  // with the ground.\n  // When you're done with that check if\n  // the particle has hit the ground, then\n  // you can apply gravity by increasing this.vy\n  // by world.gravity.\n  // Then you should simulate air resistance\n  // by multiplying this.vx by this.airResist\n  // and the same for vy.\n  // Finally, reduce this.life by 1 (when\n  // it hits 0, we'll remove the particle).\n  // Okay, do all that below!\n  this.move = function() {\n    // OMG, I'm missing code!  Write me!\n    \n    \n    \n  };\n  \n  // Whew, after all that, how about something\n  // simple?  Write the draw() method below\n  // so particles know how to draw themselves.\n  // Since particles are just a point, you\n  // can draw them using c.fillRect()\n  // with a width and height of 1.\n  this.draw = function() {\n    // Where's my code?  Write me!    \n    \n  };\n  \n  // Finally, particles need to know when they\n  // should die.  I'll write that one for\n  // you, it just needs to check if the particle\n  // is out of life.\n  this.shouldDie = function() {\n    return this.life <= 0;\n  };\n}\n// STOP HERE.  All the code you need to change\n// should be in the Particle object.  Definitely\n// read the code below here, but you shouldn't\n// have to change anything below this point to\n// get the explosions working.  Can you get it\n// to work?\n\n\n\n// A bullet (and anything the bullet hits) turns\n// into an explosion, which is a shower of\n// particles\nfunction Explosion(source) {\n  this.particles = [];\n  \n  this.init = function(s) {\n    var num = s.size * 2;\n    for (var i = 0; i < num; i++) {\n      // Start the explosion in the same \n      // spot as the source, and with random\n      // velocities influenced by, but\n      // not dominated by, the source\n      var vx = 2 * s.vx * (Math.random() - 0.2);\n      vx += 3 * (Math.random() - 0.5);\n      var vy = 2 * s.vy * (Math.random() - 0.2);\n      vy += 3 * (Math.random() - 0.5);\n      var p = new Particle(s.x, s.y, vx, vy);\n      this.particles.push(p);\n    }\n  };\n  this.init(source);\n  \n  this.move = function() {\n    var ps = this.particles;\n    // Delete particles that should die\n    for (var i = ps.length - 1; i >= 0; i--) {\n      var p = ps[i];\n      if (p.shouldDie()) {\n        ps.splice(i, 1);\n      }\n    }\n    // Move all remaining particles\n    for (i = 0; i < ps.length; i++) {\n      ps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    var ps = this.particles;\n    // Draw all particles\n    for (var i = 0; i < ps.length; i++) {\n      ps[i].draw();\n    }\n  };\n  \n  this.shouldDie = function() {\n    return this.particles.length <= 0;\n  };\n}\n\n// The cannon fits snugly at the bottom left\n// corner of the screen and shoots bullets.\nfunction Cannon() {\n  // Constants\n  this.size = 30;\n  // Position\n  this.x = this.size / 2;\n  this.y = h - this.size / 2;\n  // Initial angle, this tracks the mouse soon\n  this.angle = 45;\n  // How many frames we have to wait to shoot\n  // again, the first number is time in seconds,\n  // so, if it is 0.5, that means a half a \n  // second delay\n  this.reloadDelay = 0.7 * world.frames;\n  \n  this.draw = function() {\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.save();\n    // Move to the center of the cannon\n    c.translate(x, y);\n    // The cannon sits on a little stand\n    // half of its height and 10% its width\n    c.strokeRect(-s * 0.1 / 2, 0,\n                 s * 0.1, s / 2);\n    // The cannon itself is two rectangles,\n    // next to each other and rotated\n    // through the angle\n    c.rotate(-this.angle * Math.PI / 180);\n    c.fillRect(-s * 0.4, -s * 0.4 / 2,\n               s * 0.4, s * 0.4);\n    c.fillRect(0, -s * 0.1, s * 0.5, s * 0.2);\n    c.restore();\n  };\n  \n  this.move = function() {\n    // Change angle to match mouse location\n    var diffX = mouse.x - this.x;\n    var diffY = mouse.y - this.y;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    var a = -Math.atan2(diffY, diffX);\n    this.angle = a / Math.PI * 180;\n    \n    // If mouse is down and not reloading, fire\n    if (isMouseDown && !this.reload) {\n      // Create a bullet at the end of the\n      // muzzle\n      a = this.angle / 180 * Math.PI;\n      var x = this.x;\n      x += Math.cos(a) * this.size;\n      var y = this.y;\n      y -= Math.sin(a) * this.size;\n\n      // Muzzle velocity varies based on\n      // distance of the mouse from the\n      // cannon\n      var vStr = 0.05 * (dist + 10);\n      \n      // Distribute the muzzle velocity\n      // across velocity in x and y\n      var vx = Math.cos(a) * vStr;\n      var vy = Math.sin(a) * vStr;\n      \n      // Finally, create a new bullet\n      var bullet = new Bullet(x, y, vx, -vy);\n      world.bullets.push(bullet);\n      \n      // Don't let us shoot again for\n      // a little while\n      this.reload = this.reloadDelay;\n    }\n    if (this.reload) { this.reload--; }\n  };\n}\n\n// The cannon shoots bullets\nfunction Bullet(x, y, vx, vy) {\n  // Position\n  this.x = x;\n  this.y = y;\n  // Velocity\n  this.vx = vx;\n  this.vy = vy;\n  // Constants\n  this.size = 5;\n  this.angle = 0;\n  this.va = 10;  // Angular velocity\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    // Spin the bullets\n    this.angle += this.va;\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += world.gravity;\n  };\n  \n  this.draw = function() {\n    // Bullets are drawn as a little spinning\n    // box\n    var s = this.size;\n    c.save();\n    c.translate(this.x, this.y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.fillRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n  \n  this.shouldDie = function() {\n    return this.y > h;\n  };\n}\n\n// The world holds all the state of the game and\n// manages moving and updating everything\nfunction World() {\n  // Constants\n  this.timeStep = 50;  // In milliseconds\n  this.frames = 1000 / this.timeStep;\n  // Elasticity of collisions with the ground.\n  // Setting to 1.0 is fully elastic, 0.0 is\n  // no bounce at all (landing with a thud).\n  this.bounce = 0.8;\n  // Gravity is an acceleration, so it changes\n  // velocity every frame.\n  this.gravity = 0.5;\n  \n  this.init = function() {\n    // World state\n    this.cannon = new Cannon();\n    this.bullets = [];\n    this.explosions = [];\n  };\n\n  this.update = function() {\n    this.move();\n    this.draw();\n  };\n\n  this.move = function() {\n    // Move everything\n    this.cannon.move();\n    var l = this.bullets.length;\n    for (var i = l - 1; i >= 0; i--) {\n      var b = this.bullets[i];\n      if (b.shouldDie()) {\n        // The bullet has hit the ground or\n        // exploded or otherwise needs to die.\n        // Add an explosion\n        var e = new Explosion(b);\n        this.explosions.push(e);\n        // Delete the bullet\n        this.bullets.splice(i, 1);\n      } else {\n        b.move();\n      }\n    }\n    l = this.explosions.length;\n    for (i = l - 1; i >= 0; i--) {\n      var ex = this.explosions[i];\n      if (ex.shouldDie()) {\n        this.explosions.splice(i, 1);\n      } else {\n        ex.move();\n      }\n    }\n  };\n\n  this.draw = function() {\n    // Redraw everything\n    c.clearRect(0, 0, w, h);\n    this.cannon.draw();\n    var l = this.bullets.length;\n    for (var i = 0; i < l; i++) {\n      this.bullets[i].draw();\n    }\n    l = this.explosions.length;\n    for (i = 0; i < l; i++) {\n      this.explosions[i].draw();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the world\nvar world = new World();\nworld.init();\n\n// Animation loop\nvar cmTID;\nfunction updateAll() {\n  world.update();\n\n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll,\n                     world.timeStep);\n}\nupdateAll();",
      tutorImage: 1,
    },
    { message: "That's pretty tough to get all of that right. If you got, I'm impressed! If not, take a look at this code. Here's a slightly more elaborate version that does just a bit more that what you were working on. Try shooting around a bit. Like the effect? Take a look at the code in the Particle object to see how it works.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n\n// A particle is just a single point.\nfunction Particle(x, y, vx, vy) {\n  this.x = x;\n  this.y = y;\n  this.vx = vx;\n  this.vy = vy;\n  // The life of a particle in number of frames.\n  // Particles live for a random time (eg. \n  // from 1-3 seconds)\n  this.life = 1 * world.frames;\n  this.life *= Math.random() * 2 + 1;\n  // Air resistance here is specific to particles\n  // since they are light.\n  this.airResist = 0.97;\n  \n  this.move = function() {\n    this.x += this.vx;\n    this.y += this.vy;\n    if (this.y > h) {\n      // We hit the ground, bounce off\n      // First, compute how far we have left\n      // to move\n      var remain = (this.y - h) / this.vy;\n      // Move to the ground\n      this.y = h;\n      // Reverse the vertical velocity,\n      // simulating a partially elastic collision\n      this.vy = -Math.abs(this.vy) *\n        world.bounce;\n      // Reduce the horizontal velocity too\n      this.vx *= world.bounce;\n      // Move off the ground\n      this.y += this.vy * remain;\n    }\n    // Use gravity if we want this to look\n    // like pieces\n    this.vy += world.gravity;\n    // Use airResist if we want this to look\n    // like drifting sparks\n    this.vx *= this.airResist;\n    this.vy *= this.airResist;\n    this.life -= 1;\n  };\n  \n  this.draw = function() {\n    c.fillRect(this.x, this.y, 1, 1);\n  };\n  \n  this.shouldDie = function() {\n    return this.life <= 0;\n  };\n}\n\n// A bullet (and anything the bullet hits) turns\n// into an explosion, which is a shower of\n// particles\nfunction Explosion(source) {\n  this.particles = [];\n  \n  this.init = function(s) {\n    var num = s.size * 2;\n    for (var i = 0; i < num; i++) {\n      // Start the explosion in the same \n      // spot as the source, and with random\n      // velocities influenced by, but\n      // not dominated by, the source\n      var vx = 2 * s.vx * (Math.random() - 0.2);\n      vx += 3 * (Math.random() - 0.5);\n      var vy = 2 * s.vy * (Math.random() - 0.2);\n      vy += 3 * (Math.random() - 0.5);\n      var p = new Particle(s.x, s.y, vx, vy);\n      this.particles.push(p);\n    }\n  };\n  this.init(source);\n  \n  this.move = function() {\n    var ps = this.particles;\n    // Delete particles that should die\n    for (var i = ps.length - 1; i >= 0; i--) {\n      var p = ps[i];\n      if (p.shouldDie()) {\n        ps.splice(i, 1);\n      }\n    }\n    // Move all remaining particles\n    for (i = 0; i < ps.length; i++) {\n      ps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    var ps = this.particles;\n    // Draw all particles\n    for (var i = 0; i < ps.length; i++) {\n      ps[i].draw();\n    }\n  };\n  \n  this.shouldDie = function() {\n    return this.particles.length <= 0;\n  };\n}\n\n// The cannon fits snugly at the bottom left\n// corner of the screen and shoots bullets.\nfunction Cannon() {\n  // Constants\n  this.size = 30;\n  // Position\n  this.x = this.size / 2;\n  this.y = h - this.size / 2;\n  // Initial angle, this tracks the mouse soon\n  this.angle = 45;\n  // How many frames we have to wait to shoot\n  // again, the first number is time in seconds,\n  // so, if it is 0.5, that means a half a \n  // second delay\n  this.reloadDelay = 0.7 * world.frames;\n  \n  this.draw = function() {\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.save();\n    // Move to the center of the cannon\n    c.translate(x, y);\n    // The cannon sits on a little stand\n    // half of its height and 10% its width\n    c.strokeRect(-s * 0.1 / 2, 0,\n                 s * 0.1, s / 2);\n    // The cannon itself is two rectangles,\n    // next to each other and rotated\n    // through the angle\n    c.rotate(-this.angle * Math.PI / 180);\n    c.fillRect(-s * 0.4, -s * 0.4 / 2,\n               s * 0.4, s * 0.4);\n    c.fillRect(0, -s * 0.1, s * 0.5, s * 0.2);\n    c.restore();\n  };\n  \n  this.move = function() {\n    // Change angle to match mouse location\n    var diffX = mouse.x - this.x;\n    var diffY = mouse.y - this.y;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    var a = -Math.atan2(diffY, diffX);\n    this.angle = a / Math.PI * 180;\n    \n    // If mouse is down and not reloading, fire\n    if (isMouseDown && !this.reload) {\n      // Create a bullet at the end of the\n      // muzzle\n      a = this.angle / 180 * Math.PI;\n      var x = this.x;\n      x += Math.cos(a) * this.size;\n      var y = this.y;\n      y -= Math.sin(a) * this.size;\n\n      // Muzzle velocity varies based on\n      // distance of the mouse from the\n      // cannon\n      var vStr = 0.05 * (dist + 10);\n      \n      // Distribute the muzzle velocity\n      // across velocity in x and y\n      var vx = Math.cos(a) * vStr;\n      var vy = Math.sin(a) * vStr;\n      \n      // Finally, create a new bullet\n      var bullet = new Bullet(x, y, vx, -vy);\n      world.bullets.push(bullet);\n      \n      // Don't let us shoot again for\n      // a little while\n      this.reload = this.reloadDelay;\n    }\n    if (this.reload) { this.reload--; }\n  };\n}\n\n// The cannon shoots bullets\nfunction Bullet(x, y, vx, vy) {\n  // Position\n  this.x = x;\n  this.y = y;\n  // Velocity\n  this.vx = vx;\n  this.vy = vy;\n  // Constants\n  this.size = 5;\n  this.angle = 0;\n  this.va = 10;  // Angular velocity\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    // Spin the bullets\n    this.angle += this.va;\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += world.gravity;\n  };\n  \n  this.draw = function() {\n    // Bullets are drawn as a little spinning\n    // box\n    var s = this.size;\n    c.save();\n    c.translate(this.x, this.y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.fillRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n  \n  this.shouldDie = function() {\n    return this.y > h;\n  };\n}\n\n// The world holds all the state of the game and\n// manages moving and updating everything\nfunction World() {\n  // Constants\n  this.timeStep = 50;  // In milliseconds\n  this.frames = 1000 / this.timeStep;\n  // Elasticity of collisions with the ground.\n  // Setting to 1.0 is fully elastic, 0.0 is\n  // no bounce at all (landing with a thud).\n  this.bounce = 0.8;\n  // Gravity is an acceleration, so it changes\n  // velocity every frame.\n  this.gravity = 0.5;\n  \n  this.init = function() {\n    // World state\n    this.cannon = new Cannon();\n    this.bullets = [];\n    this.explosions = [];\n  };\n\n  this.update = function() {\n    this.move();\n    this.draw();\n  };\n\n  this.move = function() {\n    // Move everything\n    this.cannon.move();\n    var l = this.bullets.length;\n    for (var i = l - 1; i >= 0; i--) {\n      var b = this.bullets[i];\n      if (b.shouldDie()) {\n        // The bullet has hit the ground or\n        // exploded or otherwise needs to die.\n        // Add an explosion\n        var e = new Explosion(b);\n        this.explosions.push(e);\n        // Delete the bullet\n        this.bullets.splice(i, 1);\n      } else {\n        b.move();\n      }\n    }\n    l = this.explosions.length;\n    for (i = l - 1; i >= 0; i--) {\n      var ex = this.explosions[i];\n      if (ex.shouldDie()) {\n        this.explosions.splice(i, 1);\n      } else {\n        ex.move();\n      }\n    }\n  };\n\n  this.draw = function() {\n    // Redraw everything\n    c.clearRect(0, 0, w, h);\n    this.cannon.draw();\n    var l = this.bullets.length;\n    for (var i = 0; i < l; i++) {\n      this.bullets[i].draw();\n    }\n    l = this.explosions.length;\n    for (i = 0; i < l; i++) {\n      this.explosions[i].draw();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the world\nvar world = new World();\nworld.init();\n\n// Animation loop\nvar cmTID;\nfunction updateAll() {\n  world.update();\n\n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll,\n                     world.timeStep);\n}\nupdateAll();",
      tutorImage: 2,
    },
    { message: "It's really fun to try different explosion effects using this code. Experiment with it! Can you make the explosions last longer?  What happens if you eliminate air resistance (or if you increase it)?  What happens if the particles don't have gravity (comment out the line)?  Can you make the explosions bigger (more particles)?  Can you make the explosions more or less random (try fiddling with the starting velocities)?",
      tutorImage: 3,
    },
    { message: "Let's try to make fireworks!  I made a small change in the code to make the bullets explode in mid-air.  Try it!  But it doesn't really look like fireworks yet, does it? Can you mess with the air resistance, try turning off or lowering gravity, and maybe increase the number of particles in the explosions? See if you can make it look much more like fireworks!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n\n// A particle is just a single point.\nfunction Particle(x, y, vx, vy) {\n  this.x = x;\n  this.y = y;\n  this.vx = vx;\n  this.vy = vy;\n  // The life of a particle in number of frames.\n  // Particles live for a random time (eg. \n  // from 1-3 seconds)\n  this.life = 1 * world.frames;\n  this.life *= Math.random() * 2 + 1;\n  // Air resistance here is specific to particles\n  // since they are light.\n  this.airResist = 0.97;\n  \n  this.move = function() {\n    this.x += this.vx;\n    this.y += this.vy;\n    if (this.y > h) {\n      // We hit the ground, bounce off\n      // First, compute how far we have left\n      // to move\n      var remain = (this.y - h) / this.vy;\n      // Move to the ground\n      this.y = h;\n      // Reverse the vertical velocity,\n      // simulating a partially elastic collision\n      this.vy = -Math.abs(this.vy) *\n        world.bounce;\n      // Reduce the horizontal velocity too\n      this.vx *= world.bounce;\n      // Move off the ground\n      this.y += this.vy * remain;\n    }\n    // Use gravity if we want this to look\n    // like pieces\n    this.vy += world.gravity;\n    // Use airResist if we want this to look\n    // like drifting sparks\n    this.vx *= this.airResist;\n    this.vy *= this.airResist;\n    this.life -= 1;\n  };\n  \n  this.draw = function() {\n    c.fillRect(this.x, this.y, 1, 1);\n  };\n  \n  this.shouldDie = function() {\n    return this.life <= 0;\n  };\n}\n\n// A bullet (and anything the bullet hits) turns\n// into an explosion, which is a shower of\n// particles\nfunction Explosion(source) {\n  this.particles = [];\n  \n  this.init = function(s) {\n    var num = s.size * 2;\n    for (var i = 0; i < num; i++) {\n      // Start the explosion in the same \n      // spot as the source, and with random\n      // velocities influenced by, but\n      // not dominated by, the source\n      var vx = 2 * s.vx * (Math.random() - 0.2);\n      vx += 3 * (Math.random() - 0.5);\n      var vy = 2 * s.vy * (Math.random() - 0.2);\n      vy += 3 * (Math.random() - 0.5);\n      var p = new Particle(s.x, s.y, vx, vy);\n      this.particles.push(p);\n    }\n  };\n  this.init(source);\n  \n  this.move = function() {\n    var ps = this.particles;\n    // Delete particles that should die\n    for (var i = ps.length - 1; i >= 0; i--) {\n      var p = ps[i];\n      if (p.shouldDie()) {\n        ps.splice(i, 1);\n      }\n    }\n    // Move all remaining particles\n    for (i = 0; i < ps.length; i++) {\n      ps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    var ps = this.particles;\n    // Draw all particles\n    for (var i = 0; i < ps.length; i++) {\n      ps[i].draw();\n    }\n  };\n  \n  this.shouldDie = function() {\n    return this.particles.length <= 0;\n  };\n}\n\n// The cannon fits snugly at the bottom left\n// corner of the screen and shoots bullets.\nfunction Cannon() {\n  // Constants\n  this.size = 30;\n  // Position\n  this.x = this.size / 2;\n  this.y = h - this.size / 2;\n  // Initial angle, this tracks the mouse soon\n  this.angle = 45;\n  // How many frames we have to wait to shoot\n  // again, the first number is time in seconds,\n  // so, if it is 0.5, that means a half a \n  // second delay\n  this.reloadDelay = 0.7 * world.frames;\n  \n  this.draw = function() {\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.save();\n    // Move to the center of the cannon\n    c.translate(x, y);\n    // The cannon sits on a little stand\n    // half of its height and 10% its width\n    c.strokeRect(-s * 0.1 / 2, 0,\n                 s * 0.1, s / 2);\n    // The cannon itself is two rectangles,\n    // next to each other and rotated\n    // through the angle\n    c.rotate(-this.angle * Math.PI / 180);\n    c.fillRect(-s * 0.4, -s * 0.4 / 2,\n               s * 0.4, s * 0.4);\n    c.fillRect(0, -s * 0.1, s * 0.5, s * 0.2);\n    c.restore();\n  };\n  \n  this.move = function() {\n    // Change angle to match mouse location\n    var diffX = mouse.x - this.x;\n    var diffY = mouse.y - this.y;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    var a = -Math.atan2(diffY, diffX);\n    this.angle = a / Math.PI * 180;\n    \n    // If mouse is down and not reloading, fire\n    if (isMouseDown && !this.reload) {\n      // Create a bullet at the end of the\n      // muzzle\n      a = this.angle / 180 * Math.PI;\n      var x = this.x;\n      x += Math.cos(a) * this.size;\n      var y = this.y;\n      y -= Math.sin(a) * this.size;\n\n      // Muzzle velocity varies based on\n      // distance of the mouse from the\n      // cannon\n      var vStr = 0.05 * (dist + 10);\n      \n      // Distribute the muzzle velocity\n      // across velocity in x and y\n      var vx = Math.cos(a) * vStr;\n      var vy = Math.sin(a) * vStr;\n      \n      // Finally, create a new bullet\n      var bullet = new Bullet(x, y, vx, -vy);\n      world.bullets.push(bullet);\n      \n      // Don't let us shoot again for\n      // a little while\n      this.reload = this.reloadDelay;\n    }\n    if (this.reload) { this.reload--; }\n  };\n}\n\n// The cannon shoots bullets\nfunction Bullet(x, y, vx, vy) {\n  // Position\n  this.x = x;\n  this.y = y;\n  // Velocity\n  this.vx = vx;\n  this.vy = vy;\n  // Constants\n  this.size = 5;\n  this.angle = 0;\n  this.va = 10;  // Angular velocity\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    // Spin the bullets\n    this.angle += this.va;\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += world.gravity;\n  };\n  \n  this.draw = function() {\n    // Bullets are drawn as a little spinning\n    // box\n    var s = this.size;\n    c.save();\n    c.translate(this.x, this.y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.fillRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n  \n  this.shouldDie = function() {\n    // Make bullets explode in mid-air\n    return this.vy > 0 && Math.random() < 0.2;\n    // return this.y > h;\n  };\n}\n\n// The world holds all the state of the game and\n// manages moving and updating everything\nfunction World() {\n  // Constants\n  this.timeStep = 50;  // In milliseconds\n  this.frames = 1000 / this.timeStep;\n  // Elasticity of collisions with the ground.\n  // Setting to 1.0 is fully elastic, 0.0 is\n  // no bounce at all (landing with a thud).\n  this.bounce = 0.8;\n  // Gravity is an acceleration, so it changes\n  // velocity every frame.\n  this.gravity = 0.5;\n  \n  this.init = function() {\n    // World state\n    this.cannon = new Cannon();\n    this.bullets = [];\n    this.explosions = [];\n  };\n\n  this.update = function() {\n    this.move();\n    this.draw();\n  };\n\n  this.move = function() {\n    // Move everything\n    this.cannon.move();\n    var l = this.bullets.length;\n    for (var i = l - 1; i >= 0; i--) {\n      var b = this.bullets[i];\n      if (b.shouldDie()) {\n        // The bullet has hit the ground or\n        // exploded or otherwise needs to die.\n        // Add an explosion\n        var e = new Explosion(b);\n        this.explosions.push(e);\n        // Delete the bullet\n        this.bullets.splice(i, 1);\n      } else {\n        b.move();\n      }\n    }\n    l = this.explosions.length;\n    for (i = l - 1; i >= 0; i--) {\n      var ex = this.explosions[i];\n      if (ex.shouldDie()) {\n        this.explosions.splice(i, 1);\n      } else {\n        ex.move();\n      }\n    }\n  };\n\n  this.draw = function() {\n    // Redraw everything\n    c.clearRect(0, 0, w, h);\n    this.cannon.draw();\n    var l = this.bullets.length;\n    for (var i = 0; i < l; i++) {\n      this.bullets[i].draw();\n    }\n    l = this.explosions.length;\n    for (i = 0; i < l; i++) {\n      this.explosions[i].draw();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the world\nvar world = new World();\nworld.init();\n\n// Animation loop\nvar cmTID;\nfunction updateAll() {\n  world.update();\n\n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll,\n                     world.timeStep);\n}\nupdateAll();",
      lessonSection: "Fireworks",
      tutorImage: 7,
    },
    { message: "Here's some fireworks with a little color added. Ka-boom! Pretty!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n\n// A particle is just a single point.\nfunction Particle(x, y, vx, vy) {\n  this.x = x;\n  this.y = y;\n  this.vx = vx;\n  this.vy = vy;\n  // The life of a particle in number of frames.\n  // Particles live for a random time (eg. \n  // from 1-4 seconds)\n  this.life = 1 * world.frames;\n  this.life *= Math.random() * 3 + 1;\n  // Air resistance here is specific to particles\n  // since they are light.\n  this.airResist = 0.95;\n  // Assign a random color to this particle\n  this.rgb = 'rgb(' + \n      Math.ceil(Math.random() * 255) +\n      ',' + \n      Math.ceil(Math.random() * 255) +\n      ',' + \n      Math.ceil(Math.random() * 255) +\n      ')';\n\n  \n  this.move = function() {\n    this.x += this.vx;\n    this.y += this.vy;\n    if (this.y > h) {\n      // We hit the ground, bounce off\n      // First, compute how far we have left\n      // to move\n      var remain = (this.y - h) / this.vy;\n      // Move to the ground\n      this.y = h;\n      // Reverse the vertical velocity,\n      // simulating a partially elastic collision\n      this.vy = -Math.abs(this.vy) *\n        world.bounce;\n      // Reduce the horizontal velocity too\n      this.vx *= world.bounce;\n      // Move off the ground\n      this.y += this.vy * remain;\n    }\n    // Use gravity if we want this to look\n    // like pieces\n    this.vy += world.gravity * 0.1;\n    // Use airResist if we want this to look\n    // like drifting sparks\n    this.vx *= this.airResist;\n    this.vy *= this.airResist;\n    this.life -= 1;\n  };\n  \n  this.draw = function() {\n    c.save();\n    c.fillStyle = this.rgb;\n    c.fillRect(this.x, this.y, 1, 1);\n    c.restore();\n  };\n  \n  this.shouldDie = function() {\n    return this.life <= 0;\n  };\n}\n\n// A bullet (and anything the bullet hits) turns\n// into an explosion, which is a shower of\n// particles\nfunction Explosion(source) {\n  this.particles = [];\n  \n  this.init = function(s) {\n    var num = s.size * 20;\n    for (var i = 0; i < num; i++) {\n      // Start the explosion in the same \n      // spot as the source, and with random\n      // velocities influenced by, but\n      // not dominated by, the source\n      var vx = 2 * s.vx * (Math.random() - 0.2);\n      vx += 3 * (Math.random() - 0.5);\n      var vy = 2 * s.vy * (Math.random() - 0.2);\n      vy += 3 * (Math.random() - 0.5);\n      var p = new Particle(s.x, s.y, vx, vy);\n      this.particles.push(p);\n    }\n  };\n  this.init(source);\n  \n  this.move = function() {\n    var ps = this.particles;\n    // Delete particles that should die\n    for (var i = ps.length - 1; i >= 0; i--) {\n      var p = ps[i];\n      if (p.shouldDie()) {\n        ps.splice(i, 1);\n      }\n    }\n    // Move all remaining particles\n    for (i = 0; i < ps.length; i++) {\n      ps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    var ps = this.particles;\n    // Draw all particles\n    for (var i = 0; i < ps.length; i++) {\n      ps[i].draw();\n    }\n  };\n  \n  this.shouldDie = function() {\n    return this.particles.length <= 0;\n  };\n}\n\n// The cannon fits snugly at the bottom left\n// corner of the screen and shoots bullets.\nfunction Cannon() {\n  // Constants\n  this.size = 30;\n  // Position\n  this.x = this.size / 2;\n  this.y = h - this.size / 2;\n  // Initial angle, this tracks the mouse soon\n  this.angle = 45;\n  // How many frames we have to wait to shoot\n  // again, the first number is time in seconds,\n  // so, if it is 0.5, that means a half a \n  // second delay\n  this.reloadDelay = 0.7 * world.frames;\n  \n  this.draw = function() {\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.save();\n    // Move to the center of the cannon\n    c.translate(x, y);\n    // The cannon sits on a little stand\n    // half of its height and 10% its width\n    c.strokeRect(-s * 0.1 / 2, 0,\n                 s * 0.1, s / 2);\n    // The cannon itself is two rectangles,\n    // next to each other and rotated\n    // through the angle\n    c.rotate(-this.angle * Math.PI / 180);\n    c.fillRect(-s * 0.4, -s * 0.4 / 2,\n               s * 0.4, s * 0.4);\n    c.fillRect(0, -s * 0.1, s * 0.5, s * 0.2);\n    c.restore();\n  };\n  \n  this.move = function() {\n    // Change angle to match mouse location\n    var diffX = mouse.x - this.x;\n    var diffY = mouse.y - this.y;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    var a = -Math.atan2(diffY, diffX);\n    this.angle = a / Math.PI * 180;\n    \n    // If mouse is down and not reloading, fire\n    if (isMouseDown && !this.reload) {\n      // Create a bullet at the end of the\n      // muzzle\n      a = this.angle / 180 * Math.PI;\n      var x = this.x;\n      x += Math.cos(a) * this.size;\n      var y = this.y;\n      y -= Math.sin(a) * this.size;\n\n      // Muzzle velocity varies based on\n      // distance of the mouse from the\n      // cannon\n      var vStr = 0.05 * (dist + 10);\n      \n      // Distribute the muzzle velocity\n      // across velocity in x and y\n      var vx = Math.cos(a) * vStr;\n      var vy = Math.sin(a) * vStr;\n      \n      // Finally, create a new bullet\n      var bullet = new Bullet(x, y, vx, -vy);\n      world.bullets.push(bullet);\n      \n      // Don't let us shoot again for\n      // a little while\n      this.reload = this.reloadDelay;\n    }\n    if (this.reload) { this.reload--; }\n  };\n}\n\n// The cannon shoots bullets\nfunction Bullet(x, y, vx, vy) {\n  // Position\n  this.x = x;\n  this.y = y;\n  // Velocity\n  this.vx = vx;\n  this.vy = vy;\n  // Constants\n  this.size = 5;\n  this.angle = 0;\n  this.va = 10;  // Angular velocity\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    // Spin the bullets\n    this.angle += this.va;\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += world.gravity;\n  };\n  \n  this.draw = function() {\n    // Bullets are drawn as a little spinning\n    // box\n    var s = this.size;\n    c.save();\n    c.translate(this.x, this.y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.fillRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n  \n  this.shouldDie = function() {\n    // Make bullets explode in mid-air\n    return this.vy > 0 && Math.random() < 0.2;\n    // return this.y > h;\n  };\n}\n\n// The world holds all the state of the game and\n// manages moving and updating everything\nfunction World() {\n  // Constants\n  this.timeStep = 50;  // In milliseconds\n  this.frames = 1000 / this.timeStep;\n  // Elasticity of collisions with the ground.\n  // Setting to 1.0 is fully elastic, 0.0 is\n  // no bounce at all (landing with a thud).\n  this.bounce = 0.8;\n  // Gravity is an acceleration, so it changes\n  // velocity every frame.\n  this.gravity = 0.5;\n  \n  this.init = function() {\n    // World state\n    this.cannon = new Cannon();\n    this.bullets = [];\n    this.explosions = [];\n  };\n\n  this.update = function() {\n    this.move();\n    this.draw();\n  };\n\n  this.move = function() {\n    // Move everything\n    this.cannon.move();\n    var l = this.bullets.length;\n    for (var i = l - 1; i >= 0; i--) {\n      var b = this.bullets[i];\n      if (b.shouldDie()) {\n        // The bullet has hit the ground or\n        // exploded or otherwise needs to die.\n        // Add an explosion\n        var e = new Explosion(b);\n        this.explosions.push(e);\n        // Delete the bullet\n        this.bullets.splice(i, 1);\n      } else {\n        b.move();\n      }\n    }\n    l = this.explosions.length;\n    for (i = l - 1; i >= 0; i--) {\n      var ex = this.explosions[i];\n      if (ex.shouldDie()) {\n        this.explosions.splice(i, 1);\n      } else {\n        ex.move();\n      }\n    }\n  };\n\n  this.draw = function() {\n    // Redraw everything\n    c.clearRect(0, 0, w, h);\n    this.cannon.draw();\n    var l = this.bullets.length;\n    for (var i = 0; i < l; i++) {\n      this.bullets[i].draw();\n    }\n    l = this.explosions.length;\n    for (i = 0; i < l; i++) {\n      this.explosions[i].draw();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the world\nvar world = new World();\nworld.init();\n\n// Animation loop\nvar cmTID;\nfunction updateAll() {\n  world.update();\n\n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll,\n                     world.timeStep);\n}\nupdateAll();",
      tutorImage: 5,
    },
    { message: "That was seriously fun, but we've got a game to write! Let's get back to it!",
      code: "",
      tutorImage: 1,
    },
    { message: "The next step is to add enemies! You wrote an Enemy object at the start of coding this game. I'll put back in a modified version of that now. Our enemies are going to be little circles and bounce they way toward attacking the cannon. Like this! Play with it and take a look at the code, especially the code for the Enemy object and the spawn() method of the World object.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n\n// Enemies start at a random spot on the \n// right side and move left, either hitting \n// the cannon, going off the left side of the\n// screen, or getting hit by a bullet\nfunction Enemy() {\n  // Size\n  this.r = 10 + 15 * Math.random();\n  this.size = this.r * 2;\n  // Position\n  this.x = w;\n  this.y = h / 2;\n  this.y += (h - this.r) / 2 * Math.random();\n  // Velocity\n  this.vx = -Math.random() * 3 - 1;\n  this.vy = (Math.random() - 0.5) * 20;\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    var bottom = h - this.r;\n    if (this.y > bottom) {\n      // We hit the ground, bounce off\n      // First, compute how far we have left\n      // to move\n      var remain = (this.y - bottom) / this.vy;\n      // Move to the ground\n      this.y = bottom;\n      // Reverse the vertical velocity,\n      // simulating a partially elastic collision\n      this.vy = -Math.abs(this.vy) *\n        world.bounce;\n      // Move off the ground\n      this.y += this.vy * remain;\n    }\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += world.gravity;\n  };\n  \n  this.draw = function() {\n    // Enemies are drawn as a little circle\n    c.beginPath();\n    c.arc(this.x, this.y, this.r,\n          0, Math.PI * 2);\n    c.stroke();\n  };\n  \n  this.isOverlap = function(o2) {\n    // This is not done yet, just say no overlap\n    // for now\n    return false;\n  };\n  \n  this.shouldDie = function() {\n    return this.x + this.r < 0;\n  };\n}\n\n// The cannon fits snugly at the bottom left\n// corner of the screen and shoots bullets.\n// The game is over when the cannon is hit\n// by an enemy.\nfunction Cannon() {\n  // Constants\n  this.size = 30;\n  // Position\n  this.x = this.size / 2;\n  this.y = h - this.size / 2;\n  // Initial angle, this tracks the mouse soon\n  this.angle = 45;\n  // How many frames we have to wait to shoot\n  // again, the first number is time in seconds,\n  // so, if it is 0.5, that means a half a \n  // second delay\n  this.reloadDelay = 0.7 * world.frames;\n  \n  this.draw = function() {\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.save();\n    // Move to the center of the cannon\n    c.translate(x, y);\n    // The cannon sits on a little stand\n    // half of its height and 10% its width\n    c.strokeRect(-s * 0.1 / 2, 0,\n                 s * 0.1, s / 2);\n    // The cannon itself is two rectangles,\n    // next to each other and rotated\n    // through the angle\n    c.rotate(-this.angle * Math.PI / 180);\n    c.fillRect(-s * 0.4, -s * 0.4 / 2,\n               s * 0.4, s * 0.4);\n    c.fillRect(0, -s * 0.1, s * 0.5, s * 0.2);\n    c.restore();\n  };\n  \n  this.move = function() {\n    // Change angle to match mouse location\n    var diffX = mouse.x - this.x;\n    var diffY = mouse.y - this.y;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    var a = -Math.atan2(diffY, diffX);\n    this.angle = a / Math.PI * 180;\n    \n    // If mouse is down and not reloading, fire\n    if (isMouseDown && !this.reload) {\n      // Create a bullet at the end of the\n      // muzzle\n      a = this.angle / 180 * Math.PI;\n      var x = this.x;\n      x += Math.cos(a) * this.size;\n      var y = this.y;\n      y -= Math.sin(a) * this.size;\n\n      // Muzzle velocity varies based on\n      // distance of the mouse from the\n      // cannon\n      var vStr = 0.05 * (dist + 10);\n      \n      // Distribute the muzzle velocity\n      // across velocity in x and y\n      var vx = Math.cos(a) * vStr;\n      var vy = Math.sin(a) * vStr;\n      \n      // Finally, create a new bullet\n      var bullet = new Bullet(x, y, vx, -vy);\n      world.bullets.push(bullet);\n      \n      // Don't let us shoot again for\n      // a little while\n      this.reload = this.reloadDelay;\n    }\n    if (this.reload) { this.reload--; }\n  };\n}\n\n// The cannon shoots bullets\nfunction Bullet(x, y, vx, vy) {\n  // Position\n  this.x = x;\n  this.y = y;\n  // Velocity\n  this.vx = vx;\n  this.vy = vy;\n  // Constants\n  this.size = 5;\n  this.angle = 0;\n  this.va = 10;  // Angular velocity\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    // Spin the bullets\n    this.angle += this.va;\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += world.gravity;\n  };\n  \n  this.draw = function() {\n    // Bullets are drawn as a little spinning\n    // box\n    var s = this.size;\n    c.save();\n    c.translate(this.x, this.y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.fillRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n  \n  this.shouldDie = function() {\n    return this.y > h;\n  };\n}\n\n// A bullet (and anything the bullet hits) turns\n// into an explosion, which is a shower of\n// particles\nfunction Explosion(source) {\n  this.particles = [];\n  \n  this.init = function(s) {\n    var num = s.size * 2;\n    for (var i = 0; i < num; i++) {\n      // Start the explosion in the same \n      // spot as the source, and with random\n      // velocities influenced by, but\n      // not dominated by, the source\n      var vx = 2 * s.vx * (Math.random() - 0.2);\n      vx += 3 * (Math.random() - 0.5);\n      var vy = 2 * s.vy * (Math.random() - 0.2);\n      vy += 3 * (Math.random() - 0.5);\n      var p = new Particle(s.x, s.y, vx, vy);\n      this.particles.push(p);\n    }\n  };\n  this.init(source);\n  \n  this.move = function() {\n    var ps = this.particles;\n    // Delete particles that should die\n    for (var i = ps.length - 1; i >= 0; i--) {\n      var p = ps[i];\n      if (p.shouldDie()) {\n        ps.splice(i, 1);\n      }\n    }\n    // Move all remaining particles\n    for (i = 0; i < ps.length; i++) {\n      ps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    var ps = this.particles;\n    // Draw all particles\n    for (var i = 0; i < ps.length; i++) {\n      ps[i].draw();\n    }\n  };\n  \n  this.shouldDie = function() {\n    return this.particles.length <= 0;\n  };\n}\n\n// A particle is just a single point.\nfunction Particle(x, y, vx, vy) {\n  this.x = x;\n  this.y = y;\n  this.vx = vx;\n  this.vy = vy;\n  // The life of a particle in number of frames.\n  // Particles live for a random time (eg. \n  // from 1-3 seconds)\n  this.life = 1 * world.frames;\n  this.life *= Math.random() * 2 + 1;\n  // Air resistance here is specific to particles\n  // since they are light.\n  this.airResist = 0.97;\n  \n  this.move = function() {\n    this.x += this.vx;\n    this.y += this.vy;\n    if (this.y > h) {\n      // We hit the ground, bounce off\n      // First, compute how far we have left\n      // to move\n      var remain = (this.y - h) / this.vy;\n      // Move to the ground\n      this.y = h;\n      // Reverse the vertical velocity,\n      // simulating a partially elastic collision\n      this.vy = -Math.abs(this.vy) *\n        world.bounce;\n      // Reduce the horizontal velocity too\n      this.vx *= world.bounce;\n      // Move off the ground\n      this.y += this.vy * remain;\n    }\n    // Use gravity if we want this to look\n    // like pieces\n    this.vy += world.gravity;\n    // Use airResist if we want this to look\n    // like drifting sparks\n    this.vx *= this.airResist;\n    this.vy *= this.airResist;\n    this.life -= 1;\n  };\n  \n  this.draw = function() {\n    c.fillRect(this.x, this.y, 1, 1);\n  };\n  \n  this.shouldDie = function() {\n    return this.life <= 0;\n  };\n}\n\n\n// The world holds all the state of the game and\n// manages moving and updating everything\nfunction World() {\n  // Constants\n  this.timeStep = 50;  // In milliseconds\n  this.frames = 1000 / this.timeStep;\n  // Elasticity of collisions with the ground.\n  // Setting to 1.0 is fully elastic, 0.0 is\n  // no bounce at all (landing with a thud).\n  this.bounce = 0.8;\n  // Gravity is an acceleration, so it changes\n  // velocity every frame.\n  this.gravity = 0.5;\n  // This is the odds of us spawning a new enemy\n  // in a frame.  The first number is the\n  // likelihood per second, so 0.6 would mean a \n  // roughly 60% chance of a new enemy every\n  // second\n  this.spawnChance = 0.6 / this.frames;\n  \n  this.init = function() {\n    // World state\n    this.cannon = new Cannon();\n    this.bullets = [];\n    this.explosions = [];\n    this.enemies = [];\n  };\n\n  this.update = function() {\n    this.spawn();\n    this.move();\n    this.collide();\n    this.draw();\n  };\n\n  this.spawn = function() {\n    // Spawn new enemies\n    var chance = world.spawnChance;\n    // Don't spawn new enemies as much if there\n    // are already enemies out there, that\n    // makes the game not fun since you can't\n    // reload fast enough to have any ability\n    // to win\n    chance /= this.enemies.length + 1;\n    if (Math.random() < chance) {\n        this.enemies.push(new Enemy());\n    }\n  };\n\n  this.move = function() {\n    // Move everything\n    this.cannon.move();\n    var l = this.bullets.length;\n    for (var i = l - 1; i >= 0; i--) {\n      var b = this.bullets[i];\n      if (b.shouldDie()) {\n        // The bullet has hit the ground or\n        // exploded or otherwise needs to die.\n        // Add an explosion\n        var e = new Explosion(b);\n        this.explosions.push(e);\n        // Delete the bullet\n        this.bullets.splice(i, 1);\n      } else {\n        b.move();\n      }\n    }\n    l = this.explosions.length;\n    for (i = l - 1; i >= 0; i--) {\n      var ex = this.explosions[i];\n      if (ex.shouldDie()) {\n        this.explosions.splice(i, 1);\n      } else {\n        ex.move();\n      }\n    }\n    l = this.enemies.length;\n    for (i = l - 1; i >= 0; i--) {\n      var em = this.enemies[i];\n      if (em.shouldDie()) {\n        this.enemies.splice(i, 1);\n      } else {\n        em.move();\n      }\n    }\n  };\n\n  this.collide = function() {\n    // Our collision detection is a little \n    // simple, it just checks if two objects\n    // overlap, leaving open the possiblity that\n    // fast moving objects will actually move\n    // through each other in one frame. Oh well.\n\n    // Check for collisions between bullets\n    // and enemies\n    var e;\n    var l = this.enemies.length;\n    for (var i = 0; i < l; i++) {\n      e = this.enemies[i];\n      var l2 = this.bullets.length;\n      for (var j = 0; j < l2; j++) {\n        var b = this.bullets[j];\n        if (e.dead || b.dead) { continue; }\n        if (e.isOverlap(b)) {\n          // An enemy and bullet have collided.\n          // Mark both as dead\n          e.dead = b.dead = true;\n          // Add an explosion\n          var obj = {x: (e.x + b.x) / 2,\n                     y: (e.y + b.y) / 2,\n                     vx: (e.vx + b.vx) / 2,\n                     vy: (e.vy + b.vy) / 2,\n                     size: e.size + b.size\n                    };\n          var ex = new Explosion(obj);\n          this.explosions.push(ex);\n        }\n      }\n    }\n    l = this.enemies.length;\n    for (i = l - 1; i >= 0; i--) {\n      if (this.enemies[i].dead) {\n        this.enemies.splice(i, 1);\n      }\n    }\n    l = this.bullets.length;\n    for (i = l - 1; i >= 0; i--) {\n      if (this.bullets[i].dead) {\n        this.bullets.splice(i, 1);\n      }\n    }\n  };\n\n  this.draw = function() {\n    // Redraw everything\n    c.clearRect(0, 0, w, h);\n    this.cannon.draw();\n    var l = this.bullets.length;\n    for (var i = 0; i < l; i++) {\n      this.bullets[i].draw();\n    }\n    l = this.explosions.length;\n    for (i = 0; i < l; i++) {\n      this.explosions[i].draw();\n    }\n    l = this.enemies.length;\n    for (i = 0; i < l; i++) {\n      this.enemies[i].draw();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the world\nvar world = new World();\nworld.init();\n\n// Animation loop\nvar cmTID;\nfunction updateAll() {\n  world.update();\n\n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  if (!world.gameOver) {\n    cmTID = setTimeout(updateAll,\n                       world.timeStep);\n  }\n}\nupdateAll();",
      lessonSection: "Enemies and Collisions",
      tutorImage: 3,
    },
    { message: "You can really see what the game is going to be like now, can't you? But wait! The bullets just go through the enemies. That won't do at all. We need the bullets to explode the enemies in a shower of particles when they hit them! So let's do that. Look in the code for the isOverlap() method in the Enemy object and the comments there that tell you what to do.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n\n// Enemies start at a random spot on the \n// right side and move left, either hitting \n// the cannon, going off the left side of the\n// screen, or getting hit by a bullet\nfunction Enemy() {\n  // Size\n  this.r = 10 + 15 * Math.random();\n  this.size = this.r * 2;\n  // Position\n  this.x = w;\n  this.y = h / 2;\n  this.y += (h - this.r) / 2 * Math.random();\n  // Velocity\n  this.vx = -Math.random() * 3 - 1;\n  this.vy = (Math.random() - 0.5) * 20;\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    var bottom = h - this.r;\n    if (this.y > bottom) {\n      // We hit the ground, bounce off\n      // First, compute how far we have left\n      // to move\n      var remain = (this.y - bottom) / this.vy;\n      // Move to the ground\n      this.y = bottom;\n      // Reverse the vertical velocity,\n      // simulating a partially elastic collision\n      this.vy = -Math.abs(this.vy) *\n        world.bounce;\n      // Move off the ground\n      this.y += this.vy * remain;\n    }\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += world.gravity;\n  };\n  \n  this.draw = function() {\n    // Enemies are drawn as a little circle\n    c.beginPath();\n    c.arc(this.x, this.y, this.r,\n          0, Math.PI * 2);\n    c.stroke();\n  };\n  \n  this.isOverlap = function(o2) {\n    // You can assume the object passed in, o2,\n    // has method variables for position (x\n    // and y) and for size.\n    // You should compare that against this\n    // enemy's x and y and size. x and y are\n    // the centers of each of the objects and\n    // size is twice the radius, so the two\n    // should overlap when the distance between\n    // the two objects (calculated from the \n    // difference of their positions) is less\n    // than the average of their sizes.\n    // I'm not going to help you more than\n    // that, you should be able to write this\n    // yourself now, returning true if the\n    // two objects overlap, false otherwise.\n    // If you get stuck, try looking at through\n    // the code for what Cannon does when it\n    // computes the distance from the cannon\n    // to the mouse, that might help you.\n    // If you get this right, you should be\n    // able to shoot the enemies with the\n    // cannon when you are done.\n    \n    \n  };\n  \n  this.shouldDie = function() {\n    return this.x + this.r < 0;\n  };\n}\n\n// The cannon fits snugly at the bottom left\n// corner of the screen and shoots bullets.\n// The game is over when the cannon is hit\n// by an enemy.\nfunction Cannon() {\n  // Constants\n  this.size = 30;\n  // Position\n  this.x = this.size / 2;\n  this.y = h - this.size / 2;\n  // Initial angle, this tracks the mouse soon\n  this.angle = 45;\n  // How many frames we have to wait to shoot\n  // again, the first number is time in seconds,\n  // so, if it is 0.5, that means a half a \n  // second delay\n  this.reloadDelay = 0.7 * world.frames;\n  \n  this.draw = function() {\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.save();\n    // Move to the center of the cannon\n    c.translate(x, y);\n    // The cannon sits on a little stand\n    // half of its height and 10% its width\n    c.strokeRect(-s * 0.1 / 2, 0,\n                 s * 0.1, s / 2);\n    // The cannon itself is two rectangles,\n    // next to each other and rotated\n    // through the angle\n    c.rotate(-this.angle * Math.PI / 180);\n    c.fillRect(-s * 0.4, -s * 0.4 / 2,\n               s * 0.4, s * 0.4);\n    c.fillRect(0, -s * 0.1, s * 0.5, s * 0.2);\n    c.restore();\n  };\n  \n  this.move = function() {\n    // Change angle to match mouse location\n    var diffX = mouse.x - this.x;\n    var diffY = mouse.y - this.y;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    var a = -Math.atan2(diffY, diffX);\n    this.angle = a / Math.PI * 180;\n    \n    // If mouse is down and not reloading, fire\n    if (isMouseDown && !this.reload) {\n      // Create a bullet at the end of the\n      // muzzle\n      a = this.angle / 180 * Math.PI;\n      var x = this.x;\n      x += Math.cos(a) * this.size;\n      var y = this.y;\n      y -= Math.sin(a) * this.size;\n\n      // Muzzle velocity varies based on\n      // distance of the mouse from the\n      // cannon\n      var vStr = 0.05 * (dist + 10);\n      \n      // Distribute the muzzle velocity\n      // across velocity in x and y\n      var vx = Math.cos(a) * vStr;\n      var vy = Math.sin(a) * vStr;\n      \n      // Finally, create a new bullet\n      var bullet = new Bullet(x, y, vx, -vy);\n      world.bullets.push(bullet);\n      \n      // Don't let us shoot again for\n      // a little while\n      this.reload = this.reloadDelay;\n    }\n    if (this.reload) { this.reload--; }\n  };\n}\n\n// The cannon shoots bullets\nfunction Bullet(x, y, vx, vy) {\n  // Position\n  this.x = x;\n  this.y = y;\n  // Velocity\n  this.vx = vx;\n  this.vy = vy;\n  // Constants\n  this.size = 5;\n  this.angle = 0;\n  this.va = 10;  // Angular velocity\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    // Spin the bullets\n    this.angle += this.va;\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += world.gravity;\n  };\n  \n  this.draw = function() {\n    // Bullets are drawn as a little spinning\n    // box\n    var s = this.size;\n    c.save();\n    c.translate(this.x, this.y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.fillRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n  \n  this.shouldDie = function() {\n    return this.y > h;\n  };\n}\n\n// A bullet (and anything the bullet hits) turns\n// into an explosion, which is a shower of\n// particles\nfunction Explosion(source) {\n  this.particles = [];\n  \n  this.init = function(s) {\n    var num = s.size * 2;\n    for (var i = 0; i < num; i++) {\n      // Start the explosion in the same \n      // spot as the source, and with random\n      // velocities influenced by, but\n      // not dominated by, the source\n      var vx = 2 * s.vx * (Math.random() - 0.2);\n      vx += 3 * (Math.random() - 0.5);\n      var vy = 2 * s.vy * (Math.random() - 0.2);\n      vy += 3 * (Math.random() - 0.5);\n      var p = new Particle(s.x, s.y, vx, vy);\n      this.particles.push(p);\n    }\n  };\n  this.init(source);\n  \n  this.move = function() {\n    var ps = this.particles;\n    // Delete particles that should die\n    for (var i = ps.length - 1; i >= 0; i--) {\n      var p = ps[i];\n      if (p.shouldDie()) {\n        ps.splice(i, 1);\n      }\n    }\n    // Move all remaining particles\n    for (i = 0; i < ps.length; i++) {\n      ps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    var ps = this.particles;\n    // Draw all particles\n    for (var i = 0; i < ps.length; i++) {\n      ps[i].draw();\n    }\n  };\n  \n  this.shouldDie = function() {\n    return this.particles.length <= 0;\n  };\n}\n\n// A particle is just a single point.\nfunction Particle(x, y, vx, vy) {\n  this.x = x;\n  this.y = y;\n  this.vx = vx;\n  this.vy = vy;\n  // The life of a particle in number of frames.\n  // Particles live for a random time (eg. \n  // from 1-3 seconds)\n  this.life = 1 * world.frames;\n  this.life *= Math.random() * 2 + 1;\n  // Air resistance here is specific to particles\n  // since they are light.\n  this.airResist = 0.97;\n  \n  this.move = function() {\n    this.x += this.vx;\n    this.y += this.vy;\n    if (this.y > h) {\n      // We hit the ground, bounce off\n      // First, compute how far we have left\n      // to move\n      var remain = (this.y - h) / this.vy;\n      // Move to the ground\n      this.y = h;\n      // Reverse the vertical velocity,\n      // simulating a partially elastic collision\n      this.vy = -Math.abs(this.vy) *\n        world.bounce;\n      // Reduce the horizontal velocity too\n      this.vx *= world.bounce;\n      // Move off the ground\n      this.y += this.vy * remain;\n    }\n    // Use gravity if we want this to look\n    // like pieces\n    this.vy += world.gravity;\n    // Use airResist if we want this to look\n    // like drifting sparks\n    this.vx *= this.airResist;\n    this.vy *= this.airResist;\n    this.life -= 1;\n  };\n  \n  this.draw = function() {\n    c.fillRect(this.x, this.y, 1, 1);\n  };\n  \n  this.shouldDie = function() {\n    return this.life <= 0;\n  };\n}\n\n\n// The world holds all the state of the game and\n// manages moving and updating everything\nfunction World() {\n  // Constants\n  this.timeStep = 50;  // In milliseconds\n  this.frames = 1000 / this.timeStep;\n  // Elasticity of collisions with the ground.\n  // Setting to 1.0 is fully elastic, 0.0 is\n  // no bounce at all (landing with a thud).\n  this.bounce = 0.8;\n  // Gravity is an acceleration, so it changes\n  // velocity every frame.\n  this.gravity = 0.5;\n  // This is the odds of us spawning a new enemy\n  // in a frame.  The first number is the\n  // likelihood per second, so 0.6 would mean a \n  // roughly 60% chance of a new enemy every\n  // second\n  this.spawnChance = 0.6 / this.frames;\n  \n  this.init = function() {\n    // World state\n    this.cannon = new Cannon();\n    this.bullets = [];\n    this.explosions = [];\n    this.enemies = [];\n  };\n\n  this.update = function() {\n    this.spawn();\n    this.move();\n    this.collide();\n    this.draw();\n  };\n\n  this.spawn = function() {\n    // Spawn new enemies\n    var chance = world.spawnChance;\n    // Don't spawn new enemies as much if there\n    // are already enemies out there, that\n    // makes the game not fun since you can't\n    // reload fast enough to have any ability\n    // to win\n    chance /= this.enemies.length + 1;\n    if (Math.random() < chance) {\n        this.enemies.push(new Enemy());\n    }\n  };\n\n  this.move = function() {\n    // Move everything\n    this.cannon.move();\n    var l = this.bullets.length;\n    for (var i = l - 1; i >= 0; i--) {\n      var b = this.bullets[i];\n      if (b.shouldDie()) {\n        // The bullet has hit the ground or\n        // exploded or otherwise needs to die.\n        // Add an explosion\n        var e = new Explosion(b);\n        this.explosions.push(e);\n        // Delete the bullet\n        this.bullets.splice(i, 1);\n      } else {\n        b.move();\n      }\n    }\n    l = this.explosions.length;\n    for (i = l - 1; i >= 0; i--) {\n      var ex = this.explosions[i];\n      if (ex.shouldDie()) {\n        this.explosions.splice(i, 1);\n      } else {\n        ex.move();\n      }\n    }\n    l = this.enemies.length;\n    for (i = l - 1; i >= 0; i--) {\n      var em = this.enemies[i];\n      if (em.shouldDie()) {\n        this.enemies.splice(i, 1);\n      } else {\n        em.move();\n      }\n    }\n  };\n\n  this.collide = function() {\n    // Our collision detection is a little \n    // simple, it just checks if two objects\n    // overlap, leaving open the possiblity that\n    // fast moving objects will actually move\n    // through each other in one frame. Oh well.\n\n    // Check for collisions between bullets\n    // and enemies\n    var e;\n    var l = this.enemies.length;\n    for (var i = 0; i < l; i++) {\n      e = this.enemies[i];\n      var l2 = this.bullets.length;\n      for (var j = 0; j < l2; j++) {\n        var b = this.bullets[j];\n        if (e.dead || b.dead) { continue; }\n        if (e.isOverlap(b)) {\n          // An enemy and bullet have collided.\n          // Mark both as dead\n          e.dead = b.dead = true;\n          // Add an explosion\n          var obj = {x: (e.x + b.x) / 2,\n                     y: (e.y + b.y) / 2,\n                     vx: (e.vx + b.vx) / 2,\n                     vy: (e.vy + b.vy) / 2,\n                     size: e.size + b.size\n                    };\n          var ex = new Explosion(obj);\n          this.explosions.push(ex);\n        }\n      }\n    }\n    l = this.enemies.length;\n    for (i = l - 1; i >= 0; i--) {\n      if (this.enemies[i].dead) {\n        this.enemies.splice(i, 1);\n      }\n    }\n    l = this.bullets.length;\n    for (i = l - 1; i >= 0; i--) {\n      if (this.bullets[i].dead) {\n        this.bullets.splice(i, 1);\n      }\n    }\n  };\n\n  this.draw = function() {\n    // Redraw everything\n    c.clearRect(0, 0, w, h);\n    this.cannon.draw();\n    var l = this.bullets.length;\n    for (var i = 0; i < l; i++) {\n      this.bullets[i].draw();\n    }\n    l = this.explosions.length;\n    for (i = 0; i < l; i++) {\n      this.explosions[i].draw();\n    }\n    l = this.enemies.length;\n    for (i = 0; i < l; i++) {\n      this.enemies[i].draw();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the world\nvar world = new World();\nworld.init();\n\n// Animation loop\nvar cmTID;\nfunction updateAll() {\n  world.update();\n\n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  if (!world.gameOver) {\n    cmTID = setTimeout(updateAll,\n                       world.timeStep);\n  }\n}\nupdateAll();",
      tutorImage: 1,
    },
    { message: "If you finished that, we're really close to having a complete game.  We have a cannon that shoots. The bullets explode -- ka-boom! -- into a really satisfying shower of particles when they hit enemies or the ground. Enemies are randomly generated and come flying toward the cannon. There's a few things left. We need a score, the game to get harder the longer you play, and the game to end when the cannon gets hit by an enemy.",
      lessonSection: "Finishing the Second Game",
      tutorImage: 3,
    },
    { message: "Let's finish the game! You need to add the score (which increases every time you kill an enemy), check for game over (an enemy in contact with the cannon), and increase the difficulty (increase the spawn rate as the score goes up).  I'll add comments in the code that help you, but you'll have to figure out where to make the changes to find those comments. Can you do it? Can you add score, increasing difficulty, and game over?",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n// The cannon fits snugly at the bottom left\n// corner of the screen and shoots bullets.\n// The game is over when the cannon is hit\n// by an enemy.\nfunction Cannon() {\n  // Constants\n  this.size = 30;\n  // Position\n  this.x = this.size / 2;\n  this.y = h - this.size / 2;\n  // Initial angle, this tracks the mouse soon\n  this.angle = 45;\n  // How many frames we have to wait to shoot\n  // again, the first number is time in seconds,\n  // so, if it is 0.5, that means a half a \n  // second delay\n  this.reloadDelay = 0.7 * world.frames;\n  \n  this.draw = function() {\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.save();\n    // Move to the center of the cannon\n    c.translate(x, y);\n    // The cannon sits on a little stand\n    // half of its height and 10% its width\n    c.strokeRect(-s * 0.1 / 2, 0,\n                 s * 0.1, s / 2);\n    // The cannon itself is two rectangles,\n    // next to each other and rotated\n    // through the angle\n    c.rotate(-this.angle * Math.PI / 180);\n    c.fillRect(-s * 0.4, -s * 0.4 / 2,\n               s * 0.4, s * 0.4);\n    c.fillRect(0, -s * 0.1, s * 0.5, s * 0.2);\n    c.restore();\n  };\n  \n  this.move = function() {\n    // Change angle to match mouse location\n    var diffX = mouse.x - this.x;\n    var diffY = mouse.y - this.y;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    var a = -Math.atan2(diffY, diffX);\n    this.angle = a / Math.PI * 180;\n    \n    // If mouse is down and not reloading, fire\n    if (isMouseDown && !this.reload) {\n      // Create a bullet at the end of the\n      // muzzle\n      a = this.angle / 180 * Math.PI;\n      var x = this.x;\n      x += Math.cos(a) * this.size;\n      var y = this.y;\n      y -= Math.sin(a) * this.size;\n\n      // Muzzle velocity varies based on\n      // distance of the mouse from the\n      // cannon\n      var vStr = 0.05 * (dist + 10);\n      \n      // Distribute the muzzle velocity\n      // across velocity in x and y\n      var vx = Math.cos(a) * vStr;\n      var vy = Math.sin(a) * vStr;\n      \n      // Finally, create a new bullet\n      var bullet = new Bullet(x, y, vx, -vy);\n      world.bullets.push(bullet);\n      \n      // Don't let us shoot again for\n      // a little while\n      this.reload = this.reloadDelay;\n    }\n    if (this.reload) { this.reload--; }\n  };\n}\n\n// Enemies start at a random spot on the \n// right side and move left, either hitting \n// the cannon, going off the left side of the\n// screen, or getting hit by a bullet\nfunction Enemy() {\n  // Size\n  this.r = 10 + 15 * Math.random();\n  this.size = this.r * 2;\n  // Position\n  this.x = w;\n  this.y = h / 2;\n  this.y += (h - this.r) / 2 * Math.random();\n  // Velocity\n  this.vx = -Math.random() * 3 - 1;\n  this.vy = (Math.random() - 0.5) * 20;\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    var bottom = h - this.r;\n    if (this.y > bottom) {\n      // We hit the ground, bounce off\n      // First, compute how far we have left\n      // to move\n      var remain = (this.y - bottom) / this.vy;\n      // Move to the ground\n      this.y = bottom;\n      // Reverse the vertical velocity,\n      // simulating a partially elastic collision\n      this.vy = -Math.abs(this.vy) *\n        world.bounce;\n      // Move off the ground\n      this.y += this.vy * remain;\n    }\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += world.gravity;\n  };\n  \n  this.draw = function() {\n    // Enemies are drawn as a little circle\n    c.beginPath();\n    c.arc(this.x, this.y, this.r,\n          0, Math.PI * 2);\n    c.stroke();\n  };\n  \n  this.isOverlap = function(o2) {\n    // Checks if the enemy overlaps another\n    // object.  Assumes whatever is passed\n    // in is an object with x, y, and size\n    var o1 = this;\n    var dx = o1.x - o2.x;\n    var dy = o1.y - o2.y;\n    var s = (o1.size + o2.size) / 2;\n    var d = Math.sqrt(dx * dx + dy * dy);\n    return (d <= s);\n  };\n  \n  this.shouldDie = function() {\n    return this.x + this.r < 0;\n  };\n}\n\n// The cannon shoots bullets\nfunction Bullet(x, y, vx, vy) {\n  // Position\n  this.x = x;\n  this.y = y;\n  // Velocity\n  this.vx = vx;\n  this.vy = vy;\n  // Constants\n  this.size = 5;\n  this.angle = 0;\n  this.va = 10;  // Angular velocity\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    // Spin the bullets\n    this.angle += this.va;\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += world.gravity;\n  };\n  \n  this.draw = function() {\n    // Bullets are drawn as a little spinning\n    // box\n    var s = this.size;\n    c.save();\n    c.translate(this.x, this.y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.fillRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n  \n  this.shouldDie = function() {\n    return this.y > h;\n  };\n}\n\n// A bullet (and anything the bullet hits) turns\n// into an explosion, which is a shower of\n// particles\nfunction Explosion(source) {\n  this.particles = [];\n  \n  this.init = function(s) {\n    var num = s.size * 2;\n    for (var i = 0; i < num; i++) {\n      // Start the explosion in the same \n      // spot as the source, and with random\n      // velocities influenced by, but\n      // not dominated by, the source\n      var vx = 2 * s.vx * (Math.random() - 0.2);\n      vx += 3 * (Math.random() - 0.5);\n      var vy = 2 * s.vy * (Math.random() - 0.2);\n      vy += 3 * (Math.random() - 0.5);\n      var p = new Particle(s.x, s.y, vx, vy);\n      this.particles.push(p);\n    }\n  };\n  this.init(source);\n  \n  this.move = function() {\n    var ps = this.particles;\n    // Delete particles that should die\n    for (var i = ps.length - 1; i >= 0; i--) {\n      var p = ps[i];\n      if (p.shouldDie()) {\n        ps.splice(i, 1);\n      }\n    }\n    // Move all remaining particles\n    for (i = 0; i < ps.length; i++) {\n      ps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    var ps = this.particles;\n    // Draw all particles\n    for (var i = 0; i < ps.length; i++) {\n      ps[i].draw();\n    }\n  };\n  \n  this.shouldDie = function() {\n    return this.particles.length <= 0;\n  };\n}\n\n// A particle is just a single point.\nfunction Particle(x, y, vx, vy) {\n  this.x = x;\n  this.y = y;\n  this.vx = vx;\n  this.vy = vy;\n  // The life of a particle in number of frames.\n  // Particles live for a random time (eg. \n  // from 1-3 seconds)\n  this.life = 1 * world.frames;\n  this.life *= Math.random() * 2 + 1;\n  // Air resistance here is specific to particles\n  // since they are light.\n  this.airResist = 0.97;\n  \n  this.move = function() {\n    this.x += this.vx;\n    this.y += this.vy;\n    if (this.y > h) {\n      // We hit the ground, bounce off\n      // First, compute how far we have left\n      // to move\n      var remain = (this.y - h) / this.vy;\n      // Move to the ground\n      this.y = h;\n      // Reverse the vertical velocity,\n      // simulating a partially elastic collision\n      this.vy = -Math.abs(this.vy) *\n        world.bounce;\n      // Reduce the horizontal velocity too\n      this.vx *= world.bounce;\n      // Move off the ground\n      this.y += this.vy * remain;\n    }\n    // Use gravity if we want this to look\n    // like pieces\n    this.vy += world.gravity;\n    // Use airResist if we want this to look\n    // like drifting sparks\n    this.vx *= this.airResist;\n    this.vy *= this.airResist;\n    this.life -= 1;\n  };\n  \n  this.draw = function() {\n    c.fillRect(this.x, this.y, 1, 1);\n  };\n  \n  this.shouldDie = function() {\n    return this.life <= 0;\n  };\n}\n\n\n// The world holds all the state of the game and\n// manages moving and updating everything\nfunction World() {\n  // Constants\n  this.timeStep = 50;  // In milliseconds\n  this.frames = 1000 / this.timeStep;\n  // Elasticity of collisions with the ground.\n  // Setting to 1.0 is fully elastic, 0.0 is\n  // no bounce at all (landing with a thud).\n  this.bounce = 0.8;\n  // Gravity is an acceleration, so it changes\n  // velocity every frame.\n  this.gravity = 0.5;\n  // This is the odds of us spawning a new enemy\n  // in a frame.  The first number is the\n  // likelihood per second, so 0.6 would mean a \n  // roughly 60% chance of a new enemy every\n  // second\n  this.spawnChance = 0.6 / this.frames;\n  \n  this.init = function() {\n    // World state\n    this.cannon = new Cannon();\n    this.bullets = [];\n    this.explosions = [];\n    this.enemies = [];\n    this.score = 0;\n    this.gameOver = false;\n  };\n\n  this.update = function() {\n    this.spawn();\n    this.move();\n    this.collide();\n    this.draw();\n  };\n\n  this.spawn = function() {\n    // Spawn new enemies\n    // Right now, the chance of spawning an\n    // enemy is the same throughout the game.\n    // To increase the difficulty, we want to\n    // make more enemies spawn as the game\n    // goes on. One way to do that is to\n    // increase the spawn chance when the\n    // score is higher, but feel free to do\n    // whatever you like to make the game\n    // harder the longer you play.\n    var chance = world.spawnChance;\n\n    // Don't spawn new enemies as much if there\n    // are already enemies out there, that\n    // makes the game not fun since you can't\n    // reload fast enough to have any ability\n    // to win\n    chance /= this.enemies.length + 1;\n    if (Math.random() < chance) {\n        this.enemies.push(new Enemy());\n    }\n  };\n\n  this.move = function() {\n    // Move everything\n    this.cannon.move();\n    var l = this.bullets.length;\n    for (var i = l - 1; i >= 0; i--) {\n      var b = this.bullets[i];\n      if (b.shouldDie()) {\n        // The bullet has hit the ground or\n        // exploded or otherwise needs to die.\n        // Add an explosion\n        var e = new Explosion(b);\n        this.explosions.push(e);\n        // Delete the bullet\n        this.bullets.splice(i, 1);\n      } else {\n        b.move();\n      }\n    }\n    l = this.explosions.length;\n    for (i = l - 1; i >= 0; i--) {\n      var ex = this.explosions[i];\n      if (ex.shouldDie()) {\n        this.explosions.splice(i, 1);\n      } else {\n        ex.move();\n      }\n    }\n    l = this.enemies.length;\n    for (i = l - 1; i >= 0; i--) {\n      var em = this.enemies[i];\n      if (em.shouldDie()) {\n        this.enemies.splice(i, 1);\n      } else {\n        em.move();\n      }\n    }\n  };\n\n  this.collide = function() {\n    // Our collision detection is a little \n    // simple, it just checks if two objects\n    // overlap, leaving open the possiblity that\n    // fast moving objects will actually move\n    // through each other in one frame. Oh well.\n\n    // Check for collisions between bullets\n    // and enemies\n    var e;\n    var l = this.enemies.length;\n    for (var i = 0; i < l; i++) {\n      e = this.enemies[i];\n      // Check whether this particular enemy\n      // is touching any of the bullets\n      var l2 = this.bullets.length;\n      for (var j = 0; j < l2; j++) {\n        var b = this.bullets[j];\n        if (e.dead || b.dead) { continue; }\n        if (e.isOverlap(b)) {\n          // An enemy and bullet have collided.\n          // Mark both as dead\n          e.dead = b.dead = true;\n          // Add an explosion\n          var obj = {x: (e.x + b.x) / 2,\n                     y: (e.y + b.y) / 2,\n                     vx: (e.vx + b.vx) / 2,\n                     vy: (e.vy + b.vy) / 2,\n                     size: e.size + b.size\n                    };\n          var ex = new Explosion(obj);\n          this.explosions.push(ex);\n          \n          // Hey, an enemy has just been\n          // killed and turned into an explosion.\n          // This may be a good place to change\n          // the score.  I'd recommend giving\n          // the player 100 points for each\n          // enemy killed, but do whatever you\n          // like.\n          \n        }\n      }\n      \n      // So, we just finished checking if this\n      // particular enemy is touching any\n      // of the bullets.  This might be a \n      // good spot to check if this enemy is\n      // touching the cannon too.  If it is,\n      // well, the game should be over, right?\n      \n    }\n    l = this.enemies.length;\n    for (i = l - 1; i >= 0; i--) {\n      if (this.enemies[i].dead) {\n        this.enemies.splice(i, 1);\n      }\n    }\n    l = this.bullets.length;\n    for (i = l - 1; i >= 0; i--) {\n      if (this.bullets[i].dead) {\n        this.bullets.splice(i, 1);\n      }\n    }\n  };\n\n  this.draw = function() {\n    // Redraw everything\n    c.clearRect(0, 0, w, h);\n    this.cannon.draw();\n    var l = this.bullets.length;\n    for (var i = 0; i < l; i++) {\n      this.bullets[i].draw();\n    }\n    l = this.explosions.length;\n    for (i = 0; i < l; i++) {\n      this.explosions[i].draw();\n    }\n    l = this.enemies.length;\n    for (i = 0; i < l; i++) {\n      this.enemies[i].draw();\n    }\n    \n    // This is where the score is shown, but\n    // only if it exists.  You need to create\n    // it and add to it whenever an enemy is\n    // destroyed.  Where are the enemies \n    // turned to explosions? Find that spot\n    // and increment the score there.\n    // Show the score on the screen\n    if (this.score) {\n      c.fillText('Score: ' + this.score, \n                 w * 0.8, 20);\n    }\n    // This is where the 'GAME OVER' is\n    // displayed, but not where it is set.\n    // Try looking for code that might check\n    // for collisions to find out what to\n    // change to detect that the game is over.\n    // If the game is over, display game over\n    // text\n    if (this.gameOver) {\n      c.save();\n      c.font = '48pt sans-serif';\n      c.textAlign = 'center';\n      c.fillStyle = 'red';\n      c.textBaseline = 'middle';\n      c.fillText('GAME OVER', w / 2, h / 2);\n      c.restore();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the world\nvar world = new World();\nworld.init();\n\n// Animation loop\nvar cmTID;\nfunction updateAll() {\n  world.update();\n\n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  if (!world.gameOver) {\n    cmTID = setTimeout(updateAll,\n                       world.timeStep);\n  }\n}\nupdateAll();",
      tutorImage: 6,
    },
    { message: "Did you finish the game? Everything working okay? Isn't it cool?",
      tutorImage: 1,
    },
    { message: "Here's my finished game. Is it the same as yours? Try playing it for a while. It's really pretty fun!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n// The cannon fits snugly at the bottom left\n// corner of the screen and shoots bullets.\n// The game is over when the cannon is hit\n// by an enemy.\nfunction Cannon() {\n  // Constants\n  this.size = 30;\n  // Position\n  this.x = this.size / 2;\n  this.y = h - this.size / 2;\n  // Initial angle, this tracks the mouse soon\n  this.angle = 45;\n  // How many frames we have to wait to shoot\n  // again, the first number is time in seconds,\n  // so, if it is 0.5, that means a half a \n  // second delay\n  this.reloadDelay = 0.7 * world.frames;\n  \n  this.draw = function() {\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.save();\n    // Move to the center of the cannon\n    c.translate(x, y);\n    // The cannon sits on a little stand\n    // half of its height and 10% its width\n    c.strokeRect(-s * 0.1 / 2, 0,\n                 s * 0.1, s / 2);\n    // The cannon itself is two rectangles,\n    // next to each other and rotated\n    // through the angle\n    c.rotate(-this.angle * Math.PI / 180);\n    c.fillRect(-s * 0.4, -s * 0.4 / 2,\n               s * 0.4, s * 0.4);\n    c.fillRect(0, -s * 0.1, s * 0.5, s * 0.2);\n    c.restore();\n  };\n  \n  this.move = function() {\n    // Change angle to match mouse location\n    var diffX = mouse.x - this.x;\n    var diffY = mouse.y - this.y;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    var a = -Math.atan2(diffY, diffX);\n    this.angle = a / Math.PI * 180;\n    \n    // If mouse is down and not reloading, fire\n    if (isMouseDown && !this.reload) {\n      // Create a bullet at the end of the\n      // muzzle\n      a = this.angle / 180 * Math.PI;\n      var x = this.x;\n      x += Math.cos(a) * this.size;\n      var y = this.y;\n      y -= Math.sin(a) * this.size;\n\n      // Muzzle velocity varies based on\n      // distance of the mouse from the\n      // cannon\n      var vStr = 0.05 * (dist + 10);\n      \n      // Distribute the muzzle velocity\n      // across velocity in x and y\n      var vx = Math.cos(a) * vStr;\n      var vy = Math.sin(a) * vStr;\n      \n      // Finally, create a new bullet\n      var bullet = new Bullet(x, y, vx, -vy);\n      world.bullets.push(bullet);\n      \n      // Don't let us shoot again for\n      // a little while\n      this.reload = this.reloadDelay;\n    }\n    if (this.reload) { this.reload--; }\n  };\n}\n\n// Enemies start at a random spot on the \n// right side and move left, either hitting \n// the cannon, going off the left side of the\n// screen, or getting hit by a bullet\nfunction Enemy() {\n  // Size\n  this.r = 10 + 15 * Math.random();\n  this.size = this.r * 2;\n  // Position\n  this.x = w;\n  this.y = h / 2;\n  this.y += (h - this.r) / 2 * Math.random();\n  // Velocity\n  this.vx = -Math.random() * 3 - 1;\n  this.vy = (Math.random() - 0.5) * 20;\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    var bottom = h - this.r;\n    if (this.y > bottom) {\n      // We hit the ground, bounce off\n      // First, compute how far we have left\n      // to move\n      var remain = (this.y - bottom) / this.vy;\n      // Move to the ground\n      this.y = bottom;\n      // Reverse the vertical velocity,\n      // simulating a partially elastic collision\n      this.vy = -Math.abs(this.vy) *\n        world.bounce;\n      // Move off the ground\n      this.y += this.vy * remain;\n    }\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += world.gravity;\n  };\n  \n  this.draw = function() {\n    // Enemies are drawn as a little circle\n    c.beginPath();\n    c.arc(this.x, this.y, this.r,\n          0, Math.PI * 2);\n    c.stroke();\n  };\n  \n  this.isOverlap = function(o2) {\n    // Checks if the enemy overlaps another\n    // object.  Assumes whatever is passed\n    // in is an object with x, y, and size\n    var o1 = this;\n    var dx = o1.x - o2.x;\n    var dy = o1.y - o2.y;\n    var s = (o1.size + o2.size) / 2;\n    var d = Math.sqrt(dx * dx + dy * dy);\n    return (d <= s);\n  };\n  \n  this.shouldDie = function() {\n    return this.x + this.r < 0;\n  };\n}\n\n// The cannon shoots bullets\nfunction Bullet(x, y, vx, vy) {\n  // Position\n  this.x = x;\n  this.y = y;\n  // Velocity\n  this.vx = vx;\n  this.vy = vy;\n  // Constants\n  this.size = 5;\n  this.angle = 0;\n  this.va = 10;  // Angular velocity\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    // Spin the bullets\n    this.angle += this.va;\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += world.gravity;\n  };\n  \n  this.draw = function() {\n    // Bullets are drawn as a little spinning\n    // box\n    var s = this.size;\n    c.save();\n    c.translate(this.x, this.y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.fillRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n  \n  this.shouldDie = function() {\n    return this.y > h;\n  };\n}\n\n// A bullet (and anything the bullet hits) turns\n// into an explosion, which is a shower of\n// particles\nfunction Explosion(source) {\n  this.particles = [];\n  \n  this.init = function(s) {\n    var num = s.size * 2;\n    for (var i = 0; i < num; i++) {\n      // Start the explosion in the same \n      // spot as the source, and with random\n      // velocities influenced by, but\n      // not dominated by, the source\n      var vx = 2 * s.vx * (Math.random() - 0.2);\n      vx += 3 * (Math.random() - 0.5);\n      var vy = 2 * s.vy * (Math.random() - 0.2);\n      vy += 3 * (Math.random() - 0.5);\n      var p = new Particle(s.x, s.y, vx, vy);\n      this.particles.push(p);\n    }\n  };\n  this.init(source);\n  \n  this.move = function() {\n    var ps = this.particles;\n    // Delete particles that should die\n    for (var i = ps.length - 1; i >= 0; i--) {\n      var p = ps[i];\n      if (p.shouldDie()) {\n        ps.splice(i, 1);\n      }\n    }\n    // Move all remaining particles\n    for (i = 0; i < ps.length; i++) {\n      ps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    var ps = this.particles;\n    // Draw all particles\n    for (var i = 0; i < ps.length; i++) {\n      ps[i].draw();\n    }\n  };\n  \n  this.shouldDie = function() {\n    return this.particles.length <= 0;\n  };\n}\n\n// A particle is just a single point.\nfunction Particle(x, y, vx, vy) {\n  this.x = x;\n  this.y = y;\n  this.vx = vx;\n  this.vy = vy;\n  // The life of a particle in number of frames.\n  // Particles live for a random time (eg. \n  // from 1-3 seconds)\n  this.life = 1 * world.frames;\n  this.life *= Math.random() * 2 + 1;\n  // Air resistance here is specific to particles\n  // since they are light.\n  this.airResist = 0.97;\n  \n  this.move = function() {\n    this.x += this.vx;\n    this.y += this.vy;\n    if (this.y > h) {\n      // We hit the ground, bounce off\n      // First, compute how far we have left\n      // to move\n      var remain = (this.y - h) / this.vy;\n      // Move to the ground\n      this.y = h;\n      // Reverse the vertical velocity,\n      // simulating a partially elastic collision\n      this.vy = -Math.abs(this.vy) *\n        world.bounce;\n      // Reduce the horizontal velocity too\n      this.vx *= world.bounce;\n      // Move off the ground\n      this.y += this.vy * remain;\n    }\n    // Use gravity if we want this to look\n    // like pieces\n    this.vy += world.gravity;\n    // Use airResist if we want this to look\n    // like drifting sparks\n    this.vx *= this.airResist;\n    this.vy *= this.airResist;\n    this.life -= 1;\n  };\n  \n  this.draw = function() {\n    c.fillRect(this.x, this.y, 1, 1);\n  };\n  \n  this.shouldDie = function() {\n    return this.life <= 0;\n  };\n}\n\n\n// The world holds all the state of the game and\n// manages moving and updating everything\nfunction World() {\n  // Constants\n  this.timeStep = 50;  // In milliseconds\n  this.frames = 1000 / this.timeStep;\n  // Elasticity of collisions with the ground.\n  // Setting to 1.0 is fully elastic, 0.0 is\n  // no bounce at all (landing with a thud).\n  this.bounce = 0.8;\n  // Gravity is an acceleration, so it changes\n  // velocity every frame.\n  this.gravity = 0.5;\n  // This is the odds of us spawning a new enemy\n  // in a frame.  The first number is the\n  // likelihood per second, so 0.6 would mean a \n  // roughly 60% chance of a new enemy every\n  // second\n  this.spawnChance = 0.6 / this.frames;\n  this.maxDifficulty = 10;\n  \n  this.init = function() {\n    // World state\n    this.cannon = new Cannon();\n    this.bullets = [];\n    this.explosions = [];\n    this.enemies = [];\n    this.score = 0;\n    this.gameOver = false;\n  };\n\n  this.update = function() {\n    this.spawn();\n    this.move();\n    this.collide();\n    this.draw();\n  };\n\n  this.spawn = function() {\n    // Spawn new enemies\n    var chance = world.spawnChance;\n    // Make the game slowly get harder as the \n    // score gets higher, up to some maximum\n    var difficulty = this.score / 1000 + 1;\n    difficulty = Math.sqrt(difficulty);\n    difficulty = Math.min(difficulty,\n                          this.maxDifficulty);\n    chance *= difficulty; \n    // Don't spawn new enemies as much if there\n    // are already enemies out there, that\n    // makes the game not fun since you can't\n    // reload fast enough to have any ability\n    // to win\n    chance /= this.enemies.length + 1;\n    if (Math.random() < chance) {\n        this.enemies.push(new Enemy());\n    }\n  };\n\n  this.move = function() {\n    // Move everything\n    this.cannon.move();\n    var l = this.bullets.length;\n    for (var i = l - 1; i >= 0; i--) {\n      var b = this.bullets[i];\n      if (b.shouldDie()) {\n        // The bullet has hit the ground or\n        // exploded or otherwise needs to die.\n        // Add an explosion\n        var e = new Explosion(b);\n        this.explosions.push(e);\n        // Delete the bullet\n        this.bullets.splice(i, 1);\n      } else {\n        b.move();\n      }\n    }\n    l = this.explosions.length;\n    for (i = l - 1; i >= 0; i--) {\n      var ex = this.explosions[i];\n      if (ex.shouldDie()) {\n        this.explosions.splice(i, 1);\n      } else {\n        ex.move();\n      }\n    }\n    l = this.enemies.length;\n    for (i = l - 1; i >= 0; i--) {\n      var em = this.enemies[i];\n      if (em.shouldDie()) {\n        this.enemies.splice(i, 1);\n      } else {\n        em.move();\n      }\n    }\n  };\n\n  this.collide = function() {\n    // Our collision detection is a little \n    // simple, it just checks if two objects\n    // overlap, leaving open the possiblity that\n    // fast moving objects will actually move\n    // through each other in one frame. Oh well.\n\n    // Check for collisions between bullets\n    // and enemies\n    var e;\n    var l = this.enemies.length;\n    for (var i = 0; i < l; i++) {\n      e = this.enemies[i];\n      var l2 = this.bullets.length;\n      for (var j = 0; j < l2; j++) {\n        var b = this.bullets[j];\n        if (e.dead || b.dead) { continue; }\n        if (e.isOverlap(b)) {\n          // An enemy and bullet have collided.\n          // Mark both as dead\n          e.dead = b.dead = true;\n          // Add an explosion\n          var obj = {x: (e.x + b.x) / 2,\n                     y: (e.y + b.y) / 2,\n                     vx: (e.vx + b.vx) / 2,\n                     vy: (e.vy + b.vy) / 2,\n                     size: e.size + b.size\n                    };\n          var ex = new Explosion(obj);\n          this.explosions.push(ex);\n          // And adjust the score\n          this.score += 100;\n        }\n      }\n    }\n    l = this.enemies.length;\n    for (i = l - 1; i >= 0; i--) {\n      if (this.enemies[i].dead) {\n        this.enemies.splice(i, 1);\n      }\n    }\n    l = this.bullets.length;\n    for (i = l - 1; i >= 0; i--) {\n      if (this.bullets[i].dead) {\n        this.bullets.splice(i, 1);\n      }\n    }\n    \n    // Check for collisions between cannon\n    // and enemies (which ends the game)\n    l = this.enemies.length;\n    for (i = 0; i < l; i++) {\n      e = this.enemies[i];\n      if (e.isOverlap(world.cannon)) {\n        world.gameOver = true;\n      }\n    }\n  };\n\n  this.draw = function() {\n    // Redraw everything\n    c.clearRect(0, 0, w, h);\n    this.cannon.draw();\n    var l = this.bullets.length;\n    for (var i = 0; i < l; i++) {\n      this.bullets[i].draw();\n    }\n    l = this.explosions.length;\n    for (i = 0; i < l; i++) {\n      this.explosions[i].draw();\n    }\n    l = this.enemies.length;\n    for (i = 0; i < l; i++) {\n      this.enemies[i].draw();\n    }\n    // Show the score on the screen\n    c.fillText('Score: ' + this.score, \n               w * 0.8, 20);\n    // If the game is over, display game over\n    // text\n    if (this.gameOver) {\n      c.save();\n      c.font = '48pt sans-serif';\n      c.textAlign = 'center';\n      c.fillStyle = 'red';\n      c.textBaseline = 'middle';\n      c.fillText('GAME OVER', w / 2, h / 2);\n      c.restore();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the world\nvar world = new World();\nworld.init();\n\n// Animation loop\nvar cmTID;\nfunction updateAll() {\n  world.update();\n\n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  if (!world.gameOver) {\n    cmTID = setTimeout(updateAll,\n                       world.timeStep);\n  }\n}\nupdateAll();",
      lessonSection: "Second Game Completed",
    },
    { message: "One of the cool things about writing this and having all the code is you can change the game play, even change it into very different feeling games, with just some small twiddles. Try decreasing the reload time on the cannon so it fires like a machine gun. That feels like a very different game, doesn't it? Much faster paced, more like an action game, especially if you also increase the enemy spawn rate to match the faster cannon reload speed.",
      tutorImage: 2,
    }, 
    { message: "You could also do things like make the enemies bigger, make them bounce much higher, or make them move faster. Or maybe you could make enemies shrink each time you shoot them, only dying when their size goes to zero or less. Or try increasing or decreasing gravity. All of those changes can radically change the game. Come up with your own ideas, try some things, see what you like!",
      tutorImage: 7,
    },
    { message: "Before we move on, let me show you an example of what I mean by how you can make the game play very different by just changing a few things. What I did was twiddle a few things to was make the gun fire faster, the bullets and explosions smaller, made the enemies need multiple hits to die, and made the enemies bigger and faster. Try playing it. It's very different feeling and very fun too!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n// The cannon fits snugly at the bottom left\n// corner of the screen and shoots bullets.\n// The game is over when the cannon is hit\n// by an enemy.\nfunction Cannon() {\n  // Constants\n  this.size = 30;\n  // Position\n  this.x = this.size / 2;\n  this.y = h - this.size / 2;\n  // Initial angle, this tracks the mouse soon\n  this.angle = 45;\n  // How many frames we have to wait to shoot\n  // again, the first number is time in seconds,\n  // so, if it is 0.5, that means a half a \n  // second delay\n  this.reloadDelay = 0.0 * world.frames;\n  \n  this.draw = function() {\n    var x = this.x;\n    var y = this.y;\n    var s = this.size;\n    c.save();\n    // Move to the center of the cannon\n    c.translate(x, y);\n    // The cannon sits on a little stand\n    // half of its height and 10% its width\n    c.strokeRect(-s * 0.1 / 2, 0,\n                 s * 0.1, s / 2);\n    // The cannon itself is two rectangles,\n    // next to each other and rotated\n    // through the angle\n    c.rotate(-this.angle * Math.PI / 180);\n    c.fillRect(-s * 0.4, -s * 0.4 / 2,\n               s * 0.4, s * 0.4);\n    c.fillRect(0, -s * 0.1, s * 0.5, s * 0.2);\n    c.restore();\n  };\n  \n  this.move = function() {\n    // Change angle to match mouse location\n    var diffX = mouse.x - this.x;\n    var diffY = mouse.y - this.y;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    var a = -Math.atan2(diffY, diffX);\n    this.angle = a / Math.PI * 180;\n    \n    // If mouse is down and not reloading, fire\n    if (isMouseDown && !this.reload) {\n      // Create a bullet at the end of the\n      // muzzle\n      a = this.angle / 180 * Math.PI;\n      var x = this.x;\n      x += Math.cos(a) * this.size;\n      var y = this.y;\n      y -= Math.sin(a) * this.size;\n\n      // Muzzle velocity varies based on\n      // distance of the mouse from the\n      // cannon\n      var vStr = 0.05 * (dist + 10);\n      \n      // Distribute the muzzle velocity\n      // across velocity in x and y\n      var vx = Math.cos(a) * vStr;\n      var vy = Math.sin(a) * vStr;\n      \n      // Finally, create a new bullet\n      var bullet = new Bullet(x, y, vx, -vy);\n      world.bullets.push(bullet);\n      \n      // Don't let us shoot again for\n      // a little while\n      this.reload = this.reloadDelay;\n    }\n    if (this.reload) { this.reload--; }\n  };\n}\n\n// Enemies start at a random spot on the \n// right side and move left, either hitting \n// the cannon, going off the left side of the\n// screen, or getting hit by a bullet\nfunction Enemy() {\n  // Size\n  this.r = 10 + 50 * Math.random();\n  this.size = this.r * 2;\n  // Position\n  this.x = w;\n  this.y = h / 2;\n  this.y += (h - this.r) / 2 * Math.random();\n  // Velocity\n  this.vx = -Math.random() * 6 - 1;\n  this.vy = (Math.random() - 0.5) * 35;\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    var bottom = h - this.r;\n    if (this.y > bottom) {\n      // We hit the ground, bounce off\n      // First, compute how far we have left\n      // to move\n      var remain = (this.y - bottom) / this.vy;\n      // Move to the ground\n      this.y = bottom;\n      // Reverse the vertical velocity,\n      // simulating a partially elastic collision\n      this.vy = -Math.abs(this.vy) *\n        world.bounce;\n      // Move off the ground\n      this.y += this.vy * remain;\n    }\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += world.gravity;\n  };\n  \n  this.draw = function() {\n    // Enemies are drawn as a little circle\n    c.beginPath();\n    c.arc(this.x, this.y, this.r,\n          0, Math.PI * 2);\n    c.stroke();\n  };\n  \n  this.isOverlap = function(o2) {\n    // Checks if the enemy overlaps another\n    // object.  Assumes whatever is passed\n    // in is an object with x, y, and size\n    var o1 = this;\n    var dx = o1.x - o2.x;\n    var dy = o1.y - o2.y;\n    var s = (o1.size + o2.size) / 2;\n    var d = Math.sqrt(dx * dx + dy * dy);\n    return (d <= s);\n  };\n  \n  this.shouldDie = function() {\n    return this.x + this.r < 0;\n  };\n}\n\n// The cannon shoots bullets\nfunction Bullet(x, y, vx, vy) {\n  // Position\n  this.x = x;\n  this.y = y;\n  // Velocity\n  this.vx = vx;\n  this.vy = vy;\n  // Constants\n  this.size = 2;\n  this.angle = 0;\n  this.va = 10;  // Angular velocity\n  \n  this.move = function() {\n    // Adjust location by velocities\n    this.x += this.vx;\n    this.y += this.vy;\n    // Spin the bullets\n    this.angle += this.va;\n    // Gravity is an acceleration, so\n    // it changes the velocity, and it points\n    // straight down\n    this.vy += world.gravity;\n  };\n  \n  this.draw = function() {\n    // Bullets are drawn as a little spinning\n    // box\n    var s = this.size;\n    c.save();\n    c.translate(this.x, this.y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.fillRect(-s / 2, -s / 2, s, s);\n    c.restore();\n  };\n  \n  this.shouldDie = function() {\n    return this.y > h;\n  };\n}\n\n// A bullet (and anything the bullet hits) turns\n// into an explosion, which is a shower of\n// particles\nfunction Explosion(source) {\n  this.particles = [];\n  \n  this.init = function(s) {\n    var num = Math.max(10, s.size / 2);\n    for (var i = 0; i < num; i++) {\n      // Start the explosion in the same \n      // spot as the source, and with random\n      // velocities influenced by, but\n      // not dominated by, the source\n      var vx = 2 * s.vx * (Math.random() - 0.2);\n      vx += 3 * (Math.random() - 0.5);\n      var vy = 2 * s.vy * (Math.random() - 0.2);\n      vy += 3 * (Math.random() - 0.5);\n      var p = new Particle(s.x, s.y, vx, vy);\n      this.particles.push(p);\n    }\n  };\n  this.init(source);\n  \n  this.move = function() {\n    var ps = this.particles;\n    // Delete particles that should die\n    for (var i = ps.length - 1; i >= 0; i--) {\n      var p = ps[i];\n      if (p.shouldDie()) {\n        ps.splice(i, 1);\n      }\n    }\n    // Move all remaining particles\n    for (i = 0; i < ps.length; i++) {\n      ps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    var ps = this.particles;\n    // Draw all particles\n    for (var i = 0; i < ps.length; i++) {\n      ps[i].draw();\n    }\n  };\n  \n  this.shouldDie = function() {\n    return this.particles.length <= 0;\n  };\n}\n\n// A particle is just a single point.\nfunction Particle(x, y, vx, vy) {\n  this.x = x;\n  this.y = y;\n  this.vx = vx;\n  this.vy = vy;\n  // The life of a particle in number of frames.\n  // Particles live for a random time (eg. \n  // from 1-3 seconds)\n  this.life = 1 * world.frames;\n  this.life *= Math.random() * 2 + 1;\n  // Air resistance here is specific to particles\n  // since they are light.\n  this.airResist = 0.97;\n  \n  this.move = function() {\n    this.x += this.vx;\n    this.y += this.vy;\n    if (this.y > h) {\n      // We hit the ground, bounce off\n      // First, compute how far we have left\n      // to move\n      var remain = (this.y - h) / this.vy;\n      // Move to the ground\n      this.y = h;\n      // Reverse the vertical velocity,\n      // simulating a partially elastic collision\n      this.vy = -Math.abs(this.vy) *\n        world.bounce;\n      // Reduce the horizontal velocity too\n      this.vx *= world.bounce;\n      // Move off the ground\n      this.y += this.vy * remain;\n    }\n    // Use gravity if we want this to look\n    // like pieces\n    this.vy += world.gravity;\n    // Use airResist if we want this to look\n    // like drifting sparks\n    this.vx *= this.airResist;\n    this.vy *= this.airResist;\n    this.life -= 1;\n  };\n  \n  this.draw = function() {\n    c.fillRect(this.x, this.y, 1, 1);\n  };\n  \n  this.shouldDie = function() {\n    return this.life <= 0;\n  };\n}\n\n\n// The world holds all the state of the game and\n// manages moving and updating everything\nfunction World() {\n  // Constants\n  this.timeStep = 50;  // In milliseconds\n  this.frames = 1000 / this.timeStep;\n  // Elasticity of collisions with the ground.\n  // Setting to 1.0 is fully elastic, 0.0 is\n  // no bounce at all (landing with a thud).\n  this.bounce = 0.8;\n  // Gravity is an acceleration, so it changes\n  // velocity every frame.\n  this.gravity = 0.5;\n  // This is the odds of us spawning a new enemy\n  // in a frame.  The first number is the\n  // likelihood per second, so 0.6 would mean a \n  // roughly 60% chance of a new enemy every\n  // second\n  this.spawnChance = 0.6 / this.frames;\n  this.maxDifficulty = 10;\n  \n  this.init = function() {\n    // World state\n    this.cannon = new Cannon();\n    this.bullets = [];\n    this.explosions = [];\n    this.enemies = [];\n    this.score = 0;\n    this.gameOver = false;\n  };\n\n  this.update = function() {\n    this.spawn();\n    this.move();\n    this.collide();\n    this.draw();\n  };\n\n  this.spawn = function() {\n    // Spawn new enemies\n    var chance = world.spawnChance;\n    // Make the game slowly get harder as the \n    // score gets higher, up to some maximum\n    var difficulty = this.score / 1000 + 1;\n    difficulty = Math.sqrt(difficulty);\n    difficulty = Math.min(difficulty,\n                          this.maxDifficulty);\n    chance *= difficulty; \n    // Don't spawn new enemies as much if there\n    // are already enemies out there, that\n    // makes the game not fun since you can't\n    // reload fast enough to have any ability\n    // to win\n    chance /= this.enemies.length + 1;\n    if (Math.random() < chance) {\n        this.enemies.push(new Enemy());\n    }\n  };\n\n  this.move = function() {\n    // Move everything\n    this.cannon.move();\n    var l = this.bullets.length;\n    for (var i = l - 1; i >= 0; i--) {\n      var b = this.bullets[i];\n      if (b.shouldDie()) {\n        // The bullet has hit the ground or\n        // exploded or otherwise needs to die.\n        // Add an explosion\n        var e = new Explosion(b);\n        this.explosions.push(e);\n        // Delete the bullet\n        this.bullets.splice(i, 1);\n      } else {\n        b.move();\n      }\n    }\n    l = this.explosions.length;\n    for (i = l - 1; i >= 0; i--) {\n      var ex = this.explosions[i];\n      if (ex.shouldDie()) {\n        this.explosions.splice(i, 1);\n      } else {\n        ex.move();\n      }\n    }\n    l = this.enemies.length;\n    for (i = l - 1; i >= 0; i--) {\n      var em = this.enemies[i];\n      if (em.shouldDie()) {\n        this.enemies.splice(i, 1);\n      } else {\n        em.move();\n      }\n    }\n  };\n\n  this.collide = function() {\n    // Our collision detection is a little \n    // simple, it just checks if two objects\n    // overlap, leaving open the possiblity that\n    // fast moving objects will actually move\n    // through each other in one frame. Oh well.\n\n    // Check for collisions between bullets\n    // and enemies\n    var e;\n    var l = this.enemies.length;\n    for (var i = 0; i < l; i++) {\n      e = this.enemies[i];\n      var l2 = this.bullets.length;\n      for (var j = 0; j < l2; j++) {\n        var b = this.bullets[j];\n        if (e.dead || b.dead) { continue; }\n        if (e.isOverlap(b)) {\n          // An enemy and bullet have collided.\n          // Mark both as dead\n          b.dead = true;\n          e.size -= 5;\n          e.r = e.size / 2;\n          e.vx *= 0.9;\n          if (e.size <= 10) {\n            e.dead = true;\n          }\n          // Add an explosion\n          var obj = {x: (e.x + b.x) / 2,\n                     y: (e.y + b.y) / 2,\n                     vx: (e.vx + b.vx) / 2,\n                     vy: (e.vy + b.vy) / 2,\n                     size: e.size + b.size\n                    };\n          var ex = new Explosion(obj);\n          this.explosions.push(ex);\n          // And adjust the score\n          this.score += 100;\n        }\n      }\n    }\n    l = this.enemies.length;\n    for (i = l - 1; i >= 0; i--) {\n      if (this.enemies[i].dead) {\n        this.enemies.splice(i, 1);\n      }\n    }\n    l = this.bullets.length;\n    for (i = l - 1; i >= 0; i--) {\n      if (this.bullets[i].dead) {\n        this.bullets.splice(i, 1);\n      }\n    }\n    \n    // Check for collisions between cannon\n    // and enemies (which ends the game)\n    l = this.enemies.length;\n    for (i = 0; i < l; i++) {\n      e = this.enemies[i];\n      if (e.isOverlap(world.cannon)) {\n        world.gameOver = true;\n      }\n    }\n  };\n\n  this.draw = function() {\n    // Redraw everything\n    c.clearRect(0, 0, w, h);\n    this.cannon.draw();\n    var l = this.bullets.length;\n    for (var i = 0; i < l; i++) {\n      this.bullets[i].draw();\n    }\n    l = this.explosions.length;\n    for (i = 0; i < l; i++) {\n      this.explosions[i].draw();\n    }\n    l = this.enemies.length;\n    for (i = 0; i < l; i++) {\n      this.enemies[i].draw();\n    }\n    // Show the score on the screen\n    c.fillText('Score: ' + this.score, \n               w * 0.8, 20);\n    // If the game is over, display game over\n    // text\n    if (this.gameOver) {\n      c.save();\n      c.font = '48pt sans-serif';\n      c.textAlign = 'center';\n      c.fillStyle = 'red';\n      c.textBaseline = 'middle';\n      c.fillText('GAME OVER', w / 2, h / 2);\n      c.restore();\n    }\n  };\n}\n\n// Keep track of whether the mouse is pressed\nvar isMouseDown = false;\nc.canvas.onmousedown = \n  function(evt) { isMouseDown = true; };\nc.canvas.onmouseup = \n  function(evt) { isMouseDown = false; };\n\n// Keep track of where the mouse is\nvar mouse = {x: 0, y: 0};\nc.canvas.onmousemove = \n  function(evt) {\n    mouse.x = evt.clientX;\n    mouse.y = evt.clientY;\n  };\n\n// Create the world\nvar world = new World();\nworld.init();\n\n// Animation loop\nvar cmTID;\nfunction updateAll() {\n  world.update();\n\n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  if (!world.gameOver) {\n    cmTID = setTimeout(updateAll,\n                       world.timeStep);\n  }\n}\nupdateAll();",
      tutorImage: 5,
    },
    { message: "Last chance to mess with the cannon game before we move on.  Are you sure there isn't anything else you want to try? Twiddle more things, see what you can do! Mess around with it!",
      tutorImage: 1,
    },
    { message: "Okay, let's start on the third and last game. It's going to be a platformer. Think of games like Mario Bros, that's what we're trying to do.",
      code: "// No way! I get to do a third game?",
      lessonSection: "Third Game",
      tutorImage: 3,
    },
    { message: "This game is totally different than the other two. It's going to require bending your brain a bit to code. The player mostly stays still in games like this, instead the background moves, making it look like the player is moving.",
      code: "// My brain bends? Are you sure?",
      tutorImage: 4,
    },
    { message: "The game we are going to code will be a simplified infinite platformer where the levels are generated on-the-fly and the game gets harder and harder the further you go. The player will jump around from ledge to ledge. There will be rewards that increase your score and give you health and enemies that damage you if you touch them.  Ready to start?",
      code: "// Rewards and enemies and steps, oh my!",
      tutorImage: 6,
    },
    { message: "Let's start with nothing again, see if you can write a Player object. A Player object should have a size, position (so x and y), and draw() and move() methods so it can draw and move itself. For now, just set x and y to whatever (like 100), make move() do nothing, and make draw() draw a circle (circles can be drawn with c.arc(x, y, r, startAngle, endAngle), so use c.arc(this.x, this.y, this.size / 2, 0, 2 * Math.PI) and you'll also need c.beginPath() before and c.stroke() after). Then create a Player object and tell it to draw itself.",
      code: "",
      lessonSection: "Coding from Nothing Again",
      tutorImage: 1,
    },
    { message: "Did you get it? You really should be able to write your own objects from scratch at this point.  If c.arc() to draw the player as a circle is causing you problems, try hardcoding it (just throw numbers in) or doing some Google searches (like for [arc canvas javascript]) to see if you can figure out how to get it to work.  But, really, if you haven't done it yet, please code a Player object before moving on.",
      tutorImage: 6,
    },
    { message: "Now the player needs to move. The player needs to be able to move left, right, and jump. We could do all that with the mouse (move left and right if the mouse is to the left or right, jump if the mouse button is pressed), but that can be awkward to control, and normally this kind of game uses the arrow keys or WASD keys on the keyboard. So we're going to use the keyboard.",
      lessonSection: "Keyboard Events",
      tutorImage: 1,
    },
    { message: "Let's start with jumping. We want the player to sit at the bottom of the screen and then jump whenever the 'w' kay or up arrow key is pressed.  That's done using the onkeydown event on the window or canvas.  Look at the code for onkeydown(), then go to the move() method for Player and follow the comments there to write the code to make the player jump!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n\n// Track keyboard events on the canvas.\n// The canvas doesn't normally respond to\n// keyboard events, but it will if we make\n// the content editable (or set the tabIndex)\n// You will have to mouse click on the canvas\n// to get it to start seeing the up arrow or w\n// key presses.\nc.canvas.contentEditable = true;\nc.canvas.onkeydown = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // keyCode for up arrow or 'w' means jump\n    player.jump = true;\n    // We got this, don't let anyone else\n    // see the up arrow, it was for us\n    evt.preventDefault();\n  }\n};\nc.canvas.onkeyup = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // keyCode for up arrow or 'w' means jump\n    player.jump = false;\n    // We got this, don't let anyone else\n    // see the up arrow, it was for us\n    evt.preventDefault();\n  }\n};\n\nfunction Player() {\n  // Constants\n  this.r = 10;\n  this.size = this.r * 2;\n  this.x = w * 0.2;\n  this.jumpSpeed = 8;\n  this.gravity = -0.6;\n  this.bounce = 0.2;\n  // Position\n  // Only the height is variable, x is\n  // constant.  The height is the height of\n  // the center off the bottom (so, the center\n  // of the player is at h - r - y in screen\n  // coordinates)\n  this.y = 0;\n  this.vy = 0;\n  \n  this.move = function() {\n    // I NEED CODE! WRITE ME!\n    // You need to write the move() method\n    // to make the player jump.\n    // To start, if a jump as been requested\n    // (so, player.jump is true), then\n    // you need to set the velocity at the\n    // speed of a jump (set this.vy to\n    // this.jumpSpeed, it's an instant\n    // acceleration).\n    // After that, you should apply physics,\n    // so increment this.y by the velocity\n    // (this.vy) and then increment the\n    // velocity by gravity (this.gravity).\n    // Finally, you should bounce off the floor.\n    // The floor is at 0 the way we are doing\n    // the y coordinates this time, so\n    // if this.y is less than 0, set it to 0,\n    // then set this.vy to its negative,\n    // then multiply this.vy by this.bounce\n    // to simulate a partially elastic collision.\n    // Got it? Okay, code those below!\n    \n  };\n    \n  this.draw = function() {\n    // The player is a simple circle\n    c.beginPath();\n    c.arc(this.x, h - this.y - this.r, this.r,\n          0, 2 * Math.PI);\n    c.stroke();\n  };\n}\n\n\nvar player = new Player();\n\n// Animation loop\nvar cmTID;\nvar timeStep = 50;  // milliseconds\nvar frameRate = 1000 / timeStep;\nfunction updateAll() {\n  // Move everything\n  player.move();\n  // Redraw everything\n  c.clearRect(0, 0, w, h);\n  player.draw();\n  \n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);\n}\nupdateAll();",
      tutorImage: 3,
    },
    { message: "Did you get it to work? After you finish writing your code for move(), you'll need to click on the canvas window (the game window) before the arrow key press events will be sent to the canvas. The canvas needs to be selected to take the arrow key events (otherwise, the arrow keys might be for the code window, so you'll just move around in the code when you press the arrow keys).",
      tutorImage: 1,
    },
    { message: "You probably noticed that you can jump in mid-air. We probably shouldn't allow that. Can you fix that? Here's a hint, even if a jump has been requested, we shouldn't jump unless the player is close to the bottom (so, if this.y is near zero, like less than, say, 5 or so). Can you figure out how to make it so the player can only jump when near the ground?",
      tutorImage: 4,
    },
    { message: "Okay, let's work on the next thing, steps for the player to jump up to and move on.  Later, these steps will have enemies and rewards on them too.  We'll start by just trying to draw a step. I created a Step object for you, but the draw() method is empty. Look for the comments in there for how the Step object is going to work and what you need to do.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Step(index, height) {\n  // index is like the x coordinate for\n  // steps. The first step, at index 0, would\n  // be drawn from 0 to width in x.  The\n  // second step, at index 1, would be from\n  // x to 2x. Index 2 would be 2x to 3x, and\n  // so on.\n  this.index = index;\n  // height is how high off the ground this\n  // step is. On the ground is height 0.\n  // the first step off the ground will have\n  // a height of 1 and be drawn this.stepDiff\n  // pixels off the bottom (so at h - \n  // this.stepDiff). Height 2 will be 2 *\n  // this.stepDiff off the bottom, and so on.\n  this.height = height;\n  // Constants\n  this.width = w / 5;\n  this.stepDiff = 40;\n  \n  \n  this.draw = function() {\n    // WRITE ME!\n    // This should draw a horizontal line for\n    // the step at the right spot. Read the\n    // comments above for where that spot\n    // is.  I wrote a this.drawLine() method\n    // which you can use if you want to.\n    // Write your code below. When you get\n    // it, a step should appear above and to\n    // the right of the player.\n    \n  };\n  \n  this.drawLine = function(x, y, x2, y2) {\n    // Draws a line from (x,y) to (x2, y2)\n    c.beginPath();\n    c.moveTo(x, y);\n    c.lineTo(x2, y2);\n    c.stroke();\n  };\n}\n\nfunction Player() {\n  // Constants\n  this.r = 10;\n  this.size = this.r * 2;\n  this.x = w * 0.2;\n  this.jumpSpeed = 8;\n  this.gravity = -0.6;\n  this.bounce = 0.2;\n  // Position\n  // Only the height is variable, x is\n  // constant.  The height is the height of\n  // the center off the bottom (so, the center\n  // of the player is at h - r - y in screen\n  // coordinates)\n  this.y = 0;\n  this.vy = 0;\n  \n  this.move = function() {\n    // Was a jump requested? Can we jump?\n    if (this.jump && this.canJump()) {\n      // Jump!\n      this.vy = this.jumpSpeed;\n    }\n    this.y += this.vy;\n    this.vy += this.gravity;\n    if (this.y < 0) {\n      // Bounce off the floor\n      // Later, this should bounce off \n      // any surface\n      this.y = 0;\n      this.vy = this.bounce * -this.vy;\n    }\n  };\n  \n  this.canJump = function() {\n    // This should check to make sure we are\n    // on top of a solid surface we can jump\n    // off of\n    return (this.y < 5);\n  };\n    \n  this.draw = function() {\n    // The player is a simple circle\n    c.beginPath();\n    c.arc(this.x, h - this.y - this.r, this.r,\n          0, 2 * Math.PI);\n    c.stroke();\n  };\n}\n\n// Track keyboard events on the canvas.\n// The canvas doesn't normally respond to\n// keyboard events, but it will if we make\n// the content editable (or set the tabIndex)\nc.canvas.contentEditable = true;\nc.canvas.onkeydown = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = true;\n    evt.preventDefault();\n  }\n};\nc.canvas.onkeyup = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = false;\n    evt.preventDefault();\n  }\n};\n\n\n\nvar player = new Player();\nvar steps = [new Step(2, 1)];\n\n// Animation loop\nvar cmTID;\nvar timeStep = 50;  // milliseconds\nvar frameRate = 1000 / timeStep;\nfunction updateAll() {\n  // Move everything\n  player.move();\n  // Redraw everything\n  c.clearRect(0, 0, w, h);\n  player.draw();\n  for (var i = 0; i < steps.length; i++) {\n    steps[i].draw();\n  }\n  \n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);\n}\nupdateAll();",
      tutorImage: 1,
    },
    { message: "Now we have enough to see how the player will move left and right. When the player moves, it will make everything else move left or right, but the player stays still. Another way of thinking of this is that the camera is moving left or right along with the player, so the background is always what is moving.",
      tutorImage: 6,
    },
    { message: "I've added code to detect left and right arrows (or 'a' and 'd' keys) and set player.left or player.right when the player should move left or right. I've also added player.p for the player's position, which should be increased when the player moves right and decreased when the player moves left. Finally, everything else, which is just Step objects for now, should subtract player.p from where it thinks the x coordinate is of where it should be drawn to drawn so that it is drawn in the right space. Can you do all that yourself? No comments this time, you have to find the right way to do it.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Step(index, height) {\n  // index is like the x coordinate for\n  // steps. The first step, at index 0, would\n  // be drawn from 0 to width in x.  The\n  // second step, at index 1, would be from\n  // x to 2x. Index 2 would be 2x to 3x, and\n  // so on.\n  this.index = index;\n  // height is how high off the ground this\n  // step is. On the ground is height 0.\n  // the first step off the ground will have\n  // a height of 1 and be drawn this.stepDiff\n  // pixels off the bottom (so at h - \n  // this.stepDiff). Height 2 will be 2 *\n  // this.stepDiff off the bottom, and so on.\n  this.height = height;\n  // Constants\n  this.width = w / 5;\n  this.stepDiff = 40;\n  \n  \n  this.draw = function() {\n    var x = this.index * this.width;\n    var y = h - this.height * this.stepDiff;\n    this.drawLine(x, y, x + this.width, y);    \n  };\n  \n  this.drawLine = function(x, y, x2, y2) {\n    // Draws a line from (x,y) to (x2, y2)\n    c.beginPath();\n    c.moveTo(x, y);\n    c.lineTo(x2, y2);\n    c.stroke();\n  };\n}\n\nfunction Player() {\n  // Constants\n  this.r = 10;\n  this.size = this.r * 2;\n  this.x = w * 0.2;\n  this.jumpSpeed = 8;\n  this.gravity = -0.6;\n  this.bounce = 0.2;\n  // Position\n  // Only the height is variable, x is\n  // constant.  The height is the height of\n  // the center off the bottom (so, the center\n  // of the player is at h - r - y in screen\n  // coordinates)\n  this.y = 0;\n  this.vy = 0;\n  // p is the location of the player in the\n  // world after moving left or right.\n  // The player is always drawn at x, but\n  // the rest of the world, all other objects,\n  // should use player.p to adjust where they\n  // are drawn.\n  this.p = 0;\n  \n  this.move = function() {\n    // Was a jump requested? Can we jump?\n    if (this.jump && this.canJump()) {\n      // Jump!\n      this.vy = this.jumpSpeed;\n    }\n    this.y += this.vy;\n    this.vy += this.gravity;\n    if (this.y < 0) {\n      // Bounce off the floor\n      // Later, this should bounce off \n      // any surface\n      this.y = 0;\n      this.vy = this.bounce * -this.vy;\n    }\n  };\n  \n  this.canJump = function() {\n    // This should check to make sure we are\n    // on top of a solid surface we can jump\n    // off of\n    return (this.y < 5);\n  };\n    \n  this.draw = function() {\n    // The player is a simple circle\n    c.beginPath();\n    c.arc(this.x, h - this.y - this.r, this.r,\n          0, 2 * Math.PI);\n    c.stroke();\n  };\n}\n\n// Track keyboard events on the canvas.\n// The canvas doesn't normally respond to\n// keyboard events, but it will if we make\n// the content editable (or set the tabIndex)\nc.canvas.contentEditable = true;\nc.canvas.onkeydown = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = true;    \n    evt.preventDefault();  \n  }\n};\nc.canvas.onkeyup = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = false;    \n    evt.preventDefault();  \n  }\n};\n\n\n\nvar player = new Player();\nvar steps = [new Step(2, 1)];\n\n// Animation loop\nvar cmTID;\nvar timeStep = 50;  // milliseconds\nvar frameRate = 1000 / timeStep;\nfunction updateAll() {\n  // Move everything\n  player.move();\n  // Redraw everything\n  c.clearRect(0, 0, w, h);\n  player.draw();\n  for (var i = 0; i < steps.length; i++) {\n    steps[i].draw();\n  }\n  \n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);\n}\nupdateAll();",
      tutorImage: 3,
    },
    { message: "Here is an example with a few steps so you can get a feel for it. Make sure to click on the canvas, then try using the arrow keys to move and jump. See how everything else moving creates the illusion that you are moving? You might notice I smoothed the movement a little too, which has a nice effect. Yeah, I know, you go through the steps right now, there's only four steps, and we'll need enemies, rewards, and a score. There's a lot more code to write. But it's starting feel a little like a game!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\nfunction Step(index, height) {\n  // index is like the x coordinate for\n  // steps. The first step, at index 0, would\n  // be drawn from 0 to width in x.  The\n  // second step, at index 1, would be from\n  // x to 2x. Index 2 would be 2x to 3x, and\n  // so on.\n  this.index = index;\n  // height is how high off the ground this\n  // step is. On the ground is height 0.\n  // the first step off the ground will have\n  // a height of 1 and be drawn this.stepDiff\n  // pixels off the bottom (so at h - \n  // this.stepDiff). Height 2 will be 2 *\n  // this.stepDiff off the bottom, and so on.\n  this.height = height;\n  // Constants\n  this.width = w / 5;\n  this.stepDiff = 40;\n  \n  \n  this.draw = function() {\n    var x = this.index * this.width;\n    x -= player.p;\n    var y = h - this.height * this.stepDiff;\n    this.drawLine(x, y, x + this.width, y);    \n  };\n  \n  this.drawLine = function(x, y, x2, y2) {\n    // Draws a line from (x,y) to (x2, y2)\n    c.beginPath();\n    c.moveTo(x, y);\n    c.lineTo(x2, y2);\n    c.stroke();\n  };\n}\n\nfunction Player() {\n  // Constants\n  this.r = 10;\n  this.size = this.r * 2;\n  this.x = w * 0.2;\n  this.jumpSpeed = 8;\n  this.moveSpeed = 2;\n  this.maxMove = 8;\n  this.gravity = -0.6;\n  this.bounce = 0.2;\n  this.friction = 0.8;\n  // Position\n  // Only the height is variable, x is\n  // constant.  The height is the height of\n  // the center off the bottom (so, the center\n  // of the player is at h - r - y in screen\n  // coordinates)\n  this.y = 0;\n  this.vy = 0;\n  // p is the location of the player in the\n  // world after moving left or right.\n  // The player is always drawn at x, but\n  // the rest of the world, all other objects,\n  // should use player.p to adjust where they\n  // are drawn.\n  this.p = 0;\n  // vp is the velocity of the player (change\n  // in p)\n  this.vp = 0;\n  \n  this.move = function() {\n    // Was a jump requested? Can we jump?\n    if (this.jump && this.canJump()) {\n      // Jump!\n      this.vy = this.jumpSpeed;\n    }\n    if (this.right) {\n      this.vp += this.moveSpeed;\n      this.vp = Math.min(this.maxMove,\n                         this.vp);\n    }\n    if (this.left) {\n      this.vp -= this.moveSpeed;\n      this.vp = Math.max(-this.maxMove,\n                          this.vp);\n    }\n    this.y += this.vy;\n    this.vy += this.gravity;\n    this.p += this.vp;\n    this.vp *= this.friction;\n    if (this.y < 0) {\n      // Bounce off the floor\n      // Later, this should bounce off \n      // any surface\n      this.y = 0;\n      this.vy = this.bounce * -this.vy;\n    }\n  };\n  \n  this.canJump = function() {\n    // This should check to make sure we are\n    // on top of a solid surface we can jump\n    // off of\n    return (this.y < 5);\n  };\n    \n  this.draw = function() {\n    // The player is a simple circle\n    c.beginPath();\n    c.arc(this.x, h - this.y - this.r, this.r,\n          0, 2 * Math.PI);\n    c.stroke();\n  };\n}\n\n// Track keyboard events on the canvas.\n// The canvas doesn't normally respond to\n// keyboard events, but it will if we make\n// the content editable (or set the tabIndex)\nc.canvas.contentEditable = true;\nc.canvas.onkeydown = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = true;    \n    evt.preventDefault();  \n  }\n};\nc.canvas.onkeyup = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = false;    \n    evt.preventDefault();  \n  }\n};\n\n\n\nvar player = new Player();\nvar steps = [];\nfor (var i = 1; i < 5; i++) {\n  steps.push(new Step(i + 1, i));\n}\n  \n// Animation loop\nvar cmTID;\nvar timeStep = 50;  // milliseconds\nvar frameRate = 1000 / timeStep;\nfunction updateAll() {\n  // Move everything\n  player.move();\n  // Redraw everything\n  c.clearRect(0, 0, w, h);\n  player.draw();\n  for (var i = 0; i < steps.length; i++) {\n    steps[i].draw();\n  }\n  \n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);\n}\nupdateAll();",
      lessonSection: "Moving Everything But Me",
      tutorImage: 5,
    },
    { message: "Look, infinite steps! There are a couple new things here, so read the Steps object carefully. Each step is in an <i>ordered list</i> where each step should be above or to the right of the previous step. addNeeded() creates steps on demand by checking if it has enough steps and, if it doesn't, it adds one at the bottom and then randomly may add one above, at, or below the previous step. Finally, it does <i>tail recursion</i> where it calls itself to check if it now has enough steps. See how it works?",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n\nfunction Steps() {\n  // Steps should be a unique ordered list,\n  // sorted by index, subsorted by height. So, \n  // if the last step in the list is\n  // at index 5 and height 3, the next step\n  // added has to be at least index 5 and \n  // height 4 (but could also be index 6\n  // and height 0, or anything else above index\n  // 5 and height 3)\n  this.steps = [];\n  // Likelihood of a step being added at each\n  // opportunity to add a step\n  this.stepChance = 0.5;\n\n  this.addNeeded = function() {\n    var len = this.steps.length;\n    var lastStep = this.steps[len - 1];\n    var maxIndex = lastStep.index;\n    var prevHeight = lastStep.height;\n    \n    // Given the last step, figure out\n    // how high maxIndex should be\n    var minNeeded = (w + player.p) /\n                    lastStep.width;\n    minNeeded = Math.ceil(minNeeded) - 1;\n    if (maxIndex < minNeeded) {\n      var newIndex = maxIndex + 1;\n      // Every index has a step at 0 (bottom)\n      this.steps.push(new Step(newIndex, 0));\n      // Find the ceiling\n      var maxHeight = h / lastStep.stepDiff;\n      maxHeight = Math.floor(maxHeight) - 1;\n      // Randomly add a step above the bottom\n      for (var i = 1; i >= -1; i--) {\n        if (i + prevHeight > 0 &&\n            i + prevHeight < maxHeight &&\n            Math.random() < this.stepChance) {\n          // Create a new step at this height\n          this.steps.push(new Step(newIndex,\n                              i + prevHeight));\n          // Once we create a step, stop\n          // creating any more at this index\n          // (there will be at most two steps\n          // per index)\n          break;\n        }\n      }\n      // Call ourselves again to add any more\n      // steps that are still needed\n      this.addNeeded();\n    }\n  };\n\n  this.init = function() {\n    // Start with a step just at ground level\n    this.steps.push(new Step(0, 0));\n    // Automatically add any more needed steps\n    this.addNeeded();\n  };\n  this.init();\n  \n  this.move = function() {\n    for (var i = 0; i < this.steps.length; i++) {\n      this.steps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    for (var i = 0; i < this.steps.length; i++) {\n      this.steps[i].draw();\n    }\n  };\n}\n\nfunction Step(index, height) {\n  // index is like the x coordinate for\n  // steps. The first step, at index 0, would\n  // be drawn from 0 to width in x.  The\n  // second step, at index 1, would be from\n  // x to 2x. Index 2 would be 2x to 3x, and\n  // so on.\n  this.index = index;\n  // height is how high off the ground this\n  // step is. On the ground is height 0.\n  // the first step off the ground will have\n  // a height of 1 and be drawn this.stepDiff\n  // pixels off the bottom (so at h - \n  // this.stepDiff). Height 2 will be 2 *\n  // this.stepDiff off the bottom, and so on.\n  this.height = height;\n  // Constants\n  this.width = w / 5;\n  this.stepDiff = 40;\n  \n  this.move = function() {\n    // Nothing to do here yet, later, when\n    // we have enemies to move, there\n    // will be\n  };\n  \n  this.draw = function() {\n    var x = this.index * this.width;\n    x -= player.p;\n    var y = h - this.height * this.stepDiff;\n    this.drawLine(x, y, x + this.width, y);    \n  };\n  \n  this.drawLine = function(x, y, x2, y2) {\n    // Draws a line from (x,y) to (x2, y2)\n    c.beginPath();\n    c.moveTo(x, y);\n    c.lineTo(x2, y2);\n    c.stroke();\n  };\n}\n\nfunction Player() {\n  // Constants\n  this.r = 10;\n  this.size = this.r * 2;\n  this.x = w * 0.2;\n  this.jumpSpeed = 8;\n  this.moveSpeed = 2;\n  this.maxMove = 8;\n  this.gravity = -0.6;\n  this.bounce = 0.2;\n  this.friction = 0.8;\n  // Position\n  // Only the height is variable, x is\n  // constant.  The height is the height of\n  // the center off the bottom (so, the center\n  // of the player is at h - r - y in screen\n  // coordinates)\n  this.y = 0;\n  this.vy = 0;\n  // p is the location of the player in the\n  // world after moving left or right.\n  // The player is always drawn at x, but\n  // the rest of the world, all other objects,\n  // should use player.p to adjust where they\n  // are drawn.\n  this.p = 0;\n  // vp is the velocity of the player (change\n  // in p)\n  this.vp = 0;\n  \n  this.move = function() {\n    // Was a jump requested? Can we jump?\n    if (this.jump && this.canJump()) {\n      // Jump!\n      this.vy = this.jumpSpeed;\n    }\n    if (this.right) {\n      this.vp += this.moveSpeed;\n      this.vp = Math.min(this.maxMove,\n                         this.vp);\n    }\n    if (this.left) {\n      this.vp -= this.moveSpeed;\n      this.vp = Math.max(-this.maxMove,\n                          this.vp);\n    }\n    this.y += this.vy;\n    this.vy += this.gravity;\n    this.p += this.vp;\n    this.vp *= this.friction;\n    if (this.y < 0) {\n      // Bounce off the floor\n      // Later, this should bounce off \n      // any surface\n      this.y = 0;\n      this.vy = this.bounce * -this.vy;\n    }\n  };\n  \n  this.canJump = function() {\n    // This should check to make sure we are\n    // on top of a solid surface we can jump\n    // off of\n    return (this.y < 5);\n  };\n    \n  this.draw = function() {\n    // The player is a simple circle\n    c.beginPath();\n    c.arc(this.x, h - this.y - this.r, this.r,\n          0, 2 * Math.PI);\n    c.stroke();\n  };\n}\n\n// Track keyboard events on the canvas.\n// The canvas doesn't normally respond to\n// keyboard events, but it will if we make\n// the content editable (or set the tabIndex)\nc.canvas.contentEditable = true;\nc.canvas.onkeydown = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = true;    \n    evt.preventDefault();  \n  }\n};\nc.canvas.onkeyup = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = false;    \n    evt.preventDefault();  \n  }\n};\n\n\nvar player = new Player();\nvar steps = new Steps();\n  \n// Animation loop\nvar cmTID;\nvar timeStep = 50;  // milliseconds\nvar frameRate = 1000 / timeStep;\nfunction updateAll() {\n  // Move everything\n  player.move();\n  steps.move();\n  steps.addNeeded();\n  // Redraw everything\n  c.clearRect(0, 0, w, h);\n  player.draw();\n  steps.draw();\n  \n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);\n}\nupdateAll();",
      lessonSection: "Infinite Level Design",
      tutorImage: 1,
    },
    { message: "We're still not able to stand on a step yet. That's got to be fixed.",
      lessonSection: "Standing on Stuff",
      tutorImage: 6,
    },
    { message: "There are a few ways to do this, but the easiest is just to check every step to see if it is below the player. I've written that for you, but, play it a bit, and you'll see there's a problem. You can go through steps from the bottom! I've already written the code to check if a player is right below a step. All you have to do is use it. Read the code in Steps, Step, and Player about checking for collisions with steps, then make it so the player hits the ceiling when jumping at a step from below.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n\nfunction Steps() {\n  // Steps should be a unique ordered list,\n  // sorted by index, subsorted by height. So, \n  // if the last step in the list is\n  // at index 5 and height 3, the next step\n  // added has to be at least index 5 and \n  // height 4 (but could also be index 6\n  // and height 0, or anything else above index\n  // 5 and height 3)\n  this.steps = [];\n  // Likelihood of a step being added at each\n  // opportunity to add a step\n  this.stepChance = 0.5;\n\n  this.addNeeded = function() {\n    var len = this.steps.length;\n    var lastStep = this.steps[len - 1];\n    var maxIndex = lastStep.index;\n    var prevHeight = lastStep.height;\n    \n    // Given the last step, figure out\n    // how high maxIndex should be\n    var minNeeded = (w + player.p) /\n                    lastStep.width;\n    minNeeded = Math.ceil(minNeeded) - 1;\n    if (maxIndex < minNeeded) {\n      var newIndex = maxIndex + 1;\n      // Every index has a step at 0 (bottom)\n      this.steps.push(new Step(newIndex, 0));\n      // Find the ceiling\n      var maxHeight = h / lastStep.stepDiff;\n      maxHeight = Math.floor(maxHeight) - 1;\n      // Randomly add a step above the bottom\n      for (var i = 1; i >= -1; i--) {\n        if (i + prevHeight > 0 &&\n            i + prevHeight < maxHeight &&\n            Math.random() < this.stepChance) {\n          // Create a new step at this height\n          this.steps.push(new Step(newIndex,\n                              i + prevHeight));\n          // Once we create a step, stop\n          // creating any more at this index\n          // (there will be at most two steps\n          // per index)\n          break;\n        }\n      }\n      // Call ourselves again to add any more\n      // steps that are still needed\n      this.addNeeded();\n    }\n  };\n\n  this.init = function() {\n    // Start with a step just at ground level\n    this.steps.push(new Step(0, 0));\n    // Automatically add any more needed steps\n    this.addNeeded();\n  };\n  this.init();\n  \n  this.playerIsOnAnyStep = function(tolerance) {\n    tolerance = tolerance || 1;\n    for (var i = 0; i < this.steps.length; i++) {\n      if (this.steps[i].playerIsOn(tolerance)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  this.playerIsBelowAnyStep = \n    function(tolerance) {\n    tolerance = tolerance || 2;\n    for (var i = 0; i < this.steps.length; i++) {\n      var s = this.steps[i];\n      if (s.playerIsBelow(tolerance)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  this.move = function() {\n    for (var i = 0; i < this.steps.length; i++) {\n      this.steps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    for (var i = 0; i < this.steps.length; i++) {\n      this.steps[i].draw();\n    }\n  };\n}\n\nfunction Step(index, height) {\n  // index is like the x coordinate for\n  // steps. The first step, at index 0, would\n  // be drawn from 0 to width in x.  The\n  // second step, at index 1, would be from\n  // x to 2x. Index 2 would be 2x to 3x, and\n  // so on.\n  this.index = index;\n  // height is how high off the ground this\n  // step is. On the ground is height 0.\n  // the first step off the ground will have\n  // a height of 1 and be drawn this.stepDiff\n  // pixels off the bottom (so at h - \n  // this.stepDiff). Height 2 will be 2 *\n  // this.stepDiff off the bottom, and so on.\n  this.height = height;\n  // Constants\n  this.width = w / 5;\n  this.stepDiff = 40;\n  \n  this.playerIsOn = function(tolerance) {\n    tolerance = tolerance || 1;\n    // Returns true if the player is on this\n    // step\n    \n    // First check if the player is anywhere\n    // near this step\n    var x = this.index * this.width;\n    if (player.p + player.x + player.r < x) {\n      // Player is way to the left\n      return false;\n    }\n    if (player.p + player.x - player.r >\n        x + this.width) {\n      // Player is way to the right\n      return false;\n    }\n    var y = this.height * this.stepDiff;\n    var diffY = player.y - y;\n    return (diffY >= 0 && diffY <= tolerance);\n  };\n\n  this.playerIsBelow = function(tolerance) {\n    tolerance = tolerance || 2;\n    // Returns true if the player is immediately\n    // below this step\n    \n    // First check if the player is anywhere\n    // near this step\n    var x = this.index * this.width;\n    if (player.p + player.x + player.r < x) {\n      // Player is way to the left\n      return false;\n    }\n    if (player.p + player.x - player.r >\n        x + this.width) {\n      // Player is way to the right\n      return false;\n    }\n    var y = this.height * this.stepDiff;\n    var diffY = y - (player.y + player.size);\n    return (diffY >= 0 && diffY <= tolerance);\n  };\n\n  this.move = function() {\n    // Nothing to do here yet, later, when\n    // we have enemies to move, there\n    // will be\n  };\n  \n  this.draw = function() {\n    var x = this.index * this.width;\n    x -= player.p;\n    var y = h - this.height * this.stepDiff;\n    this.drawLine(x, y, x + this.width, y);    \n  };\n  \n  this.drawLine = function(x, y, x2, y2) {\n    // Draws a line from (x,y) to (x2, y2)\n    c.beginPath();\n    c.moveTo(x, y);\n    c.lineTo(x2, y2);\n    c.stroke();\n  };\n}\n\nfunction Player() {\n  // Constants\n  this.r = 10;\n  this.size = this.r * 2;\n  this.x = w * 0.2;\n  this.jumpSpeed = 8;\n  this.moveSpeed = 2;\n  this.maxMove = 8;\n  this.gravity = -0.6;\n  this.bounce = 0.2;\n  this.friction = 0.8;\n  // Position\n  // Only the height is variable, x is\n  // constant.  The height is the height of\n  // the center off the bottom (so, the center\n  // of the player is at h - r - y in screen\n  // coordinates)\n  this.y = 0;\n  this.vy = 0;\n  // p is the location of the player in the\n  // world after moving left or right.\n  // The player is always drawn at x, but\n  // the rest of the world, all other objects,\n  // should use player.p to adjust where they\n  // are drawn.\n  this.p = 0;\n  // vp is the velocity of the player (change\n  // in p)\n  this.vp = 0;\n  \n  this.move = function() {\n    // Was a jump requested? Can we jump?\n    if (this.jump && this.canJump()) {\n      // Jump!\n      this.vy = this.jumpSpeed;\n    }\n    if (this.right) {\n      this.vp += this.moveSpeed;\n      this.vp = Math.min(this.maxMove,\n                         this.vp);\n    }\n    if (this.left) {\n      this.vp -= this.moveSpeed;\n      this.vp = Math.max(-this.maxMove,\n                          this.vp);\n    }\n    this.y += this.vy;\n    this.vy += this.gravity;\n    this.p += this.vp;\n    this.vp *= this.friction;\n    \n    // Are we on a step?\n    var tolerance = Math.max(-player.vy, 1);\n    if (this.vy < 0 &&\n        steps.playerIsOnAnyStep(tolerance)) {\n      // Bounce off a step\n      this.vy = this.bounce * -this.vy;\n    }\n    // CODE ME!\n    // Are we right below a step?\n    // Right now, the player goes through steps\n    // from the bottom. That's lame! Fix it!\n    // You should check for whether you\n    // are below a step, using\n    // steps.playerIsBelowAnyStep()\n    // and make the player hit his head with\n    // a thud (by setting vy to 0) if he \n    // does hit the ceiling.  The code should\n    // look almost the same as the lines\n    // above for checking if we are on a \n    // step and bouncing off the step,\n    // but you'll have to think about directions\n    // (remember y and vy are positive going\n    // up in this game) and set this.vy\n    // differently to get that nice thud.\n    // Be sure to read how playerIsBelowAnyStep()\n    // in the Steps object works.  Okay, go\n    // for it, code it below!\n    \n  };\n  \n  this.canJump = function() {\n    // This should check to make sure we are\n    // on top of a solid surface we can jump\n    // off of\n    var tolerance = Math.max(-player.vy, 8);\n    return steps.playerIsOnAnyStep(tolerance);\n  };\n    \n  this.draw = function() {\n    // The player is a simple circle\n    c.beginPath();\n    c.arc(this.x, h - this.y - this.r, this.r,\n          0, 2 * Math.PI);\n    c.stroke();\n  };\n}\n\n// Track keyboard events on the canvas.\n// The canvas doesn't normally respond to\n// keyboard events, but it will if we make\n// the content editable (or set the tabIndex)\nc.canvas.contentEditable = true;\nc.canvas.onkeydown = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = true;    \n    evt.preventDefault();  \n  }\n};\nc.canvas.onkeyup = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = false;    \n    evt.preventDefault();  \n  }\n};\n\n\nvar player = new Player();\nvar steps = new Steps();\n  \n// Animation loop\nvar cmTID;\nvar timeStep = 50;  // milliseconds\nvar frameRate = 1000 / timeStep;\nfunction updateAll() {\n  // Move everything\n  player.move();\n  steps.move();\n  steps.addNeeded();\n  // Redraw everything\n  c.clearRect(0, 0, w, h);\n  player.draw();\n  steps.draw();\n  \n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);\n}\nupdateAll();",
      tutorImage: 1,
    },
    { message: "Looking pretty good, isn't it? Next we're going to add rewards and enemies to the game. In this simple platformer, a step will have at most one reward, which will be stationary, and can also have at most one enemy, which will move. The player will get points and health by touching rewards, and lose health by touching enemies. Both rewards and enemies disappear when touched. The game will end when the player's health runs out.",
      tutorImage: 3,
    },
    { message: "Think about how you might add enemies and rewards to the game. How would you attach them to the step they are on? How would you code them? Try writing a little code for them, at least create Enemy and Reward objects along with empty draw() and move() methods. How should the enemies and rewards keep track of where they are on a step? How far can you get on adding Enemy and Reward objects to the game? Spend some time on it, try to do it.",
      lessonSection: "Enemies and Rewards",
      tutorImage: 4,
    },
    { message: "Here's my version. It doesn't detect the player touching a reward or enemy yet, but it's still pretty fun. Before we code anything else, try some changes to the code to make sure you've read and understood it. Can you change the color of the rewards and enemies? Can you make them appear more or less often? How about speeding up how fast the enemies move? Try to do all those things before going on.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n\nfunction Reward(step) {\n  this.size = 16;\n  this.r = this.size / 2;\n  // The step we are on\n  this.step = step;\n  // How high we float above that step\n  this.gap = 2;\n  // The x position on the step we are on,\n  // indicates offset of the center of the \n  // reward on the step\n  this.x = this.step.width - this.size;\n  this.x *= Math.random();\n  this.x += this.r;\n  // Angle will be used to spin the reward\n  // as it is dying\n  this.angle = 0;\n\n  this.move = function() {\n    // Rewards don't move, do nothing\n  };\n\n  this.draw = function() {\n    var x = this.step.getX();\n    var y = h - this.step.getY();\n    // Adjust x and y to center of reward\n    x += this.x;\n    y -= this.r + this.gap;\n    // Parameters are the left top coordinates\n    // of the step we are on\n    c.save();\n    // Draw the reward as a filled green box\n    c.fillStyle = 'green';\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.fillRect(-this.r, -this.r, \n               this.size, this.size);\n    c.restore();\n\n    // When the reward is dying, spin it\n    // and shrink it\n    if (this.dying) {\n      this.angle += 10;\n      this.size = Math.max(0, this.size - 1);\n    }\n  };\n}\n\nfunction Enemy(step) {\n  this.size = 20;\n  this.r = this.size / 2;\n  // The step we are on\n  this.step = step;\n  // How high we float above that step\n  this.gap = 2;\n  // The x position on the step we are on,\n  // indicates offset of the center of the \n  // enemy on the step\n  this.x = this.step.width - this.size;\n  this.x *= Math.random();\n  this.x += this.r;\n  // Velocity (since the enemies move)\n  this.maxVx = 2;\n  this.vx = (Math.random() - 0.5);\n  this.vx *= this.maxVx * 2;\n  // Angle will be used to spin the enemy\n  // as it is dying\n  this.angle = 0;\n  \n  this.move = function() {\n    // Move back and forth on the step\n    this.x += this.vx;\n    if (this.x < this.r) {\n      this.x = this.r;\n      this.vx = -this.vx;\n    }\n    var maxX = this.step.width - this.r;\n    if (this.x > maxX) {\n      this.x = maxX;\n      this.vx = -this.vx;\n    }\n  };\n  \n  this.draw = function() {\n    var x = this.step.getX();\n    var y = h - this.step.getY();\n    // Adjust x and y to center of enemy\n    x += this.x;\n    y -= this.r + this.gap;\n    var s = this.size;\n    // Parameters are the left top coordinates\n    // of the step we are on\n    c.save();\n    // Draw the enemy as a filled red triangle\n    c.strokeStyle = 'red';\n    c.lineWidth = 2;\n    // Move to the center of the enemy\n    c.translate(x, y);\n    // Rotate as necessary\n    c.rotate(this.angle * Math.PI / 180);\n    // Draw a triangle\n    c.beginPath();\n    c.moveTo(-s / 3, s / 2);\n    c.lineTo(0, -s / 2);\n    c.lineTo(s / 3, s / 2);\n    c.closePath();\n    c.stroke();\n    c.restore();\n\n    // When the enemy is dying, spin it\n    // and shrink it\n    if (this.dying) {\n      this.angle += 10;\n      this.size = Math.max(0, this.size - 1);\n    }\n  };\n}\n\n\nfunction Step(index, height) {\n  // index is like the x coordinate for\n  // steps. The first step, at index 0, would\n  // be drawn from 0 to width in x.  The\n  // second step, at index 1, would be from\n  // x to 2x. Index 2 would be 2x to 3x, and\n  // so on.\n  this.index = index;\n  // height is how high off the ground this\n  // step is. On the ground is height 0.\n  // the first step off the ground will have\n  // a height of 1 and be drawn this.stepDiff\n  // pixels off the bottom (so at h - \n  // this.stepDiff). Height 2 will be 2 *\n  // this.stepDiff off the bottom, and so on.\n  this.height = height;\n  // Constants\n  this.width = w / 5;\n  this.stepDiff = 40;\n  \n  \n  this.init = function() {\n    // Don't allow anything on the first couple\n    // steps\n    if (this.index < 2) { return; }\n    // Randomly add rewards and enemies\n    if (Math.random() < (this.height + 1) / 10) {\n      // More rewards on higher, harder\n      // to get to steps\n      this.reward = new Reward(this);\n    }\n    if (Math.random() < 0.1) {\n      // Later, this should add more enemies\n      // the higher the score (increasing\n      // the difficulty), right now, just\n      // make it a 10% chance of any step\n      // (including the bottom) having\n      // an enemy.\n      this.enemy = new Enemy(this);\n    }\n  };\n  this.init();\n\n  this.playerIsOn = function(tolerance) {\n    tolerance = tolerance || 1;\n    // Returns true if the player is on this\n    // step\n    \n    // First check if the player is anywhere\n    // near this step\n    var x = this.getX();\n    if (player.x + player.r < x) {\n      // Player is way to the left\n      return false;\n    }\n    if (player.x - player.r > x + this.width) {\n      // Player is way to the right\n      return false;\n    }\n    var y = this.getY();\n    var diffY = player.y - y;\n    return (diffY >= 0 && diffY <= tolerance);\n  };\n\n  this.playerIsBelow = function(tolerance) {\n    tolerance = tolerance || 2;\n    // Returns true if the player is immediately\n    // below this step\n    \n    // First check if the player is anywhere\n    // near this step\n    var x = this.getX();\n    if (player.x + player.r < x) {\n      // Player is way to the left\n      return false;\n    }\n    if (player.x - player.r > x + this.width) {\n      // Player is way to the right\n      return false;\n    }\n    var y = this.getY();\n    var diffY = y - (player.y + player.size);\n    return (diffY >= 0 && diffY <= tolerance);\n  };\n\n  this.move = function() {\n    // If we have a reward or enemy, ask\n    // it to move itself\n    if (this.reward) {\n      this.reward.move();\n      if (this.reward.dying &&\n          this.reward.size <= 0) {\n        // The reward went from dying to dead.\n        // Remove it completely.\n        this.reward = undefined;\n      }\n    }\n    if (this.enemy) {\n      this.enemy.move();\n      if (this.enemy.dying &&\n          this.enemy.size <= 0) {\n        // The enemy went from dying to dead.\n        // Remove it completely.\n        this.enemy = undefined;\n      }\n    }\n  };\n  \n  this.draw = function() {\n    var x = this.getX();\n    // Stop immediately if we are off the\n    // screen\n    if (x + this.stepWidth < 0 ||\n        x > w) {\n      return;\n    }\n    var y = h - this.getY();\n    this.drawLine(x, y, x + this.width, y);\n    // If we have a reward or enemy, ask\n    // it to draw itself\n    if (this.reward) {\n      this.reward.draw();\n    }\n    if (this.enemy) {\n      this.enemy.draw();\n    }\n  };\n  \n  this.getX = function() {\n    // Returns left position of the step\n    var x = this.index * this.width;\n    x -= player.p;\n    return x;\n  };\n  \n  this.getY = function() {\n    // Returns y position (from bottom, not\n    // top of canvas, do (h - this.getY())\n    // to get the y position to use for\n    // drawing\n    var y = this.height * this.stepDiff;\n    return y;\n  };\n  \n  this.drawLine = function(x, y, x2, y2) {\n    // Draws a line from (x,y) to (x2, y2)\n    c.beginPath();\n    c.moveTo(x, y);\n    c.lineTo(x2, y2);\n    c.stroke();\n  };\n}\n\n\nfunction Steps() {\n  // Steps should be a unique ordered list,\n  // sorted by index, subsorted by height. So, \n  // if the last step in the list is\n  // at index 5 and height 3, the next step\n  // added has to be at least index 5 and \n  // height 4 (but could also be index 6\n  // and height 0, or anything else above index\n  // 5 and height 3)\n  this.steps = [];\n  // Likelihood of a step being added at each\n  // opportunity to add a step\n  this.stepChance = 0.5;\n\n  this.addNeeded = function() {\n    var len = this.steps.length;\n    var lastStep = this.steps[len - 1];\n    var maxIndex = lastStep.index;\n    var prevHeight = lastStep.height;\n    \n    // Given the last step, figure out\n    // how high maxIndex should be\n    var minNeeded = (w + player.p) /\n                    lastStep.width;\n    minNeeded = Math.ceil(minNeeded) - 1;\n    if (maxIndex < minNeeded) {\n      var newIndex = maxIndex + 1;\n      // Every index has a step at 0 (bottom)\n      this.steps.push(new Step(newIndex, 0));\n      // Find the ceiling\n      var maxHeight = h / lastStep.stepDiff;\n      maxHeight = Math.floor(maxHeight) - 1;\n      // Randomly add a step above the bottom\n      for (var i = 1; i >= -1; i--) {\n        if (i + prevHeight > 0 &&\n            i + prevHeight < maxHeight &&\n            Math.random() < this.stepChance) {\n          // Create a new step at this height\n          this.steps.push(new Step(newIndex,\n                              i + prevHeight));\n          // Once we create a step, stop\n          // creating any more at this index\n          // (there will be at most two steps\n          // per index)\n          break;\n        }\n      }\n      // Call ourselves again to add any more\n      // steps that are still needed\n      this.addNeeded();\n    }\n  };\n\n  this.init = function() {\n    // Start with a couple steps just at \n    // ground level\n    this.steps.push(new Step(0, 0));\n    this.steps.push(new Step(1, 0));\n    // Automatically add any more needed steps\n    this.addNeeded();\n  };\n  this.init();\n  \n  this.playerIsOnAnyStep = function(tolerance) {\n    tolerance = tolerance || 1;\n    for (var i = 0; i < this.steps.length; i++) {\n      if (this.steps[i].playerIsOn(tolerance)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  this.playerIsBelowAnyStep = \n    function(tolerance) {\n    tolerance = tolerance || 2;\n    for (var i = 0; i < this.steps.length; i++) {\n      var s = this.steps[i];\n      if (s.playerIsBelow(tolerance)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  this.move = function() {\n    for (var i = 0; i < this.steps.length; i++) {\n      this.steps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    for (var i = 0; i < this.steps.length; i++) {\n      this.steps[i].draw();\n    }\n  };\n}\n\nfunction Player() {\n  // Constants\n  this.r = 10;\n  this.size = this.r * 2;\n  this.x = w * 0.2;\n  this.jumpSpeed = 8;\n  this.moveSpeed = 2;\n  this.maxMove = 8;\n  this.gravity = -0.6;\n  this.bounce = 0.2;\n  this.friction = 0.8;\n  // Position\n  // Only the height is variable, x is\n  // constant.  The height is the height of\n  // the center off the bottom (so, the center\n  // of the player is at h - r - y in screen\n  // coordinates)\n  this.y = 0;\n  this.vy = 0;\n  // p is the location of the player in the\n  // world after moving left or right.\n  // The player is always drawn at x, but\n  // the rest of the world, all other objects,\n  // should use player.p to adjust where they\n  // are drawn.\n  this.p = 0;\n  // vp is the velocity of the player (change\n  // in p)\n  this.vp = 0;\n  \n  this.move = function() {\n    // Was a jump requested? Can we jump?\n    if (this.jump && this.canJump()) {\n      // Jump!\n      this.vy = this.jumpSpeed;\n    }\n    if (this.right) {\n      this.vp += this.moveSpeed;\n      this.vp = Math.min(this.maxMove,\n                         this.vp);\n    }\n    if (this.left) {\n      this.vp -= this.moveSpeed;\n      this.vp = Math.max(-this.maxMove,\n                          this.vp);\n    }\n    this.y += this.vy;\n    this.vy += this.gravity;\n    this.p += this.vp;\n    this.p = Math.max(this.p, 0);\n    this.vp *= this.friction;\n    \n    // Are we on a step?\n    var tolerance = Math.max(-player.vy, 1);\n    if (this.vy < 0 &&\n        steps.playerIsOnAnyStep(tolerance)) {\n      // Bounce off a step\n      this.vy = this.bounce * -this.vy;\n    }\n    // Are we right below a step?\n    tolerance = Math.max(player.vy, 1);\n    if (this.vy > 0 &&\n        steps.playerIsBelowAnyStep(tolerance)) {\n      // Hit the ceiling with a thud\n      this.vy = 0;\n    }\n  };\n  \n  this.canJump = function() {\n    // This should check to make sure we are\n    // on top of a solid surface we can jump\n    // off of\n    var tolerance = Math.max(-player.vy, 8);\n    return steps.playerIsOnAnyStep(tolerance);\n  };\n    \n  this.draw = function() {\n    // The player is a simple circle\n    c.beginPath();\n    c.arc(this.x, h - this.y - this.r, this.r,\n          0, 2 * Math.PI);\n    c.stroke();\n  };\n}\n\n// Track keyboard events on the canvas.\n// The canvas doesn't normally respond to\n// keyboard events, but it will if we make\n// the content editable (or set the tabIndex)\nc.canvas.contentEditable = true;\nc.canvas.onkeydown = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = true;    \n    evt.preventDefault();  \n  }\n};\nc.canvas.onkeyup = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = false;    \n    evt.preventDefault();  \n  }\n};\n\n\nvar player = new Player();\nvar steps = new Steps();\n  \n// Animation loop\nvar cmTID;\nvar timeStep = 50;  // milliseconds\nvar frameRate = 1000 / timeStep;\nfunction updateAll() {\n  // Move everything\n  player.move();\n  steps.move();\n  steps.addNeeded();\n  // Redraw everything\n  c.clearRect(0, 0, w, h);\n  player.draw();\n  steps.draw();\n  \n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);\n}\nupdateAll();",
      tutorImage: 6,
    },  
    { message: "Let's kill off the rewards and enemies when the player bumps into them. This kind of collision detection stuff is fun to write.  Look for the comments in checkPlayerTouch() in the Reward object that tell you what to do, then write that function for both rewards and enemies.  When you're done writing that function, the other code should all just work, so you should be able to play and see the enemies and rewards do a little dying animation when you run into them.",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n\nfunction Reward(step) {\n  this.size = 16;\n  this.r = this.size / 2;\n  // The step we are on\n  this.step = step;\n  // How high we float above that step\n  this.gap = 2;\n  // The x position on the step we are on,\n  // indicates offset of the center of the \n  // reward on the step\n  this.x = this.step.width - this.size;\n  this.x *= Math.random();\n  this.x += this.r;\n  // Angle will be used to spin the reward\n  // as it is dying\n  this.angle = 0;\n\n  this.checkPlayerTouch = function() {\n    // CODE ME!\n    // Compute if we are overlapping with the\n    // player.  If we are, set this.dying\n    // to true.\n    // Computing if we are overlapping with\n    // the player isn't easy, but also isn't\n    // that bad.  It's a lot like the\n    // code in draw() to find the center of\n    // the object to translate() to. Once\n    // you have the center, the player's\n    // center is at player.x and player.y\n    // (but don't forget that player.y is\n    // from the bottom of the screen and\n    // draw's y coordinate will usually be\n    // from the top, you may have to convert).\n    // Then, the center's overlap if their\n    // distance apart is less than the sum\n    // of their radiuses (this.r and player.r).\n    // Write all that code to check if they\n    // are overlapping, and, if they are,\n    // set this.dying to true. Then do\n    // it again for checkPlayerTouch()\n    // down in the Enemy object. Code away!\n    \n  };\n  \n  this.move = function() {\n    // Check if we are in contact with the player\n    this.checkPlayerTouch();\n    // Rewards don't move, do nothing else\n  };\n\n  this.draw = function() {\n    var x = this.step.getX();\n    var y = h - this.step.getY();\n    // Adjust x and y to center of reward\n    x += this.x;\n    y -= this.r + this.gap;\n    // Parameters are the left top coordinates\n    // of the step we are on\n    c.save();\n    // Draw the reward as a filled green box\n    c.fillStyle = 'green';\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.fillRect(-this.r, -this.r, \n               this.size, this.size);\n    c.restore();\n\n    // When the reward is dying, spin it\n    // and shrink it\n    if (this.dying) {\n      this.angle += 10;\n      this.size = Math.max(0, this.size - 1);\n    }\n  };\n}\n\nfunction Enemy(step) {\n  this.size = 20;\n  this.r = this.size / 2;\n  // The step we are on\n  this.step = step;\n  // How high we float above that step\n  this.gap = 2;\n  // The x position on the step we are on,\n  // indicates offset of the center of the \n  // enemy on the step\n  this.x = this.step.width - this.size;\n  this.x *= Math.random();\n  this.x += this.r;\n  // Velocity (since the enemies move)\n  this.maxVx = 2;\n  this.vx = (Math.random() - 0.5);\n  this.vx *= this.maxVx * 2;\n  // Angle will be used to spin the enemy\n  // as it is dying\n  this.angle = 0;\n  \n  this.checkPlayerTouch = function() {\n    // CODE ME!\n    // Compute if we are overlapping with the\n    // player.  If we are, set this.dying\n    // to true.\n    \n  };\n  \n\n  this.move = function() {\n    // Check if we are in contact with the player\n    this.checkPlayerTouch();\n    // Move back and forth on the step\n    this.x += this.vx;\n    if (this.x < this.r) {\n      this.x = this.r;\n      this.vx = -this.vx;\n    }\n    var maxX = this.step.width - this.r;\n    if (this.x > maxX) {\n      this.x = maxX;\n      this.vx = -this.vx;\n    }\n  };\n  \n  this.draw = function() {\n    var x = this.step.getX();\n    var y = h - this.step.getY();\n    // Adjust x and y to center of enemy\n    x += this.x;\n    y -= this.r + this.gap;\n    var s = this.size;\n    // Parameters are the left top coordinates\n    // of the step we are on\n    c.save();\n    // Draw the enemy as a filled red triangle\n    c.strokeStyle = 'red';\n    c.lineWidth = 2;\n    // Move to the center of the enemy\n    c.translate(x, y);\n    // Rotate as necessary\n    c.rotate(this.angle * Math.PI / 180);\n    // Draw a triangle\n    c.beginPath();\n    c.moveTo(-s / 3, s / 2);\n    c.lineTo(0, -s / 2);\n    c.lineTo(s / 3, s / 2);\n    c.closePath();\n    c.stroke();\n    c.restore();\n\n    // When the enemy is dying, spin it\n    // and shrink it\n    if (this.dying) {\n      this.angle += 10;\n      this.size = Math.max(0, this.size - 1);\n    }\n  };\n}\n\n\nfunction Step(index, height) {\n  // index is like the x coordinate for\n  // steps. The first step, at index 0, would\n  // be drawn from 0 to width in x.  The\n  // second step, at index 1, would be from\n  // x to 2x. Index 2 would be 2x to 3x, and\n  // so on.\n  this.index = index;\n  // height is how high off the ground this\n  // step is. On the ground is height 0.\n  // the first step off the ground will have\n  // a height of 1 and be drawn this.stepDiff\n  // pixels off the bottom (so at h - \n  // this.stepDiff). Height 2 will be 2 *\n  // this.stepDiff off the bottom, and so on.\n  this.height = height;\n  // Constants\n  this.width = w / 5;\n  this.stepDiff = 40;\n  \n  \n  this.init = function() {\n    // Don't allow anything on the first couple\n    // steps\n    if (this.index < 2) { return; }\n    // Randomly add rewards and enemies\n    if (Math.random() < (this.height + 1) / 10) {\n      // More rewards on higher, harder\n      // to get to steps\n      this.reward = new Reward(this);\n    }\n    if (Math.random() < 0.1) {\n      // Later, this should add more enemies\n      // the higher the score (increasing\n      // the difficulty), right now, just\n      // make it a 10% chance of any step\n      // (including the bottom) having\n      // an enemy.\n      this.enemy = new Enemy(this);\n    }\n  };\n  this.init();\n\n  this.playerIsOn = function(tolerance) {\n    tolerance = tolerance || 1;\n    // Returns true if the player is on this\n    // step\n    \n    // First check if the player is anywhere\n    // near this step\n    var x = this.getX();\n    if (player.x + player.r < x) {\n      // Player is way to the left\n      return false;\n    }\n    if (player.x - player.r > x + this.width) {\n      // Player is way to the right\n      return false;\n    }\n    var y = this.getY();\n    var diffY = player.y - y;\n    return (diffY >= 0 && diffY <= tolerance);\n  };\n\n  this.playerIsBelow = function(tolerance) {\n    tolerance = tolerance || 2;\n    // Returns true if the player is immediately\n    // below this step\n    \n    // First check if the player is anywhere\n    // near this step\n    var x = this.getX();\n    if (player.x + player.r < x) {\n      // Player is way to the left\n      return false;\n    }\n    if (player.x - player.r > x + this.width) {\n      // Player is way to the right\n      return false;\n    }\n    var y = this.getY();\n    var diffY = y - (player.y + player.size);\n    return (diffY >= 0 && diffY <= tolerance);\n  };\n\n  this.move = function() {\n    // If we have a reward or enemy, ask\n    // it to move itself\n    if (this.reward) {\n      this.reward.move();\n      if (this.reward.dying &&\n          this.reward.size <= 0) {\n        // The reward went from dying to dead.\n        // Remove it completely.\n        this.reward = undefined;\n      }\n    }\n    if (this.enemy) {\n      this.enemy.move();\n      if (this.enemy.dying &&\n          this.enemy.size <= 0) {\n        // The enemy went from dying to dead.\n        // Remove it completely.\n        this.enemy = undefined;\n      }\n    }\n  };\n  \n  this.draw = function() {\n    var x = this.getX();\n    // Stop immediately if we are off the\n    // screen\n    if (x + this.stepWidth < 0 ||\n        x > w) {\n      return;\n    }\n    var y = h - this.getY();\n    this.drawLine(x, y, x + this.width, y);\n    // If we have a reward or enemy, ask\n    // it to draw itself\n    if (this.reward) {\n      this.reward.draw();\n    }\n    if (this.enemy) {\n      this.enemy.draw();\n    }\n  };\n  \n  this.getX = function() {\n    // Returns left position of the step\n    var x = this.index * this.width;\n    x -= player.p;\n    return x;\n  };\n  \n  this.getY = function() {\n    // Returns y position (from bottom, not\n    // top of canvas, do (h - this.getY())\n    // to get the y position to use for\n    // drawing\n    var y = this.height * this.stepDiff;\n    return y;\n  };\n  \n  this.drawLine = function(x, y, x2, y2) {\n    // Draws a line from (x,y) to (x2, y2)\n    c.beginPath();\n    c.moveTo(x, y);\n    c.lineTo(x2, y2);\n    c.stroke();\n  };\n}\n\n\nfunction Steps() {\n  // Steps should be a unique ordered list,\n  // sorted by index, subsorted by height. So, \n  // if the last step in the list is\n  // at index 5 and height 3, the next step\n  // added has to be at least index 5 and \n  // height 4 (but could also be index 6\n  // and height 0, or anything else above index\n  // 5 and height 3)\n  this.steps = [];\n  // Likelihood of a step being added at each\n  // opportunity to add a step\n  this.stepChance = 0.5;\n\n  this.addNeeded = function() {\n    var len = this.steps.length;\n    var lastStep = this.steps[len - 1];\n    var maxIndex = lastStep.index;\n    var prevHeight = lastStep.height;\n    \n    // Given the last step, figure out\n    // how high maxIndex should be\n    var minNeeded = (w + player.p) /\n                    lastStep.width;\n    minNeeded = Math.ceil(minNeeded) - 1;\n    if (maxIndex < minNeeded) {\n      var newIndex = maxIndex + 1;\n      // Every index has a step at 0 (bottom)\n      this.steps.push(new Step(newIndex, 0));\n      // Find the ceiling\n      var maxHeight = h / lastStep.stepDiff;\n      maxHeight = Math.floor(maxHeight) - 1;\n      // Randomly add a step above the bottom\n      for (var i = 1; i >= -1; i--) {\n        if (i + prevHeight > 0 &&\n            i + prevHeight < maxHeight &&\n            Math.random() < this.stepChance) {\n          // Create a new step at this height\n          this.steps.push(new Step(newIndex,\n                              i + prevHeight));\n          // Once we create a step, stop\n          // creating any more at this index\n          // (there will be at most two steps\n          // per index)\n          break;\n        }\n      }\n      // Call ourselves again to add any more\n      // steps that are still needed\n      this.addNeeded();\n    }\n  };\n\n  this.init = function() {\n    // Start with a couple steps just at \n    // ground level\n    this.steps.push(new Step(0, 0));\n    this.steps.push(new Step(1, 0));\n    // Automatically add any more needed steps\n    this.addNeeded();\n  };\n  this.init();\n  \n  this.playerIsOnAnyStep = function(tolerance) {\n    tolerance = tolerance || 1;\n    for (var i = 0; i < this.steps.length; i++) {\n      if (this.steps[i].playerIsOn(tolerance)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  this.playerIsBelowAnyStep = \n    function(tolerance) {\n    tolerance = tolerance || 2;\n    for (var i = 0; i < this.steps.length; i++) {\n      var s = this.steps[i];\n      if (s.playerIsBelow(tolerance)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  this.move = function() {\n    for (var i = 0; i < this.steps.length; i++) {\n      this.steps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    for (var i = 0; i < this.steps.length; i++) {\n      this.steps[i].draw();\n    }\n  };\n}\n\nfunction Player() {\n  // Constants\n  this.r = 10;\n  this.size = this.r * 2;\n  this.x = w * 0.2;\n  this.jumpSpeed = 8;\n  this.moveSpeed = 2;\n  this.maxMove = 8;\n  this.gravity = -0.6;\n  this.bounce = 0.2;\n  this.friction = 0.8;\n  // Position\n  // Only the height is variable, x is\n  // constant.  The height is the height of\n  // the center off the bottom (so, the center\n  // of the player is at h - r - y in screen\n  // coordinates)\n  this.y = 0;\n  this.vy = 0;\n  // p is the location of the player in the\n  // world after moving left or right.\n  // The player is always drawn at x, but\n  // the rest of the world, all other objects,\n  // should use player.p to adjust where they\n  // are drawn.\n  this.p = 0;\n  // vp is the velocity of the player (change\n  // in p)\n  this.vp = 0;\n  \n  this.move = function() {\n    // Was a jump requested? Can we jump?\n    if (this.jump && this.canJump()) {\n      // Jump!\n      this.vy = this.jumpSpeed;\n    }\n    if (this.right) {\n      this.vp += this.moveSpeed;\n      this.vp = Math.min(this.maxMove,\n                         this.vp);\n    }\n    if (this.left) {\n      this.vp -= this.moveSpeed;\n      this.vp = Math.max(-this.maxMove,\n                          this.vp);\n    }\n    this.y += this.vy;\n    this.vy += this.gravity;\n    this.p += this.vp;\n    this.p = Math.max(this.p, 0);\n    this.vp *= this.friction;\n    \n    // Are we on a step?\n    var tolerance = Math.max(-player.vy, 1);\n    if (this.vy < 0 &&\n        steps.playerIsOnAnyStep(tolerance)) {\n      // Bounce off a step\n      this.vy = this.bounce * -this.vy;\n    }\n    // Are we right below a step?\n    tolerance = Math.max(player.vy, 1);\n    if (this.vy > 0 &&\n        steps.playerIsBelowAnyStep(tolerance)) {\n      // Hit the ceiling with a thud\n      this.vy = 0;\n    }\n  };\n  \n  this.canJump = function() {\n    // This should check to make sure we are\n    // on top of a solid surface we can jump\n    // off of\n    var tolerance = Math.max(-player.vy, 8);\n    return steps.playerIsOnAnyStep(tolerance);\n  };\n    \n  this.draw = function() {\n    // The player is a simple circle\n    c.beginPath();\n    c.arc(this.x, h - this.y - this.r, this.r,\n          0, 2 * Math.PI);\n    c.stroke();\n  };\n}\n\n// Track keyboard events on the canvas.\n// The canvas doesn't normally respond to\n// keyboard events, but it will if we make\n// the content editable (or set the tabIndex)\nc.canvas.contentEditable = true;\nc.canvas.onkeydown = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = true;    \n    evt.preventDefault();  \n  }\n};\nc.canvas.onkeyup = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = false;    \n    evt.preventDefault();  \n  }\n};\n\n\nvar player = new Player();\nvar steps = new Steps();\n  \n// Animation loop\nvar cmTID;\nvar timeStep = 50;  // milliseconds\nvar frameRate = 1000 / timeStep;\nfunction updateAll() {\n  // Move everything\n  player.move();\n  steps.move();\n  steps.addNeeded();\n  // Redraw everything\n  c.clearRect(0, 0, w, h);\n  player.draw();\n  steps.draw();\n  \n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  cmTID = setTimeout(updateAll, timeStep);\n}\nupdateAll();",
      tutorImage: 1,
    },    
    { message: "Okay, now we need a score and the game to end when the player runs out of health.  I've added score and health to the Player object and code to display them as well as a check for player.gameOver being set. You need to subtract 20 health from the player when he hits an enemy, add 10 to health and 100 to the score when the player hits a reward, and modify Player's move() so the game ends (player.gameOver is set to true) when health is 0 or less. Can you do all that? If you can, you'll have a fully playable game! Spend some time on this, try to get it!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n\nfunction Reward(step) {\n  this.size = 16;\n  this.r = this.size / 2;\n  // The step we are on\n  this.step = step;\n  // How high we float above that step\n  this.gap = 2;\n  // The x position on the step we are on,\n  // indicates offset of the center of the \n  // reward on the step\n  this.x = this.step.width - this.size;\n  this.x *= Math.random();\n  this.x += this.r;\n  // Angle will be used to spin the reward\n  // as it is dying\n  this.angle = 0;\n\n  this.checkPlayerTouch = function() {\n    // Compute if we are overlapping with the\n    // player.  If we are, set this.dying\n    // to true.\n    if (this.dying) { return; }\n    var x = this.step.getX();\n    var y = h - this.step.getY();\n    // Adjust x and y to center of reward\n    x += this.x;\n    y -= this.r + this.gap;\n    var x2 = player.x;\n    var y2 = h - player.y;\n    var diffX = x - x2;\n    var diffY = y - y2;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    if (dist < player.r + this.r) {\n      this.dying = true;\n    }\n  };\n  \n  this.move = function() {\n    // Check if we are in contact with the player\n    this.checkPlayerTouch();\n    // Rewards don't move, do nothing else\n  };\n\n  this.draw = function() {\n    var x = this.step.getX();\n    var y = h - this.step.getY();\n    // Adjust x and y to center of reward\n    x += this.x;\n    y -= this.r + this.gap;\n    // Parameters are the left top coordinates\n    // of the step we are on\n    c.save();\n    // Draw the reward as a filled green box\n    c.fillStyle = 'green';\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.fillRect(-this.r, -this.r, \n               this.size, this.size);\n    c.restore();\n\n    // When the reward is dying, spin it\n    // and shrink it\n    if (this.dying) {\n      this.angle += 10;\n      this.size = Math.max(0, this.size - 1);\n    }\n  };\n}\n\nfunction Enemy(step) {\n  this.size = 20;\n  this.r = this.size / 2;\n  // The step we are on\n  this.step = step;\n  // How high we float above that step\n  this.gap = 2;\n  // The x position on the step we are on,\n  // indicates offset of the center of the \n  // enemy on the step\n  this.x = this.step.width - this.size;\n  this.x *= Math.random();\n  this.x += this.r;\n  // Velocity (since the enemies move)\n  this.maxVx = 2;\n  this.vx = (Math.random() - 0.5);\n  this.vx *= this.maxVx * 2;\n  // Angle will be used to spin the enemy\n  // as it is dying\n  this.angle = 0;\n  \n  this.checkPlayerTouch = function() {\n    // Compute if we are overlapping with the\n    // player.  If we are, set this.dying\n    // to true.\n    if (this.dying) { return; }\n    var x = this.step.getX();\n    var y = h - this.step.getY();\n    // Adjust x and y to center of reward\n    x += this.x;\n    y -= this.r + this.gap;\n    var x2 = player.x;\n    var y2 = h - player.y;\n    var diffX = x - x2;\n    var diffY = y - y2;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    if (dist < player.r + this.r) {\n      this.dying = true;\n    }    \n  };\n  \n\n  this.move = function() {\n    // Check if we are in contact with the player\n    this.checkPlayerTouch();\n    // Move back and forth on the step\n    this.x += this.vx;\n    if (this.x < this.r) {\n      this.x = this.r;\n      this.vx = -this.vx;\n    }\n    var maxX = this.step.width - this.r;\n    if (this.x > maxX) {\n      this.x = maxX;\n      this.vx = -this.vx;\n    }\n  };\n  \n  this.draw = function() {\n    var x = this.step.getX();\n    var y = h - this.step.getY();\n    // Adjust x and y to center of enemy\n    x += this.x;\n    y -= this.r + this.gap;\n    var s = this.size;\n    // Parameters are the left top coordinates\n    // of the step we are on\n    c.save();\n    // Draw the enemy as a filled red triangle\n    c.strokeStyle = 'red';\n    c.lineWidth = 2;\n    // Move to the center of the enemy\n    c.translate(x, y);\n    // Rotate as necessary\n    c.rotate(this.angle * Math.PI / 180);\n    // Draw a triangle\n    c.beginPath();\n    c.moveTo(-s / 3, s / 2);\n    c.lineTo(0, -s / 2);\n    c.lineTo(s / 3, s / 2);\n    c.closePath();\n    c.stroke();\n    c.restore();\n\n    // When the enemy is dying, spin it\n    // and shrink it\n    if (this.dying) {\n      this.angle += 10;\n      this.size = Math.max(0, this.size - 1);\n    }\n  };\n}\n\n\nfunction Step(index, height) {\n  // index is like the x coordinate for\n  // steps. The first step, at index 0, would\n  // be drawn from 0 to width in x.  The\n  // second step, at index 1, would be from\n  // x to 2x. Index 2 would be 2x to 3x, and\n  // so on.\n  this.index = index;\n  // height is how high off the ground this\n  // step is. On the ground is height 0.\n  // the first step off the ground will have\n  // a height of 1 and be drawn this.stepDiff\n  // pixels off the bottom (so at h - \n  // this.stepDiff). Height 2 will be 2 *\n  // this.stepDiff off the bottom, and so on.\n  this.height = height;\n  // Constants\n  this.width = w / 5;\n  this.stepDiff = 40;\n  \n  \n  this.init = function() {\n    // Don't allow anything on the first couple\n    // steps\n    if (this.index < 2) { return; }\n    // Randomly add rewards and enemies\n    if (Math.random() < (this.height + 1) / 10) {\n      // More rewards on higher, harder\n      // to get to steps\n      this.reward = new Reward(this);\n    }\n    if (Math.random() < 0.1) {\n      // Later, this should add more enemies\n      // the higher the score (increasing\n      // the difficulty), right now, just\n      // make it a 10% chance of any step\n      // (including the bottom) having\n      // an enemy.\n      this.enemy = new Enemy(this);\n    }\n  };\n  this.init();\n\n  this.playerIsOn = function(tolerance) {\n    tolerance = tolerance || 1;\n    // Returns true if the player is on this\n    // step\n    \n    // First check if the player is anywhere\n    // near this step\n    var x = this.getX();\n    if (player.x + player.r < x) {\n      // Player is way to the left\n      return false;\n    }\n    if (player.x - player.r > x + this.width) {\n      // Player is way to the right\n      return false;\n    }\n    var y = this.getY();\n    var diffY = player.y - y;\n    return (diffY >= 0 && diffY <= tolerance);\n  };\n\n  this.playerIsBelow = function(tolerance) {\n    tolerance = tolerance || 2;\n    // Returns true if the player is immediately\n    // below this step\n    \n    // First check if the player is anywhere\n    // near this step\n    var x = this.getX();\n    if (player.x + player.r < x) {\n      // Player is way to the left\n      return false;\n    }\n    if (player.x - player.r > x + this.width) {\n      // Player is way to the right\n      return false;\n    }\n    var y = this.getY();\n    var diffY = y - (player.y + player.size);\n    return (diffY >= 0 && diffY <= tolerance);\n  };\n\n  this.move = function() {\n    // If we have a reward or enemy, ask\n    // it to move itself\n    if (this.reward) {\n      this.reward.move();\n      if (this.reward.dying &&\n          this.reward.size <= 0) {\n        // The reward went from dying to dead.\n        // Remove it completely.\n        this.reward = undefined;\n      }\n    }\n    if (this.enemy) {\n      this.enemy.move();\n      if (this.enemy.dying &&\n          this.enemy.size <= 0) {\n        // The enemy went from dying to dead.\n        // Remove it completely.\n        this.enemy = undefined;\n      }\n    }\n  };\n  \n  this.draw = function() {\n    var x = this.getX();\n    // Stop immediately if we are off the\n    // screen\n    if (x + this.stepWidth < 0 ||\n        x > w) {\n      return;\n    }\n    var y = h - this.getY();\n    this.drawLine(x, y, x + this.width, y);\n    // If we have a reward or enemy, ask\n    // it to draw itself\n    if (this.reward) {\n      this.reward.draw();\n    }\n    if (this.enemy) {\n      this.enemy.draw();\n    }\n  };\n  \n  this.getX = function() {\n    // Returns left position of the step\n    var x = this.index * this.width;\n    x -= player.p;\n    return x;\n  };\n  \n  this.getY = function() {\n    // Returns y position (from bottom, not\n    // top of canvas, do (h - this.getY())\n    // to get the y position to use for\n    // drawing\n    var y = this.height * this.stepDiff;\n    return y;\n  };\n  \n  this.drawLine = function(x, y, x2, y2) {\n    // Draws a line from (x,y) to (x2, y2)\n    c.beginPath();\n    c.moveTo(x, y);\n    c.lineTo(x2, y2);\n    c.stroke();\n  };\n}\n\n\nfunction Steps() {\n  // Steps should be a unique ordered list,\n  // sorted by index, subsorted by height. So, \n  // if the last step in the list is\n  // at index 5 and height 3, the next step\n  // added has to be at least index 5 and \n  // height 4 (but could also be index 6\n  // and height 0, or anything else above index\n  // 5 and height 3)\n  this.steps = [];\n  // Likelihood of a step being added at each\n  // opportunity to add a step\n  this.stepChance = 0.5;\n\n  this.addNeeded = function() {\n    var len = this.steps.length;\n    var lastStep = this.steps[len - 1];\n    var maxIndex = lastStep.index;\n    var prevHeight = lastStep.height;\n    \n    // Given the last step, figure out\n    // how high maxIndex should be\n    var minNeeded = (w + player.p) /\n                    lastStep.width;\n    minNeeded = Math.ceil(minNeeded) - 1;\n    if (maxIndex < minNeeded) {\n      var newIndex = maxIndex + 1;\n      // Every index has a step at 0 (bottom)\n      this.steps.push(new Step(newIndex, 0));\n      // Find the ceiling\n      var maxHeight = h / lastStep.stepDiff;\n      maxHeight = Math.floor(maxHeight) - 1;\n      // Randomly add a step above the bottom\n      for (var i = 1; i >= -1; i--) {\n        if (i + prevHeight > 0 &&\n            i + prevHeight < maxHeight &&\n            Math.random() < this.stepChance) {\n          // Create a new step at this height\n          this.steps.push(new Step(newIndex,\n                              i + prevHeight));\n          // Once we create a step, stop\n          // creating any more at this index\n          // (there will be at most two steps\n          // per index)\n          break;\n        }\n      }\n      // Call ourselves again to add any more\n      // steps that are still needed\n      this.addNeeded();\n    }\n  };\n\n  this.init = function() {\n    // Start with a couple steps just at \n    // ground level\n    this.steps.push(new Step(0, 0));\n    this.steps.push(new Step(1, 0));\n    // Automatically add any more needed steps\n    this.addNeeded();\n  };\n  this.init();\n  \n  this.playerIsOnAnyStep = function(tolerance) {\n    tolerance = tolerance || 1;\n    for (var i = 0; i < this.steps.length; i++) {\n      if (this.steps[i].playerIsOn(tolerance)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  this.playerIsBelowAnyStep = \n    function(tolerance) {\n    tolerance = tolerance || 2;\n    for (var i = 0; i < this.steps.length; i++) {\n      var s = this.steps[i];\n      if (s.playerIsBelow(tolerance)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  this.move = function() {\n    for (var i = 0; i < this.steps.length; i++) {\n      this.steps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    for (var i = 0; i < this.steps.length; i++) {\n      this.steps[i].draw();\n    }\n  };\n}\n\nfunction Player() {\n  // Constants\n  this.r = 10;\n  this.size = this.r * 2;\n  this.x = w * 0.2;\n  this.jumpSpeed = 8;\n  this.moveSpeed = 2;\n  this.maxMove = 8;\n  this.gravity = -0.6;\n  this.bounce = 0.2;\n  this.friction = 0.8;\n  // Position\n  // Only the height is variable, x is\n  // constant.  The height is the height of\n  // the center off the bottom (so, the center\n  // of the player is at h - r - y in screen\n  // coordinates)\n  this.y = 0;\n  this.vy = 0;\n  // p is the location of the player in the\n  // world after moving left or right.\n  // The player is always drawn at x, but\n  // the rest of the world, all other objects,\n  // should use player.p to adjust where they\n  // are drawn.\n  this.p = 0;\n  // vp is the velocity of the player (change\n  // in p)\n  this.vp = 0;\n  // Score starts at 0, Health at 100\n  this.score = 0;\n  this.health = 100;\n  \n  this.move = function() {\n    // Was a jump requested? Can we jump?\n    if (this.jump && this.canJump()) {\n      // Jump!\n      this.vy = this.jumpSpeed;\n    }\n    if (this.right) {\n      this.vp += this.moveSpeed;\n      this.vp = Math.min(this.maxMove,\n                         this.vp);\n    }\n    if (this.left) {\n      this.vp -= this.moveSpeed;\n      this.vp = Math.max(-this.maxMove,\n                          this.vp);\n    }\n    this.y += this.vy;\n    this.vy += this.gravity;\n    this.p += this.vp;\n    this.p = Math.max(this.p, 0);\n    this.vp *= this.friction;\n    \n    // Are we on a step?\n    var tolerance = Math.max(-player.vy, 1);\n    if (this.vy < 0 &&\n        steps.playerIsOnAnyStep(tolerance)) {\n      // Bounce off a step\n      this.vy = this.bounce * -this.vy;\n    }\n    // Are we right below a step?\n    tolerance = Math.max(player.vy, 1);\n    if (this.vy > 0 &&\n        steps.playerIsBelowAnyStep(tolerance)) {\n      // Hit the ceiling with a thud\n      this.vy = 0;\n    }\n  };\n  \n  this.canJump = function() {\n    // This should check to make sure we are\n    // on top of a solid surface we can jump\n    // off of\n    var tolerance = Math.max(-player.vy, 8);\n    return steps.playerIsOnAnyStep(tolerance);\n  };\n    \n  this.draw = function() {\n    // The player is a simple circle\n    c.beginPath();\n    c.arc(this.x, h - this.y - this.r, this.r,\n          0, 2 * Math.PI);\n    c.stroke();\n  };\n}\n\n// Track keyboard events on the canvas.\n// The canvas doesn't normally respond to\n// keyboard events, but it will if we make\n// the content editable (or set the tabIndex)\nc.canvas.contentEditable = true;\nc.canvas.onkeydown = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = true;    \n    evt.preventDefault();  \n  }\n};\nc.canvas.onkeyup = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = false;    \n    evt.preventDefault();  \n  }\n};\n\n\nvar player = new Player();\nvar steps = new Steps();\n\nfunction drawAllText() {\n  // Display score and health\n  c.fillText('Score: ' + player.score,\n             w * 0.8, 20);\n  c.fillText('Health: ' +\n             Math.ceil(player.health),\n             w * 0.05, 20);\n  // If the game is over, display game over\\n  // text\n  if (player.gameOver) {\n    c.save();\n    c.font = '48pt sans-serif';\n    c.textAlign = 'center';\n    c.fillStyle = 'red';\n    c.textBaseline = 'middle';\n    c.fillText('GAME OVER', w / 2, h / 2);\n    c.restore();\n  }\n}\n  \n// Animation loop\nvar cmTID;\nvar timeStep = 50;  // milliseconds\nvar frameRate = 1000 / timeStep;\nfunction updateAll() {\n  // Move everything\n  player.move();\n  steps.move();\n  steps.addNeeded();\n  // Redraw everything\n  c.clearRect(0, 0, w, h);\n  player.draw();\n  steps.draw();\n  drawAllText();\n  \n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  if (!player.gameOver) {\n    cmTID = setTimeout(updateAll, timeStep);\n  }\n}\nupdateAll();",
      lessonSection: "Finishing the Third Game",
      tutorImage: 3,
    },
    { message: "If you got that, try to do a couple more twiddles.  First, try to make your health drop slowly over time unless you get rewards, which nicely puts a little time pressure into the game.  Second, try to make the game get harder -- maybe by adding more enemies or making the enemies do more damage? -- as the score increases.",
      tutorImage: 6,
    },
    { message: "Here's my version. We're done! And it's fun! Try playing it!",
      code: "var w = c.canvas.width;\nvar h = c.canvas.height;\n\n\nfunction Reward(step) {\n  this.size = 16;\n  this.r = this.size / 2;\n  // The step we are on\n  this.step = step;\n  // How high we float above that step\n  this.gap = 2;\n  // The x position on the step we are on,\n  // indicates offset of the center of the \n  // reward on the step\n  this.x = this.step.width - this.size;\n  this.x *= Math.random();\n  this.x += this.r;\n  // Angle will be used to spin the reward\n  // as it is dying\n  this.angle = 0;\n  // How much health the player gets for \n  // touching this\n  this.strength = 10;\n  // How much score the player gets for\n  // touching this\n  this.reward = 100;\n\n  this.checkPlayerTouch = function() {\n    if (this.dying) { return; }\n    // Compute if we are overlapping with the\n    // player.  If we are, set this.dying\n    // to true.\n    var x = this.step.getX();\n    var y = h - this.step.getY();\n    // Adjust x and y to center of reward\n    x += this.x;\n    y -= this.r + this.gap;\n    var x2 = player.x;\n    var y2 = h - player.y;\n    var diffX = x - x2;\n    var diffY = y - y2;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    if (dist < player.r + this.r) {\n      this.dying = true;\n      player.health += this.strength;\n      player.health = \n        Math.min(100, player.health);\n      player.score += this.reward;\n    }\n  };\n  \n  this.move = function() {\n    // Check if we are in contact with the player\n    this.checkPlayerTouch();\n    // Rewards don't move, do nothing else\n  };\n\n  this.draw = function() {\n    var x = this.step.getX();\n    var y = h - this.step.getY();\n    // Adjust x and y to center of reward\n    x += this.x;\n    y -= this.r + this.gap;\n    // Parameters are the left top coordinates\n    // of the step we are on\n    c.save();\n    // Draw the reward as a filled green box\n    c.fillStyle = 'green';\n    c.translate(x, y);\n    c.rotate(this.angle * Math.PI / 180);\n    c.fillRect(-this.r, -this.r, \n               this.size, this.size);\n    c.restore();\n\n    // When the reward is dying, spin it\n    // and shrink it\n    if (this.dying) {\n      this.angle += 10;\n      this.size = Math.max(0, this.size - 1);\n    }\n  };\n}\n\nfunction Enemy(step) {\n  this.size = 20;\n  this.r = this.size / 2;\n  // The step we are on\n  this.step = step;\n  // How high we float above that step\n  this.gap = 2;\n  // The x position on the step we are on,\n  // indicates offset of the center of the \n  // enemy on the step\n  this.x = this.step.width - this.size;\n  this.x *= Math.random();\n  this.x += this.r;\n  // Velocity (since the enemies move)\n  this.maxVx = 2;\n  this.vx = (Math.random() - 0.5);\n  this.vx *= this.maxVx * 2;\n  // Angle will be used to spin the enemy\n  // as it is dying\n  this.angle = 0;\n  // How much health the player gets for \n  // touching this\n  this.strength = -20;\n  \n  this.checkPlayerTouch = function() {\n    if (this.dying) { return; }\n    // Compute if we are overlapping with the\n    // player.  If we are, set this.dying\n    // to true.\n    var x = this.step.getX();\n    var y = h - this.step.getY();\n    // Adjust x and y to center of reward\n    x += this.x;\n    y -= this.r + this.gap;\n    var x2 = player.x;\n    var y2 = h - player.y;\n    var diffX = x - x2;\n    var diffY = y - y2;\n    var dist = Math.sqrt(diffX * diffX +\n                         diffY * diffY);\n    if (dist < player.r + this.r) {\n      player.health += this.strength;\n      player.health = Math.max(0, player.health);\n      this.dying = true;\n    }    \n  };\n  \n\n  this.move = function() {\n    // Check if we are in contact with the player\n    this.checkPlayerTouch();\n    // Move back and forth on the step\n    this.x += this.vx;\n    if (this.x < this.r) {\n      this.x = this.r;\n      this.vx = -this.vx;\n    }\n    var maxX = this.step.width - this.r;\n    if (this.x > maxX) {\n      this.x = maxX;\n      this.vx = -this.vx;\n    }\n  };\n  \n  this.draw = function() {\n    var x = this.step.getX();\n    var y = h - this.step.getY();\n    // Adjust x and y to center of enemy\n    x += this.x;\n    y -= this.r + this.gap;\n    var s = this.size;\n    // Parameters are the left top coordinates\n    // of the step we are on\n    c.save();\n    // Draw the enemy as a filled red triangle\n    c.strokeStyle = 'red';\n    c.lineWidth = 2;\n    // Move to the center of the enemy\n    c.translate(x, y);\n    // Rotate as necessary\n    c.rotate(this.angle * Math.PI / 180);\n    // Draw a triangle\n    c.beginPath();\n    c.moveTo(-s / 3, s / 2);\n    c.lineTo(0, -s / 2);\n    c.lineTo(s / 3, s / 2);\n    c.closePath();\n    c.stroke();\n    c.restore();\n\n    // When the enemy is dying, spin it\n    // and shrink it\n    if (this.dying) {\n      this.angle += 10;\n      this.size = Math.max(0, this.size - 1);\n    }\n  };\n}\n\n\nfunction Step(index, height) {\n  // index is like the x coordinate for\n  // steps. The first step, at index 0, would\n  // be drawn from 0 to width in x.  The\n  // second step, at index 1, would be from\n  // x to 2x. Index 2 would be 2x to 3x, and\n  // so on.\n  this.index = index;\n  // height is how high off the ground this\n  // step is. On the ground is height 0.\n  // the first step off the ground will have\n  // a height of 1 and be drawn this.stepDiff\n  // pixels off the bottom (so at h - \n  // this.stepDiff). Height 2 will be 2 *\n  // this.stepDiff off the bottom, and so on.\n  this.height = height;\n  // Constants\n  this.width = w / 5;\n  this.stepDiff = 40;\n  \n  \n  this.init = function() {\n    // Don't allow anything on the first couple\n    // steps\n    if (this.index < 2) { return; }\n    // Randomly add rewards and enemies\n    if (Math.random() < (this.height + 1) / 10) {\n      // More rewards on higher, harder\n      // to get to steps\n      this.reward = new Reward(this);\n    }\n    if (Math.random() < \n        player.score / 10000 + 0.1) {\n      // Add more enemies the higher the \n      // score (increasing the difficulty)\n      this.enemy = new Enemy(this);\n    }\n  };\n  this.init();\n\n  this.playerIsOn = function(tolerance) {\n    tolerance = tolerance || 1;\n    // Returns true if the player is on this\n    // step\n    \n    // First check if the player is anywhere\n    // near this step\n    var x = this.getX();\n    if (player.x + player.r < x) {\n      // Player is way to the left\n      return false;\n    }\n    if (player.x - player.r > x + this.width) {\n      // Player is way to the right\n      return false;\n    }\n    var y = this.getY();\n    var diffY = player.y - y;\n    return (diffY >= 0 && diffY <= tolerance);\n  };\n\n  this.playerIsBelow = function(tolerance) {\n    tolerance = tolerance || 2;\n    // Returns true if the player is immediately\n    // below this step\n    \n    // First check if the player is anywhere\n    // near this step\n    var x = this.getX();\n    if (player.x + player.r < x) {\n      // Player is way to the left\n      return false;\n    }\n    if (player.x - player.r > x + this.width) {\n      // Player is way to the right\n      return false;\n    }\n    var y = this.getY();\n    var diffY = y - (player.y + player.size);\n    return (diffY >= 0 && diffY <= tolerance);\n  };\n\n  this.move = function() {\n    // If we have a reward or enemy, ask\n    // it to move itself\n    if (this.reward) {\n      this.reward.move();\n      if (this.reward.dying &&\n          this.reward.size <= 0) {\n        // The reward went from dying to dead.\n        // Remove it completely.\n        this.reward = undefined;\n      }\n    }\n    if (this.enemy) {\n      this.enemy.move();\n      if (this.enemy.dying &&\n          this.enemy.size <= 0) {\n        // The enemy went from dying to dead.\n        // Remove it completely.\n        this.enemy = undefined;\n      }\n    }\n  };\n  \n  this.draw = function() {\n    var x = this.getX();\n    // Stop immediately if we are off the\n    // screen\n    if (x + this.stepWidth < 0 ||\n        x > w) {\n      return;\n    }\n    var y = h - this.getY();\n    this.drawLine(x, y, x + this.width, y);\n    // If we have a reward or enemy, ask\n    // it to draw itself\n    if (this.reward) {\n      this.reward.draw();\n    }\n    if (this.enemy) {\n      this.enemy.draw();\n    }\n  };\n  \n  this.getX = function() {\n    // Returns left position of the step\n    var x = this.index * this.width;\n    x -= player.p;\n    return x;\n  };\n  \n  this.getY = function() {\n    // Returns y position (from bottom, not\n    // top of canvas, do (h - this.getY())\n    // to get the y position to use for\n    // drawing\n    var y = this.height * this.stepDiff;\n    return y;\n  };\n  \n  this.drawLine = function(x, y, x2, y2) {\n    // Draws a line from (x,y) to (x2, y2)\n    c.beginPath();\n    c.moveTo(x, y);\n    c.lineTo(x2, y2);\n    c.stroke();\n  };\n}\n\n\nfunction Steps() {\n  // Steps should be a unique ordered list,\n  // sorted by index, subsorted by height. So, \n  // if the last step in the list is\n  // at index 5 and height 3, the next step\n  // added has to be at least index 5 and \n  // height 4 (but could also be index 6\n  // and height 0, or anything else above index\n  // 5 and height 3)\n  this.steps = [];\n  // Likelihood of a step being added at each\n  // opportunity to add a step\n  this.stepChance = 0.5;\n\n  this.addNeeded = function() {\n    var len = this.steps.length;\n    var lastStep = this.steps[len - 1];\n    var maxIndex = lastStep.index;\n    var prevHeight = lastStep.height;\n    \n    // Given the last step, figure out\n    // how high maxIndex should be\n    var minNeeded = (w + player.p) /\n                    lastStep.width;\n    minNeeded = Math.ceil(minNeeded) - 1;\n    if (maxIndex < minNeeded) {\n      var newIndex = maxIndex + 1;\n      // Every index has a step at 0 (bottom)\n      this.steps.push(new Step(newIndex, 0));\n      // Find the ceiling\n      var maxHeight = h / lastStep.stepDiff;\n      maxHeight = Math.floor(maxHeight) - 1;\n      // Randomly add a step above the bottom\n      for (var i = 1; i >= -1; i--) {\n        if (i + prevHeight > 0 &&\n            i + prevHeight < maxHeight &&\n            Math.random() < this.stepChance) {\n          // Create a new step at this height\n          this.steps.push(new Step(newIndex,\n                              i + prevHeight));\n          // Once we create a step, stop\n          // creating any more at this index\n          // (there will be at most two steps\n          // per index)\n          break;\n        }\n      }\n      // Call ourselves again to add any more\n      // steps that are still needed\n      this.addNeeded();\n    }\n  };\n\n  this.init = function() {\n    // Start with a couple steps just at \n    // ground level\n    this.steps.push(new Step(0, 0));\n    this.steps.push(new Step(1, 0));\n    // Automatically add any more needed steps\n    this.addNeeded();\n  };\n  this.init();\n  \n  this.playerIsOnAnyStep = function(tolerance) {\n    tolerance = tolerance || 1;\n    for (var i = 0; i < this.steps.length; i++) {\n      if (this.steps[i].playerIsOn(tolerance)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  this.playerIsBelowAnyStep = \n    function(tolerance) {\n    tolerance = tolerance || 2;\n    for (var i = 0; i < this.steps.length; i++) {\n      var s = this.steps[i];\n      if (s.playerIsBelow(tolerance)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  this.move = function() {\n    for (var i = 0; i < this.steps.length; i++) {\n      this.steps[i].move();\n    }\n  };\n  \n  this.draw = function() {\n    for (var i = 0; i < this.steps.length; i++) {\n      this.steps[i].draw();\n    }\n  };\n}\n\nfunction Player() {\n  // Constants\n  this.r = 10;\n  this.size = this.r * 2;\n  this.x = w * 0.2;\n  this.jumpSpeed = 8;\n  this.moveSpeed = 2;\n  this.maxMove = 8;\n  this.gravity = -0.6;\n  this.bounce = 0.2;\n  this.friction = 0.8;\n  // Position\n  // Only the height is variable, x is\n  // constant.  The height is the height of\n  // the center off the bottom (so, the center\n  // of the player is at h - r - y in screen\n  // coordinates)\n  this.y = 0;\n  this.vy = 0;\n  // p is the location of the player in the\n  // world after moving left or right.\n  // The player is always drawn at x, but\n  // the rest of the world, all other objects,\n  // should use player.p to adjust where they\n  // are drawn.\n  this.p = 0;\n  // vp is the velocity of the player (change\n  // in p)\n  this.vp = 0;\n  // Score starts at 0, Health at 100\n  this.score = 0;\n  this.health = 100;\n  // Hunger is a cost to health charged every\n  // frame, the cost of staying alive\n  this.hunger = 0.03;\n  \n  this.move = function() {\n    // Was a jump requested? Can we jump?\n    if (this.jump && this.canJump()) {\n      // Jump!\n      this.vy = this.jumpSpeed;\n    }\n    if (this.right) {\n      this.vp += this.moveSpeed;\n      this.vp = Math.min(this.maxMove,\n                         this.vp);\n    }\n    if (this.left) {\n      this.vp -= this.moveSpeed;\n      this.vp = Math.max(-this.maxMove,\n                          this.vp);\n    }\n    this.y += this.vy;\n    this.vy += this.gravity;\n    this.p += this.vp;\n    this.p = Math.max(this.p, 0);\n    this.vp *= this.friction;\n    \n    // Are we on a step?\n    var tolerance = Math.max(-player.vy, 1);\n    if (this.vy < 0 &&\n        steps.playerIsOnAnyStep(tolerance)) {\n      // Bounce off a step\n      this.vy = this.bounce * -this.vy;\n    }\n    // Are we right below a step?\n    tolerance = Math.max(player.vy, 1);\n    if (this.vy > 0 &&\n        steps.playerIsBelowAnyStep(tolerance)) {\n      // Hit the ceiling with a thud\n      this.vy = 0;\n    }\n    \n    // Slowly reduce player health over time\n    this.health -= this.hunger;\n    this.health = Math.max(0, this.health);\n    if (this.health <= 0) {\n      this.gameOver = true;\n    }\n  };\n  \n  this.canJump = function() {\n    // This should check to make sure we are\n    // on top of a solid surface we can jump\n    // off of\n    var tolerance = Math.max(-player.vy, 8);\n    return steps.playerIsOnAnyStep(tolerance);\n  };\n    \n  this.draw = function() {\n    // The player is a simple circle\n    c.beginPath();\n    c.arc(this.x, h - this.y - this.r, this.r,\n          0, 2 * Math.PI);\n    c.stroke();\n  };\n}\n\n// Track keyboard events on the canvas.\n// The canvas doesn't normally respond to\n// keyboard events, but it will if we make\n// the content editable (or set the tabIndex)\nc.canvas.contentEditable = true;\nc.canvas.onkeydown = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = true;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = true;    \n    evt.preventDefault();  \n  }\n};\nc.canvas.onkeyup = function(evt) {\n  if (evt.keyCode == 38 || evt.keyCode == 87) {\n    // Up arrow or 'w' means jump\n    player.jump = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 37 || evt.keyCode == 65) {\n    // Left arrow or 'a' means left\n    player.left = false;\n    evt.preventDefault();\n  }\n  if (evt.keyCode == 39 || evt.keyCode == 68) {\n    // Right arrow or 'd' means right    \n    player.right = false;    \n    evt.preventDefault();  \n  }\n};\n\n\nvar player = new Player();\nvar steps = new Steps();\n\nfunction drawAllText() {\n  // Display score and health\n  c.fillText('Score: ' + player.score,\n             w * 0.8, 20);\n  c.fillText('Health: ' +\n             Math.ceil(player.health),\n             w * 0.05, 20);\n  // If the game is over, display game over\n  // text\n  if (player.gameOver) {\n    c.save();\n    c.font = '48pt sans-serif';\n    c.textAlign = 'center';\n    c.fillStyle = 'red';\n    c.textBaseline = 'middle';\n    c.fillText('GAME OVER', w / 2, h / 2);\n    c.restore();\n  }\n}\n  \n// Animation loop\nvar cmTID;\nvar timeStep = 50;  // milliseconds\nvar frameRate = 1000 / timeStep;\nfunction updateAll() {\n  // Move everything\n  player.move();\n  steps.move();\n  steps.addNeeded();\n  // Redraw everything\n  c.clearRect(0, 0, w, h);\n  player.draw();\n  steps.draw();\n  drawAllText();\n  \n  // Do everything again in a little bit\n  clearTimeout(cmTID);\n  if (!player.gameOver) {\n    cmTID = setTimeout(updateAll, timeStep);\n  }\n}\nupdateAll();",
      lessonSection: "Third Game Completed",
      tutorImage: 5,
    },
    { message: "Now is your chance to customize this in any way you want. Do you like a different color for the enemies or rewards? What if enemies reduced your score when touched? Maybe you think you should be able to jump higher?  What if gravity is stronger or weaker? Maybe you want enemies to look like circles instead of triangles? Maybe moving faster might be fun? Try some things, see if you can make the game better!",
      tutorImage: 2,
    },
    { message: "That's it! Three games written. Wow!",
      code: "// Three games! Three games! Three games!",
      lessonSection: "The End",
      tutorImage: 3,
    },
    { message: "You're at the end! Congratulations! Did you learn a lot? Write a lot of code? I'm impressed you finished, good job! I hope you enjoyed it!",
      code: "var s = 10;\n\nc.canvas.onmousemove = function(evt) {\n  c.fillStyle = randomRGBA();\n  var x = evt.clientX;\n  var y = evt.clientY;\n  c.fillRect(x - s / 2, y - s / 2, s, s);};\n\nfunction randomRGBA() {\n  var r = randInt(255);\n  var g = randInt(255);\n  var b = randInt(255);\n  var a = Math.random();\n  var rgba = [r,g,b,a].join(',');\n  return 'rgba(' + rgba + ')';\n}\n\nfunction randInt(limit) {\n  var x = Math.random() * limit;\n  return Math.floor(x);\n}\n",
      tutorImage: 1,
    },
  ];


// To keep JSHint from complaining about variables and functions in
// the hidden code, list them here.  The boolean is whether they can
// be overridden by user code.
var predefForJSHint = {c: true, 
					   rgb: true, 
					   rgba: true,
					  };


// Images for tutor, referenced by the lessons to switch
var tutorImages = [ "i/maven1-h250.png",
					"i/maven2-h250.png",
					"i/maven3-h250.png",
					"i/maven4-h250.png",
					"i/maven5-h250.png",
					"i/maven6-h250.png",
					"i/maven7-h250.png",
				  ];
